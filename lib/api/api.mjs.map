{"version":3,"sources":["../../src/api/api.ts","../../src/common/logger.ts","../../src/common/utility.ts","../../src/module/amount.ts","../../src/common/bignumber.ts","../../src/module/formatter.ts","../../src/module/fraction.ts","../../src/raydium/token/constant.ts","../../src/module/token.ts","../../src/common/pubKey.ts","../../src/module/currency.ts","../../src/module/percent.ts","../../src/module/price.ts","../../src/common/txTool.ts","../../src/common/accountInfo.ts"],"sourcesContent":["import axios, { AxiosInstance } from \"axios\";\n\nimport { createLogger, sleep } from \"../common\";\nimport { Raydium } from \"../raydium\";\nimport { Cluster } from \"../solana\";\n\nimport { ApiFarmPools, ApiJsonPairInfo, ApiLiquidityPools, ApiTokens } from \"./type\";\n\nconst logger = createLogger(\"Raydium_Api\");\n\nexport async function endlessRetry<T>(name: string, call: () => Promise<T>, interval = 1000): Promise<T> {\n  let result: T | undefined;\n\n  while (result == undefined) {\n    try {\n      logger.debug(`Request ${name} through endlessRetry`);\n      result = await call();\n    } catch (err) {\n      logger.error(`Request ${name} failed, retry after ${interval} ms`, err);\n      await sleep(interval);\n    }\n  }\n\n  return result;\n}\n\nexport interface ApiProps {\n  cluster: Cluster;\n  timeout: number;\n}\n\nexport class Api {\n  public cluster: Cluster;\n\n  public api: AxiosInstance;\n\n  constructor({ cluster, timeout }: ApiProps) {\n    this.cluster = cluster;\n\n    this.api = axios.create({ baseURL: \"https://api.raydium.io/v2\", timeout });\n\n    this.api.interceptors.request.use(\n      (config) => {\n        // before request\n        const { method, baseURL, url } = config;\n\n        logger.debug(`${method?.toUpperCase()} ${baseURL}${url}`);\n\n        return config;\n      },\n      (error) => {\n        // request error\n        logger.error(`Request failed`);\n\n        return Promise.reject(error);\n      },\n    );\n    this.api.interceptors.response.use(\n      (response) => {\n        // 2xx\n        const { config, data, status } = response;\n        const { method, baseURL, url } = config;\n\n        logger.debug(`${method?.toUpperCase()} ${baseURL}${url}  ${status}`);\n\n        return data;\n      },\n      (error) => {\n        // https://axios-http.com/docs/handling_errors\n        // not 2xx\n        const { config, response = {} } = error;\n        const { status } = response;\n        const { method, baseURL, url } = config;\n\n        logger.error(`${method.toUpperCase()} ${baseURL}${url} ${status || error.message}`);\n\n        return Promise.reject(error);\n      },\n    );\n  }\n\n  async getTokens(): Promise<ApiTokens> {\n    return this.api.get(`/sdk/token/raydium.mainnet.json`);\n  }\n\n  async getLiquidityPools(): Promise<ApiLiquidityPools> {\n    return this.api.get(`/sdk/liquidity/${this.cluster}.json`);\n  }\n\n  async getPairsInfo(): Promise<ApiJsonPairInfo[]> {\n    return this.api.get(\"https://api.raydium.io/v2/main/pairs\");\n  }\n\n  async getFarmPools(): Promise<ApiFarmPools> {\n    return this.api.get(`/sdk/farm-v2/${this.cluster}.json`);\n  }\n\n  async getCoingeckoPrice(coingeckoIds: string[]): Promise<Record<string, { usd?: number }>> {\n    return this.api.get(\n      `https://api.coingecko.com/api/v3/simple/price?ids=${coingeckoIds.join(\",\")}&vs_currencies=usd`,\n    );\n  }\n\n  async getRaydiumTokenPrice(): Promise<Record<string, number>> {\n    return this.api.get(\"https://api.raydium.io/v2/main/price\");\n  }\n\n  async getBlockSlotCountForSecond(endpointUrl?: string): Promise<number> {\n    if (!endpointUrl) return 2;\n    const res: {\n      id: string;\n      jsonrpc: string;\n      result: { numSlots: number; numTransactions: number; samplePeriodSecs: number; slot: number }[];\n    } = await this.api.post(endpointUrl, {\n      id: \"getRecentPerformanceSamples\",\n      jsonrpc: \"2.0\",\n      method: \"getRecentPerformanceSamples\",\n      params: [4],\n    });\n    const slotList = res.result.map((data) => data.numSlots);\n    return slotList.reduce((a, b) => a + b, 0) / slotList.length / 60;\n  }\n}\n","import { get, set } from \"lodash\";\nimport dayjs from \"dayjs\";\nimport utc from \"dayjs/plugin/utc\";\ndayjs.extend(utc);\n\nexport type ModuleName = \"Common.Api\";\n\nexport enum LogLevel {\n  Error,\n  Warning,\n  Info,\n  Debug,\n}\nexport class Logger {\n  private logLevel: LogLevel;\n  private name: string;\n  constructor(params: { name: string; logLevel?: LogLevel }) {\n    this.logLevel = params.logLevel !== undefined ? params.logLevel : LogLevel.Error;\n    this.name = params.name;\n  }\n\n  set level(logLevel: LogLevel) {\n    this.logLevel = logLevel;\n  }\n  get time(): string {\n    return dayjs().utc().format(\"YYYY/MM/DD HH:mm:ss UTC\");\n  }\n  get moduleName(): string {\n    return this.name;\n  }\n\n  private isLogLevel(level: LogLevel): boolean {\n    return level <= this.logLevel;\n  }\n\n  public error(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Error)) return this;\n    console.error(this.time, this.name, \"sdk logger error\", ...props);\n    return this;\n  }\n\n  public logWithError(...props): Logger {\n    // this.error(...props)\n    const msg = props.map((arg) => (typeof arg === \"object\" ? JSON.stringify(arg) : arg)).join(\", \");\n    throw new Error(msg);\n  }\n\n  public warning(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Warning)) return this;\n    console.warn(this.time, this.name, \"sdk logger warning\", ...props);\n    return this;\n  }\n\n  public info(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Info)) return this;\n    console.info(this.time, this.name, \"sdk logger info\", ...props);\n    return this;\n  }\n\n  public debug(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Debug)) return this;\n    console.debug(this.time, this.name, \"sdk logger debug\", ...props);\n    return this;\n  }\n}\n\nconst moduleLoggers: { [key in ModuleName]?: Logger } = {};\nconst moduleLevels: { [key in ModuleName]?: LogLevel } = {};\n\nexport function createLogger(moduleName: string): Logger {\n  let logger = get(moduleLoggers, moduleName);\n  if (!logger) {\n    // default level is error\n    const logLevel = get(moduleLevels, moduleName);\n\n    logger = new Logger({ name: moduleName, logLevel });\n    set(moduleLoggers, moduleName, logger);\n  }\n\n  return logger;\n}\n\nexport function setLoggerLevel(moduleName: string, level: LogLevel): void {\n  set(moduleLevels, moduleName, level);\n\n  const logger = get(moduleLoggers, moduleName);\n  if (logger) logger.level = level;\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\n\nimport { Fraction, Percent, Price, Token, TokenAmount } from \"../module\";\nimport { ReplaceType } from \"../raydium/type\";\n\nimport { tryParsePublicKey } from \"./pubKey\";\n\nexport async function sleep(ms: number): Promise<void> {\n  new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function getTimestamp(): number {\n  return new Date().getTime();\n}\n\nconst baseInnerObjects = [Token, TokenAmount, PublicKey, Fraction, BN, Price, Percent];\n\nfunction notInnerObject(v: unknown): v is Record<string, any> {\n  return typeof v === \"object\" && v !== null && !baseInnerObjects.some((o) => typeof o === \"object\" && v instanceof o);\n}\n\nexport function jsonInfo2PoolKeys<T>(jsonInfo: T): ReplaceType<T, string, PublicKey> {\n  // @ts-expect-error no need type for inner code\n  return typeof jsonInfo === \"string\"\n    ? tryParsePublicKey(jsonInfo)\n    : Array.isArray(jsonInfo)\n    ? jsonInfo.map((k) => jsonInfo2PoolKeys(k))\n    : notInnerObject(jsonInfo)\n    ? Object.fromEntries(Object.entries(jsonInfo).map(([k, v]) => [k, jsonInfo2PoolKeys(v)]))\n    : jsonInfo;\n}\n","import _Big from \"big.js\";\nimport BN from \"bn.js\";\n\nimport { BigNumberish, BN_TEN, parseBigNumberish, Rounding } from \"../common/bignumber\";\nimport { createLogger, Logger } from \"../common/logger\";\n\nimport toFormat, { WrappedBig } from \"./formatter\";\nimport { Fraction } from \"./fraction\";\nimport { Token } from \"./token\";\n\nconst logger = createLogger(\"Raydium_amount\");\n\nconst Big = toFormat(_Big);\ntype Big = WrappedBig;\n\nexport function splitNumber(num: string, decimals: number): [string, string] {\n  let integral = \"0\";\n  let fractional = \"0\";\n\n  if (num.includes(\".\")) {\n    const splited = num.split(\".\");\n    if (splited.length === 2) {\n      [integral, fractional] = splited;\n      fractional = fractional.padEnd(decimals, \"0\");\n    } else {\n      logger.logWithError(`invalid number string, num: ${num}`);\n    }\n  } else {\n    integral = num;\n  }\n\n  // fix decimals is 0\n  return [integral, fractional.slice(0, decimals) || fractional];\n}\n\nexport class TokenAmount extends Fraction {\n  public readonly token: Token;\n  protected logger: Logger;\n\n  public constructor(token: Token, amount: BigNumberish, isRaw = true, name?: string) {\n    let parsedAmount = new BN(0);\n    const multiplier = BN_TEN.pow(new BN(token.decimals));\n\n    if (isRaw) {\n      parsedAmount = parseBigNumberish(amount);\n    } else {\n      let integralAmount = new BN(0);\n      let fractionalAmount = new BN(0);\n\n      // parse fractional string\n      if (typeof amount === \"string\" || typeof amount === \"number\" || typeof amount === \"bigint\") {\n        const [integral, fractional] = splitNumber(amount.toString(), token.decimals);\n        integralAmount = parseBigNumberish(integral);\n        fractionalAmount = parseBigNumberish(fractional);\n      }\n\n      integralAmount = integralAmount.mul(multiplier);\n      parsedAmount = integralAmount.add(fractionalAmount);\n    }\n\n    super(parsedAmount, multiplier);\n    this.logger = createLogger(name || \"Amount\");\n    this.token = token;\n  }\n\n  public get raw(): BN {\n    return this.numerator;\n  }\n  public isZero(): boolean {\n    return this.raw.isZero();\n  }\n  public gt(other: TokenAmount): boolean {\n    if (!this.token.equals(other.token)) this.logger.logWithError(\"gt token not equals\");\n    return this.raw.gt(other.raw);\n  }\n\n  /**\n   * a less than b\n   */\n  public lt(other: TokenAmount): boolean {\n    if (!this.token.equals(other.token)) this.logger.logWithError(\"lt token not equals\");\n    return this.raw.lt(other.raw);\n  }\n\n  public add(other: TokenAmount): TokenAmount {\n    if (!this.token.equals(other.token)) this.logger.logWithError(\"add token not equals\");\n    return new TokenAmount(this.token, this.raw.add(other.raw));\n  }\n\n  public subtract(other: TokenAmount): TokenAmount {\n    if (!this.token.equals(other.token)) this.logger.logWithError(\"sub token not equals\");\n    return new TokenAmount(this.token, this.raw.sub(other.raw));\n  }\n\n  public toSignificant(\n    significantDigits = this.token.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN,\n  ): string {\n    return super.toSignificant(significantDigits, format, rounding);\n  }\n\n  /**\n   * To fixed\n   *\n   * @example\n   * ```\n   * 1 -> 1.000000000\n   * 1.234 -> 1.234000000\n   * 1.123456789876543 -> 1.123456789\n   * ```\n   */\n  public toFixed(\n    decimalPlaces = this.token.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN,\n  ): string {\n    if (decimalPlaces > this.token.decimals) this.logger.logWithError(\"decimals overflow\");\n    return super.toFixed(decimalPlaces, format, rounding);\n  }\n\n  /**\n   * To exact\n   *\n   * @example\n   * ```\n   * 1 -> 1\n   * 1.234 -> 1.234\n   * 1.123456789876543 -> 1.123456789\n   * ```\n   */\n  public toExact(format: object = { groupSeparator: \"\" }): string {\n    Big.DP = this.token.decimals;\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);\n  }\n}\n\n// export class TokenAmount extends CurrencyAmount {\n//   public readonly token: Token;\n\n//   public constructor(token: Token, amount: BigNumberish, isRaw = true) {\n//     super(token, amount, isRaw);\n//     this.token = token;\n//   }\n\n//   public add(other: TokenAmount): TokenAmount {\n//     if (!currencyEquals(this.token, other.token)) this.logger.logWithError(\"add token not equals\");\n//     return new TokenAmount(this.token, this.raw.add(other.raw));\n//   }\n\n//   public subtract(other: TokenAmount): TokenAmount {\n//     if (!currencyEquals(this.token, other.token)) this.logger.logWithError(\"sub token not equals\");\n//     return new TokenAmount(this.token, this.raw.sub(other.raw));\n//   }\n// }\n","import BN from \"bn.js\";\n\nimport { Fraction, Percent, Price, TokenAmount, Token } from \"../module\";\nimport { SplToken, TokenJson } from \"../raydium/token/type\";\nimport { createLogger } from \"./logger\";\n\nconst logger = createLogger(\"Raydium_bignumber\");\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP,\n}\n\nexport const BN_ZERO = new BN(0);\nexport const BN_ONE = new BN(1);\nexport const BN_TWO = new BN(2);\nexport const BN_THREE = new BN(3);\nexport const BN_FIVE = new BN(5);\nexport const BN_TEN = new BN(10);\nexport const BN_100 = new BN(100);\nexport const BN_1000 = new BN(1000);\nexport const BN_10000 = new BN(10000);\nexport type BigNumberish = BN | string | number | bigint;\nexport type Numberish = number | string | bigint | Fraction | BN;\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\nexport function parseBigNumberish(value: BigNumberish): BN {\n  // BN\n  if (value instanceof BN) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    if (value.match(/^-?[0-9]+$/)) {\n      return new BN(value);\n    }\n    logger.logWithError(`invalid BigNumberish string: ${value}`);\n  }\n\n  if (typeof value === \"number\") {\n    if (value % 1) {\n      logger.logWithError(`BigNumberish number underflow: ${value}`);\n    }\n\n    if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n      logger.logWithError(`BigNumberish number overflow: ${value}`);\n    }\n\n    return new BN(String(value));\n  }\n\n  if (typeof value === \"bigint\") {\n    return new BN(value.toString());\n  }\n  logger.logWithError(`invalid BigNumberish value: ${value}`);\n  return new BN(0); // never reach, because logWithError will throw error\n}\n\nexport function tenExponential(shift: BigNumberish): BN {\n  return BN_TEN.pow(parseBigNumberish(shift));\n}\n\n/**\n *\n * @example\n * getIntInfo(0.34) //=> { numerator: '34', denominator: '100'}\n * getIntInfo('0.34') //=> { numerator: '34', denominator: '100'}\n */\nexport function parseNumberInfo(n: Numberish | undefined): {\n  denominator: string;\n  numerator: string;\n  sign?: string;\n  int?: string;\n  dec?: string;\n} {\n  if (n === undefined) return { denominator: \"1\", numerator: \"0\" };\n  if (n instanceof BN) {\n    return { numerator: n.toString(), denominator: \"1\" };\n  }\n\n  if (n instanceof Fraction) {\n    return { denominator: n.denominator.toString(), numerator: n.numerator.toString() };\n  }\n\n  const s = String(n);\n  const [, sign = \"\", int = \"\", dec = \"\"] = s.replace(\",\", \"\").match(/(-?)(\\d*)\\.?(\\d*)/) ?? [];\n  const denominator = \"1\" + \"0\".repeat(dec.length);\n  const numerator = sign + (int === \"0\" ? \"\" : int) + dec || \"0\";\n  return { denominator, numerator, sign, int, dec };\n}\n\n// round up\nexport function divCeil(a: BN, b: BN): BN {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const dm = a.divmod(b);\n\n  // Fast case - exact division\n  if (dm.mod.isZero()) return dm.div;\n\n  // Round up\n  return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n}\n\nexport function shakeFractionDecimal(n: Fraction): string {\n  const [, sign = \"\", int = \"\"] = n.toFixed(2).match(/(-?)(\\d*)\\.?(\\d*)/) ?? [];\n  return `${sign}${int}`;\n}\n\nexport function toBN(n: Numberish, decimal: BigNumberish = 0): BN {\n  if (n instanceof BN) return n;\n  return new BN(shakeFractionDecimal(toFraction(n).mul(BN_TEN.pow(new BN(String(decimal))))));\n}\n\nexport function toFraction(value: Numberish): Fraction {\n  //  to complete math format(may have decimal), not int\n  if (value instanceof Percent) return new Fraction(value.numerator, value.denominator);\n\n  if (value instanceof Price) return value.adjusted;\n\n  // to complete math format(may have decimal), not BN\n  if (value instanceof TokenAmount)\n    try {\n      return toFraction(value.toExact());\n    } catch {\n      return new Fraction(BN_ZERO);\n    }\n\n  // do not ideal with other fraction value\n  if (value instanceof Fraction) return value;\n\n  // wrap to Fraction\n  const n = String(value);\n  const details = parseNumberInfo(n);\n  return new Fraction(details.numerator, details.denominator);\n}\n\n/**\n * @example\n * toPercent(3.14) // => Percent { 314.00% }\n * toPercent(3.14, { alreadyDecimaled: true }) // => Percent {3.14%}\n */\nexport function toPercent(\n  n: Numberish,\n  options?: { /* usually used for backend data */ alreadyDecimaled?: boolean },\n): Percent {\n  const { numerator, denominator } = parseNumberInfo(n);\n  return new Percent(new BN(numerator), new BN(denominator).mul(options?.alreadyDecimaled ? new BN(100) : new BN(1)));\n}\n\nexport function toTokenPrice(params: {\n  token: TokenJson | Token | SplToken;\n  numberPrice: Numberish;\n  decimalDone?: boolean;\n}): Price {\n  const { token, numberPrice, decimalDone } = params;\n  const usdCurrency = new Token({ mint: \"\", decimals: 6, symbol: \"usd\", name: \"usd\", skipMint: true });\n  const { numerator, denominator } = parseNumberInfo(numberPrice);\n  const parsedNumerator = decimalDone ? new BN(numerator).mul(BN_TEN.pow(new BN(token.decimals))) : numerator;\n  const parsedDenominator = new BN(denominator).mul(BN_TEN.pow(new BN(usdCurrency.decimals)));\n\n  return new Price({\n    baseToken: usdCurrency,\n    denominator: parsedDenominator.toString(),\n    quoteToken: new Token({ ...token, skipMint: true, mint: \"\" }),\n    numerator: parsedNumerator.toString(),\n  });\n}\n\nexport function mul(a: Numberish | undefined, b: Numberish | undefined): Fraction | undefined {\n  if (a == null || b == null) return undefined;\n  const fa = toFraction(a);\n  const fb = toFraction(b);\n  return fa.mul(fb);\n}\n\nexport function toUsdCurrency(amount: Numberish): TokenAmount {\n  const usdCurrency = new Token({ mint: \"\", decimals: 6, symbol: \"usd\", name: \"usd\", skipMint: true });\n  const amountBigNumber = toBN(mul(amount, 10 ** usdCurrency.decimals)!);\n  return new TokenAmount(usdCurrency, amountBigNumber);\n}\n\nexport function toTotalPrice(amount: Numberish | undefined, price: Price | undefined): TokenAmount {\n  if (!price || !amount) return toUsdCurrency(0);\n  return toUsdCurrency(mul(amount, price)!);\n}\n","import Big, { BigConstructor, BigSource, RoundingMode } from \"big.js\";\nimport Decimal, { Config, Numeric } from \"decimal.js-light\";\nimport _toFarmat from \"toformat\";\n\ntype TakeStatic<T> = { [P in keyof T]: T[P] };\ninterface FormatOptions {\n  decimalSeparator?: string;\n  groupSeparator?: string;\n  groupSize?: number;\n  fractionGroupSeparator?: string;\n  fractionGroupSize?: number;\n}\ninterface WrappedBigConstructor extends TakeStatic<BigConstructor> {\n  new (value: BigSource): WrappedBig;\n  (value: BigSource): WrappedBig;\n  (): WrappedBigConstructor;\n\n  format: FormatOptions;\n}\nexport interface WrappedBig extends Big {\n  add(n: BigSource): WrappedBig;\n  abs(): WrappedBig;\n  div(n: BigSource): WrappedBig;\n  minus(n: BigSource): WrappedBig;\n  mod(n: BigSource): WrappedBig;\n  mul(n: BigSource): WrappedBig;\n  plus(n: BigSource): WrappedBig;\n  pow(exp: number): WrappedBig;\n  round(dp?: number, rm?: RoundingMode): WrappedBig;\n  sqrt(): WrappedBig;\n  sub(n: BigSource): WrappedBig;\n  times(n: BigSource): WrappedBig;\n  toFormat(): string;\n  toFormat(options: FormatOptions): string;\n  toFormat(fractionLength: number): string;\n  toFormat(fractionLength: number, options: FormatOptions): string;\n  toFormat(fractionLength: number, missionUnknown: number): string;\n  toFormat(fractionLength: number, missionUnknown: number, options: FormatOptions): string;\n}\n\ntype DecimalConstructor = typeof Decimal;\ninterface WrappedDecimalConstructor extends TakeStatic<DecimalConstructor> {\n  new (value: Numeric): WrappedDecimal;\n  clone(config?: Config): WrappedDecimalConstructor;\n  config(config: Config): WrappedDecimal;\n  set(config: Config): WrappedDecimal;\n  format: FormatOptions;\n}\nexport interface WrappedDecimal extends Decimal {\n  absoluteValue(): WrappedDecimal;\n  abs(): WrappedDecimal;\n  dividedBy(y: Numeric): WrappedDecimal;\n  div(y: Numeric): WrappedDecimal;\n  dividedToIntegerBy(y: Numeric): WrappedDecimal;\n  idiv(y: Numeric): WrappedDecimal;\n  logarithm(base?: Numeric): WrappedDecimal;\n  log(base?: Numeric): WrappedDecimal;\n  minus(y: Numeric): WrappedDecimal;\n  sub(y: Numeric): WrappedDecimal;\n  modulo(y: Numeric): WrappedDecimal;\n  mod(y: Numeric): WrappedDecimal;\n  naturalExponetial(): WrappedDecimal;\n  exp(): WrappedDecimal;\n  naturalLogarithm(): WrappedDecimal;\n  ln(): WrappedDecimal;\n  negated(): WrappedDecimal;\n  neg(): WrappedDecimal;\n  plus(y: Numeric): WrappedDecimal;\n  add(y: Numeric): WrappedDecimal;\n  squareRoot(): WrappedDecimal;\n  sqrt(): WrappedDecimal;\n  times(y: Numeric): WrappedDecimal;\n  mul(y: Numeric): WrappedDecimal;\n  toWrappedDecimalPlaces(dp?: number, rm?: number): WrappedDecimal;\n  todp(dp?: number, rm?: number): WrappedDecimal;\n  toInteger(): WrappedDecimal;\n  toint(): WrappedDecimal;\n  toPower(y: Numeric): WrappedDecimal;\n  pow(y: Numeric): WrappedDecimal;\n  toSignificantDigits(sd?: number, rm?: number): WrappedDecimal;\n  tosd(sd?: number, rm?: number): WrappedDecimal;\n  toFormat(options: FormatOptions): string;\n  toFormat(fractionLength: number): string;\n  toFormat(fractionLength: number, options: FormatOptions): string;\n  toFormat(fractionLength: number, missionUnknown: number): string;\n  toFormat(fractionLength: number, missionUnknown: number, options: FormatOptions): string;\n}\n\nconst toFormat: {\n  (fn: BigConstructor): WrappedBigConstructor;\n  (fn: DecimalConstructor): WrappedDecimalConstructor;\n} = _toFarmat;\nexport default toFormat;\n","import _Big from \"big.js\";\nimport BN from \"bn.js\";\nimport _Decimal from \"decimal.js-light\";\n\nimport { BigNumberish, BN_ONE, parseBigNumberish, Rounding } from \"../common/bignumber\";\nimport { createLogger } from \"../common/logger\";\n\nimport toFormat, { WrappedBig } from \"./formatter\";\n\nconst logger = createLogger(\"module/fraction\");\n\nconst Big = toFormat(_Big);\ntype Big = WrappedBig;\n\nconst Decimal = toFormat(_Decimal);\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP,\n};\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: _Big.roundDown,\n  [Rounding.ROUND_HALF_UP]: _Big.roundHalfUp,\n  [Rounding.ROUND_UP]: _Big.roundUp,\n};\n\nexport class Fraction {\n  public readonly numerator: BN;\n  public readonly denominator: BN;\n\n  public constructor(numerator: BigNumberish, denominator: BigNumberish = BN_ONE) {\n    this.numerator = parseBigNumberish(numerator);\n    this.denominator = parseBigNumberish(denominator);\n  }\n\n  public get quotient(): BN {\n    return this.numerator.div(this.denominator);\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator);\n  }\n\n  public add(other: Fraction | BigNumberish): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigNumberish(other));\n\n    if (this.denominator.eq(otherParsed.denominator)) {\n      return new Fraction(this.numerator.add(otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator).add(otherParsed.numerator.mul(this.denominator)),\n      this.denominator.mul(otherParsed.denominator),\n    );\n  }\n\n  public sub(other: Fraction | BigNumberish): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigNumberish(other));\n\n    if (this.denominator.eq(otherParsed.denominator)) {\n      return new Fraction(this.numerator.sub(otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator).sub(otherParsed.numerator.mul(this.denominator)),\n      this.denominator.mul(otherParsed.denominator),\n    );\n  }\n\n  public mul(other: Fraction | BigNumberish): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigNumberish(other));\n\n    return new Fraction(this.numerator.mul(otherParsed.numerator), this.denominator.mul(otherParsed.denominator));\n  }\n\n  public div(other: Fraction | BigNumberish): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigNumberish(other));\n\n    return new Fraction(this.numerator.mul(otherParsed.denominator), this.denominator.mul(otherParsed.numerator));\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: \"\" },\n    rounding: Rounding = Rounding.ROUND_HALF_UP,\n  ): string {\n    if (!Number.isInteger(significantDigits)) logger.logWithError(`${significantDigits} is not an integer.`);\n    if (significantDigits <= 0) logger.logWithError(`${significantDigits} is not positive.`);\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] });\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits);\n    return quotient.toFormat(quotient.decimalPlaces(), format);\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: \"\" },\n    rounding: Rounding = Rounding.ROUND_HALF_UP,\n  ): string {\n    if (!Number.isInteger(decimalPlaces)) logger.logWithError(`${decimalPlaces} is not an integer.`);\n    if (decimalPlaces < 0) logger.logWithError(`${decimalPlaces} is negative.`);\n\n    Big.DP = decimalPlaces;\n    Big.RM = toFixedRounding[rounding] || 1;\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);\n  }\n\n  public isZero(): boolean {\n    return this.numerator.isZero();\n  }\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { NativeTokenInfo, SplTokenInfo } from \"./type\";\n\nexport const TOKEN_SOL: NativeTokenInfo = {\n  symbol: \"SOL\",\n  name: \"Solana\",\n  decimals: 9,\n};\n\nexport const TOKEN_WSOL: SplTokenInfo = {\n  symbol: \"WSOL\",\n  name: \"Wrapped SOL\",\n  mint: \"So11111111111111111111111111111111111111112\",\n  decimals: 9,\n  extensions: {\n    coingeckoId: \"solana\",\n  },\n};\n\nexport const quantumSOLHydratedTokenJsonInfo = {\n  isQuantumSOL: true,\n  isLp: false,\n  official: true,\n  mint: new PublicKey(TOKEN_WSOL.mint),\n  decimals: 9,\n  symbol: \"SOL\",\n  id: \"sol\",\n  name: \"solana\",\n  icon: `https://img.raydium.io/icon/So11111111111111111111111111111111111111112.png`,\n  extensions: {\n    coingeckoId: \"solana\",\n  },\n};\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { PublicKeyish, SOLMint, validateAndParsePublicKey } from \"../common/pubKey\";\nimport { TOKEN_WSOL } from \"../raydium/token/constant\";\n\n/**\n * A token is any fungible financial instrument on Solana, including SOL and all SPL tokens.\n */\nexport interface TokenProps {\n  mint: PublicKeyish;\n  decimals: number;\n  symbol?: string;\n  name?: string;\n  skipMint?: boolean;\n}\n\nexport class Token {\n  public readonly symbol?: string;\n  public readonly name?: string;\n  public readonly decimals: number;\n\n  public readonly mint: PublicKey;\n  public static readonly WSOL: Token = new Token(TOKEN_WSOL);\n\n  /**\n   *\n   * @param mint - pass \"sol\" as mint will auto generate wsol token config\n   */\n  public constructor({ mint, decimals, symbol = \"UNKNOWN\", name = \"UNKNOWN\", skipMint = false }: TokenProps) {\n    if (mint === SOLMint.toBase58() || (mint instanceof PublicKey && SOLMint.equals(mint))) {\n      this.decimals = TOKEN_WSOL.decimals;\n      this.symbol = TOKEN_WSOL.symbol;\n      this.name = TOKEN_WSOL.name;\n      this.mint = new PublicKey(TOKEN_WSOL.mint);\n      return;\n    }\n\n    this.decimals = decimals;\n    this.symbol = symbol;\n    this.name = name;\n    this.mint = skipMint ? PublicKey.default : validateAndParsePublicKey({ publicKey: mint });\n  }\n\n  public equals(other: Token): boolean {\n    // short circuit on reference equality\n    if (this === other) {\n      return true;\n    }\n    return this.mint.equals(other.mint);\n  }\n}\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { AccountMeta, PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\n\ninterface AccountMetaProps {\n  pubkey: PublicKey;\n  isSigner?: boolean;\n  isWritable?: boolean;\n}\n\nexport function accountMeta({ pubkey, isSigner = false, isWritable = true }: AccountMetaProps): AccountMeta {\n  return {\n    pubkey,\n    isWritable,\n    isSigner,\n  };\n}\n\nexport const commonSystemAccountMeta = [\n  accountMeta({ pubkey: TOKEN_PROGRAM_ID, isWritable: false }),\n  accountMeta({ pubkey: SystemProgram.programId, isWritable: false }),\n  accountMeta({ pubkey: SYSVAR_RENT_PUBKEY, isWritable: false }),\n];\n\nexport type PublicKeyish = PublicKey | string;\n\nexport function validateAndParsePublicKey({\n  publicKey,\n  transformSol,\n}: {\n  publicKey: PublicKeyish;\n  transformSol?: boolean;\n}): PublicKey {\n  if (publicKey instanceof PublicKey) {\n    if (transformSol && publicKey.equals(SOLMint)) return WSOLMint;\n    return publicKey;\n  }\n\n  if (transformSol && publicKey === SOLMint.toBase58()) return WSOLMint;\n\n  if (typeof publicKey === \"string\") {\n    try {\n      const key = new PublicKey(publicKey);\n      return key;\n    } catch {\n      throw new Error(\"invalid public key\");\n    }\n  }\n\n  throw new Error(\"invalid public key\");\n}\n\nexport function tryParsePublicKey(v: string): PublicKey | string {\n  try {\n    return new PublicKey(v);\n  } catch (e) {\n    return v;\n  }\n}\n\nexport const RAYMint = new PublicKey(\"4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R\");\nexport const PAIMint = new PublicKey(\"Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS\");\nexport const SRMMint = new PublicKey(\"SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt\");\nexport const USDCMint = new PublicKey(\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\");\nexport const USDTMint = new PublicKey(\"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB\");\nexport const mSOLMint = new PublicKey(\"mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So\");\nexport const stSOLMint = new PublicKey(\"7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj\");\nexport const USDHMint = new PublicKey(\"USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX\");\nexport const NRVMint = new PublicKey(\"NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa\");\nexport const ANAMint = new PublicKey(\"ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo\");\nexport const ETHMint = new PublicKey(\"7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs\");\nexport const WSOLMint = new PublicKey(\"So11111111111111111111111111111111111111112\");\nexport const SOLMint = PublicKey.default;\n","import { TOKEN_SOL } from \"../raydium/token/constant\";\n\nimport { Token } from \"./token\";\n\ninterface CurrencyProps {\n  decimals: number;\n  symbol?: string;\n  name?: string;\n}\n/**\n * A currency is any fungible financial instrument on Solana, including SOL and all SPL tokens.\n * The only instance of the base class `Currency` is SOL.\n */\nexport class Currency {\n  public readonly symbol?: string;\n  public readonly name?: string;\n  public readonly decimals: number;\n\n  /**\n   * The only instance of the base class `Currency`.\n   */\n  public static readonly SOL: Currency = new Currency(TOKEN_SOL);\n\n  /**\n   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.SOL`.\n   * @param decimals - decimals of the currency\n   * @param symbol - symbol of the currency\n   * @param name - name of the currency\n   */\n  public constructor({ decimals, symbol = \"UNKNOWN\", name = \"UNKNOWN\" }: CurrencyProps) {\n    this.decimals = decimals;\n    this.symbol = symbol;\n    this.name = name;\n  }\n\n  public equals(other: Currency): boolean {\n    return this === other;\n  }\n}\n\n/**\n * Compares two currencies for equality\n */\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB);\n  } else if (currencyA instanceof Token || currencyB instanceof Token) {\n    return false;\n  } else {\n    return currencyA === currencyB;\n  }\n}\n","import { BN_100, Rounding } from \"../common/bignumber\";\n\nimport { Fraction } from \"./fraction\";\n\nexport const _100_PERCENT = new Fraction(BN_100);\n\nexport class Percent extends Fraction {\n  public toSignificant(significantDigits = 5, format?: object, rounding?: Rounding): string {\n    return this.mul(_100_PERCENT).toSignificant(significantDigits, format, rounding);\n  }\n\n  public toFixed(decimalPlaces = 2, format?: object, rounding?: Rounding): string {\n    return this.mul(_100_PERCENT).toFixed(decimalPlaces, format, rounding);\n  }\n}\n","import { BigNumberish, Rounding, tenExponential } from \"../common/bignumber\";\nimport { createLogger } from \"../common/logger\";\n\nimport { Fraction } from \"./fraction\";\nimport { Token } from \"./token\";\n\nconst logger = createLogger(\"Raydium_price\");\n\ninterface PriceProps {\n  baseToken: Token;\n  denominator: BigNumberish;\n  quoteToken: Token;\n  numerator: BigNumberish;\n}\n\nexport class Price extends Fraction {\n  public readonly baseToken: Token; // input i.e. denominator\n  public readonly quoteToken: Token; // output i.e. numerator\n  // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n  public readonly scalar: Fraction;\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  public constructor(params: PriceProps) {\n    const { baseToken, quoteToken, numerator, denominator } = params;\n    super(numerator, denominator);\n\n    this.baseToken = baseToken;\n    this.quoteToken = quoteToken;\n    this.scalar = new Fraction(tenExponential(baseToken.decimals), tenExponential(quoteToken.decimals));\n  }\n\n  public get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator);\n  }\n\n  public get adjusted(): Fraction {\n    return super.mul(this.scalar);\n  }\n\n  public invert(): Price {\n    return new Price({\n      baseToken: this.quoteToken,\n      quoteToken: this.baseToken,\n      denominator: this.numerator,\n      numerator: this.denominator,\n    });\n  }\n\n  public mul(other: Price): Price {\n    if (this.quoteToken !== other.baseToken) logger.logWithError(\"mul token not equals\");\n\n    const fraction = super.mul(other);\n    return new Price({\n      baseToken: this.baseToken,\n      quoteToken: other.quoteToken,\n      denominator: fraction.denominator,\n      numerator: fraction.numerator,\n    });\n  }\n\n  public toSignificant(significantDigits = this.quoteToken.decimals, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding);\n  }\n\n  public toFixed(decimalPlaces = this.quoteToken.decimals, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding);\n  }\n}\n","import {\n  Connection,\n  PACKET_DATA_SIZE,\n  PublicKey,\n  RpcResponseAndContext,\n  sendAndConfirmTransaction,\n  Signer,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\n\nimport { SignAllTransactions } from \"../raydium/type\";\n\nimport { createLogger } from \"./logger\";\nimport { Owner } from \"./owner\";\n\nconst logger = createLogger(\"Raydium_txTool\");\ninterface TxBuilderInit {\n  connection: Connection;\n  feePayer: PublicKey;\n  owner?: Owner;\n  signAllTransactions?: SignAllTransactions;\n}\n\nexport interface AddInstructionParam {\n  instructions?: TransactionInstruction[];\n  endInstructions?: TransactionInstruction[];\n  signers?: Signer[];\n}\n\nexport interface TxBuildData {\n  transaction: Transaction;\n  signers: Signer[];\n  execute: () => Promise<string>;\n  extInfo: Record<string, any>;\n}\n\nexport interface MultiTxBuildData {\n  transactions: Transaction[];\n  signers: Signer[][];\n  execute: () => Promise<string[]>;\n  extInfo: Record<string, any>;\n}\n\nexport class TxBuilder {\n  private connection: Connection;\n  private owner?: Owner;\n  private instructions: TransactionInstruction[] = [];\n  private endInstructions: TransactionInstruction[] = [];\n  private signers: Signer[] = [];\n  private feePayer: PublicKey;\n  private signAllTransactions?: SignAllTransactions;\n\n  constructor(params: TxBuilderInit) {\n    this.connection = params.connection;\n    this.feePayer = params.feePayer;\n    this.signAllTransactions = params.signAllTransactions;\n    this.owner = params.owner;\n  }\n\n  get AllTxData(): {\n    instructions: TransactionInstruction[];\n    endInstructions: TransactionInstruction[];\n    signers: Signer[];\n  } {\n    return {\n      instructions: this.instructions,\n      endInstructions: this.endInstructions,\n      signers: this.signers,\n    };\n  }\n\n  get allInstructions(): TransactionInstruction[] {\n    return [...this.instructions, ...this.endInstructions];\n  }\n\n  public addInstruction({ instructions = [], endInstructions = [], signers = [] }: AddInstructionParam): TxBuilder {\n    this.instructions.push(...instructions);\n    this.endInstructions.push(...endInstructions);\n    this.signers.push(...signers);\n    return this;\n  }\n\n  public build(extInfo?: Record<string, any>): TxBuildData {\n    const transaction = new Transaction();\n    if (this.allInstructions.length) transaction.add(...this.allInstructions);\n    transaction.feePayer = this.feePayer;\n\n    return {\n      transaction,\n      signers: this.signers,\n      execute: async (): Promise<string> => {\n        const recentBlockHash = await getRecentBlockHash(this.connection);\n        transaction.recentBlockhash = recentBlockHash;\n        if (this.owner?.isKeyPair) {\n          return sendAndConfirmTransaction(this.connection, transaction, this.signers);\n        }\n        if (this.signAllTransactions) {\n          if (this.signers.length) transaction.partialSign(...this.signers);\n          const txs = await this.signAllTransactions([transaction]);\n          return await this.connection.sendRawTransaction(txs[0].serialize(), { skipPreflight: true });\n        }\n        throw new Error(\"please connect wallet first\");\n      },\n      extInfo: extInfo || {},\n    };\n  }\n\n  public buildMultiTx(params: { extraPreBuildData?: TxBuildData[]; extInfo?: Record<string, any> }): MultiTxBuildData {\n    const { extraPreBuildData = [], extInfo } = params;\n    const { transaction } = this.build(extInfo);\n\n    const filterExtraBuildData = extraPreBuildData.filter((data) => data.transaction.instructions.length > 0);\n\n    const allTransactions: Transaction[] = [...filterExtraBuildData.map((data) => data.transaction), transaction];\n    const allSigners: Signer[][] = [...filterExtraBuildData.map((data) => data.signers), this.signers];\n\n    return {\n      transactions: allTransactions,\n      signers: allSigners,\n      execute: async (): Promise<string[]> => {\n        const recentBlockHash = await getRecentBlockHash(this.connection);\n        if (this.owner?.isKeyPair) {\n          return await Promise.all(\n            allTransactions.map(async (tx, idx) => {\n              tx.recentBlockhash = recentBlockHash;\n              return await sendAndConfirmTransaction(this.connection, tx, allSigners[idx]);\n            }),\n          );\n        }\n        if (this.signAllTransactions) {\n          const partialSignedTxs = allTransactions.map((tx, idx) => {\n            tx.recentBlockhash = recentBlockHash;\n            if (allSigners[idx].length) tx.partialSign(...allSigners[idx]);\n            return tx;\n          });\n          const signedTxs = await this.signAllTransactions(partialSignedTxs);\n\n          const txIds: string[] = [];\n          for (let i = 0; i < signedTxs.length; i += 1) {\n            const txId = await this.connection.sendRawTransaction(signedTxs[i].serialize(), { skipPreflight: true });\n            txIds.push(txId);\n          }\n          return txIds;\n        }\n        throw new Error(\"please connect wallet first\");\n      },\n      extInfo: extInfo || {},\n    };\n  }\n}\n\nexport async function getRecentBlockHash(connection: Connection): Promise<string> {\n  try {\n    return (await connection.getLatestBlockhash?.())?.blockhash || (await connection.getRecentBlockhash()).blockhash;\n  } catch {\n    return (await connection.getRecentBlockhash()).blockhash;\n  }\n}\n\n/**\n * Forecast transaction size\n */\nexport function forecastTransactionSize(instructions: TransactionInstruction[], signers: PublicKey[]): number {\n  if (instructions.length < 1) logger.logWithError(`no instructions provided: ${instructions.toString()}`);\n  if (signers.length < 1) logger.logWithError(`no signers provided:, ${signers.toString()}`);\n\n  const transaction = new Transaction();\n  transaction.recentBlockhash = \"11111111111111111111111111111111\";\n  transaction.feePayer = signers[0];\n  transaction.add(...instructions);\n\n  const message = transaction.compileMessage().serialize();\n  // SIGNATURE_LENGTH = 64\n  const transactionLength = signers.length + signers.length * 64 + message.length;\n  return transactionLength;\n}\n\n/**\n * Simulates multiple instruction\n */\nexport async function simulateMultipleInstruction(\n  connection: Connection,\n  instructions: TransactionInstruction[],\n  keyword: string,\n): Promise<any> {\n  const feePayer = new PublicKey(\"RaydiumSimuLateTransaction11111111111111111\");\n\n  const transactions: Transaction[] = [];\n\n  let transaction = new Transaction();\n  transaction.feePayer = feePayer;\n\n  for (const instruction of instructions) {\n    if (forecastTransactionSize([...transaction.instructions, instruction], [feePayer]) > PACKET_DATA_SIZE) {\n      transactions.push(transaction);\n      transaction = new Transaction();\n      transaction.feePayer = feePayer;\n      transaction.add(instruction);\n    } else {\n      transaction.add(instruction);\n    }\n  }\n  if (transaction.instructions.length > 0) {\n    transactions.push(transaction);\n  }\n\n  let results: RpcResponseAndContext<SimulatedTransactionResponse>[] = [];\n\n  try {\n    results = await Promise.all(transactions.map((transaction) => connection.simulateTransaction(transaction)));\n  } catch (error) {\n    if (error instanceof Error) {\n      logger.logWithError(`failed to simulate for instructions, RPC_ERROR, ${error.message}`);\n    }\n  }\n\n  const logs: string[] = [];\n  for (const result of results) {\n    const { value } = result;\n    logger.debug(`simulate result: ${JSON.stringify(result)}`);\n\n    if (value.logs) {\n      const filteredLog = value.logs.filter((log) => log && log.includes(keyword));\n      logger.debug(`filteredLog: ${JSON.stringify(logs)}`);\n      if (!filteredLog.length) logger.logWithError(` \"simulate log not match keyword, keyword: ${keyword}`);\n      logs.push(...filteredLog);\n    }\n  }\n\n  return logs;\n}\n\nexport function parseSimulateLogToJson(log: string, keyword: string): any {\n  const results = log.match(/{[\"\\w:,]+}/g);\n  if (!results || results.length !== 1) {\n    return logger.logWithError(`simulate log fail to match json, keyword: ${keyword}`);\n  }\n\n  return results[0];\n}\n\nexport function parseSimulateValue(log: string, key: string): any {\n  const reg = new RegExp(`\"${key}\":(\\\\d+)`, \"g\");\n\n  const results = reg.exec(log);\n  if (!results || results.length !== 2) {\n    return logger.logWithError(`simulate log fail to match key\", key: ${key}`);\n  }\n\n  return results[1];\n}\n\nexport interface ProgramAddress {\n  publicKey: PublicKey;\n  nonce: number;\n}\nexport async function findProgramAddress(\n  seeds: Array<Buffer | Uint8Array>,\n  programId: PublicKey,\n): Promise<ProgramAddress> {\n  const [publicKey, nonce] = await PublicKey.findProgramAddress(seeds, programId);\n  return { publicKey, nonce };\n}\n","import { AccountInfo, Commitment, Connection, PublicKey } from \"@solana/web3.js\";\n\nimport { chunkArray } from \"./lodash\";\nimport { createLogger } from \"./logger\";\n\ninterface MultipleAccountsJsonRpcResponse {\n  jsonrpc: string;\n  id: string;\n  error?: {\n    code: number;\n    message: string;\n  };\n  result: {\n    context: { slot: number };\n    value: { data: Array<string>; executable: boolean; lamports: number; owner: string; rentEpoch: number }[];\n  };\n}\n\nexport interface GetMultipleAccountsInfoConfig {\n  batchRequest?: boolean;\n  commitment?: Commitment;\n}\n\nconst logger = createLogger(\"Raydium_accountInfo_util\");\n\nexport async function getMultipleAccountsInfo(\n  connection: Connection,\n  publicKeys: PublicKey[],\n  config?: GetMultipleAccountsInfoConfig,\n): Promise<(AccountInfo<Buffer> | null)[]> {\n  const { batchRequest, commitment } = {\n    batchRequest: false,\n    ...config,\n  };\n\n  const chunkedKeys = chunkArray(publicKeys, 100);\n  let results: (AccountInfo<Buffer> | null)[][] = new Array(chunkedKeys.length).fill([]);\n\n  if (batchRequest) {\n    const batch = chunkedKeys.map((keys) => {\n      const args = connection._buildArgs([keys.map((key) => key.toBase58())], commitment, \"base64\");\n      return {\n        methodName: \"getMultipleAccounts\",\n        args,\n      };\n    });\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const unsafeResponse: MultipleAccountsJsonRpcResponse[] = await connection._rpcBatchRequest(batch);\n    results = unsafeResponse.map((unsafeRes: MultipleAccountsJsonRpcResponse) => {\n      if (unsafeRes.error)\n        logger.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${unsafeRes.error.message}`);\n\n      return unsafeRes.result.value.map((accountInfo) => {\n        if (accountInfo) {\n          const { data, executable, lamports, owner, rentEpoch } = accountInfo;\n\n          if (data.length !== 2 && data[1] !== \"base64\") logger.logWithError(`info must be base64 encoded, RPC_ERROR`);\n\n          return {\n            data: Buffer.from(data[0], \"base64\"),\n            executable,\n            lamports,\n            owner: new PublicKey(owner),\n            rentEpoch,\n          };\n        }\n        return null;\n      });\n    });\n  } else {\n    try {\n      results = (await Promise.all(\n        chunkedKeys.map((keys) => connection.getMultipleAccountsInfo(keys, commitment)),\n      )) as (AccountInfo<Buffer> | null)[][];\n    } catch (error) {\n      if (error instanceof Error) {\n        logger.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${error.message}`);\n      }\n    }\n  }\n\n  return results.flat();\n}\n\nexport async function getMultipleAccountsInfoWithCustomFlags<T extends { pubkey: PublicKey }>(\n  connection: Connection,\n  publicKeysWithCustomFlag: T[],\n  config?: GetMultipleAccountsInfoConfig,\n): Promise<({ accountInfo: AccountInfo<Buffer> | null } & T)[]> {\n  const multipleAccountsInfo = await getMultipleAccountsInfo(\n    connection,\n    publicKeysWithCustomFlag.map((o) => o.pubkey),\n    config,\n  );\n\n  return publicKeysWithCustomFlag.map((o, idx) => ({ ...o, accountInfo: multipleAccountsInfo[idx] }));\n}\n"],"mappings":"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","names":[]}