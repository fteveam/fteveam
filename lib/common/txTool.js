var R=Object.create;var T=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var E=Object.getOwnPropertyNames;var D=Object.getPrototypeOf,C=Object.prototype.hasOwnProperty;var K=(e,t)=>{for(var n in t)T(e,n,{get:t[n],enumerable:!0})},I=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of E(t))!C.call(e,s)&&s!==n&&T(e,s,{get:()=>t[s],enumerable:!(r=B(t,s))||r.enumerable});return e};var b=(e,t,n)=>(n=e!=null?R(D(e)):{},I(t||!e||!e.__esModule?T(n,"default",{value:e,enumerable:!0}):n,e)),M=e=>I(T({},"__esModule",{value:!0}),e);var J={};K(J,{TxBuilder:()=>x,findProgramAddress:()=>z,forecastTransactionSize:()=>k,getRecentBlockHash:()=>L,parseSimulateLogToJson:()=>H,parseSimulateValue:()=>j,simulateMultipleInstruction:()=>O});module.exports=M(J);var a=require("@solana/web3.js");var m=require("lodash"),w=b(require("dayjs")),A=b(require("dayjs/plugin/utc"));w.default.extend(A.default);var y=class{constructor(t){this.logLevel=t.logLevel!==void 0?t.logLevel:3,this.name=t.name}set level(t){this.logLevel=t}get time(){return(0,w.default)().utc().format("YYYY/MM/DD HH:mm:ss UTC")}get moduleName(){return this.name}isLogLevel(t){return t<=this.logLevel}error(...t){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...t),this):this}logWithError(...t){let n=t.map(r=>typeof r=="object"?JSON.stringify(r):r).join(", ");throw new Error(n)}warning(...t){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...t),this):this}info(...t){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...t),this):this}debug(...t){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...t),this):this}},v={},$={};function S(e){let t=(0,m.get)(v,e);if(!t){let n=(0,m.get)($,e);t=new y({name:e,logLevel:n}),(0,m.set)(v,e,t)}return t}var l=S("Raydium_txTool"),x=class{constructor(t){this.instructions=[];this.endInstructions=[];this.signers=[];this.connection=t.connection,this.feePayer=t.feePayer,this.signAllTransactions=t.signAllTransactions,this.owner=t.owner}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers}}get allInstructions(){return[...this.instructions,...this.endInstructions]}addInstruction({instructions:t=[],endInstructions:n=[],signers:r=[]}){return this.instructions.push(...t),this.endInstructions.push(...n),this.signers.push(...r),this}build(t){let n=new a.Transaction;return this.allInstructions.length&&n.add(...this.allInstructions),n.feePayer=this.feePayer,{transaction:n,signers:this.signers,execute:async()=>{var s;let r=await L(this.connection);if(n.recentBlockhash=r,(s=this.owner)!=null&&s.isKeyPair)return(0,a.sendAndConfirmTransaction)(this.connection,n,this.signers);if(this.signAllTransactions){this.signers.length&&n.partialSign(...this.signers);let o=await this.signAllTransactions([n]);return await this.connection.sendRawTransaction(o[0].serialize(),{skipPreflight:!0})}throw new Error("please connect wallet first")},extInfo:t||{}}}buildMultiTx(t){let{extraPreBuildData:n=[],extInfo:r}=t,{transaction:s}=this.build(r),o=n.filter(i=>i.transaction.instructions.length>0),f=[...o.map(i=>i.transaction),s],c=[...o.map(i=>i.signers),this.signers];return{transactions:f,signers:c,execute:async()=>{var d;let i=await L(this.connection);if((d=this.owner)!=null&&d.isKeyPair)return await Promise.all(f.map(async(g,u)=>(g.recentBlockhash=i,await(0,a.sendAndConfirmTransaction)(this.connection,g,c[u]))));if(this.signAllTransactions){let g=f.map((h,p)=>(h.recentBlockhash=i,c[p].length&&h.partialSign(...c[p]),h)),u=await this.signAllTransactions(g),P=[];for(let h=0;h<u.length;h+=1){let p=await this.connection.sendRawTransaction(u[h].serialize(),{skipPreflight:!0});P.push(p)}return P}throw new Error("please connect wallet first")},extInfo:r||{}}}};async function L(e){var t,n;try{return((n=await((t=e.getLatestBlockhash)==null?void 0:t.call(e)))==null?void 0:n.blockhash)||(await e.getRecentBlockhash()).blockhash}catch{return(await e.getRecentBlockhash()).blockhash}}function k(e,t){e.length<1&&l.logWithError(`no instructions provided: ${e.toString()}`),t.length<1&&l.logWithError(`no signers provided:, ${t.toString()}`);let n=new a.Transaction;n.recentBlockhash="11111111111111111111111111111111",n.feePayer=t[0],n.add(...e);let r=n.compileMessage().serialize();return t.length+t.length*64+r.length}async function O(e,t,n){let r=new a.PublicKey("RaydiumSimuLateTransaction11111111111111111"),s=[],o=new a.Transaction;o.feePayer=r;for(let i of t)k([...o.instructions,i],[r])>a.PACKET_DATA_SIZE&&(s.push(o),o=new a.Transaction,o.feePayer=r),o.add(i);o.instructions.length>0&&s.push(o);let f=[];try{f=await Promise.all(s.map(i=>e.simulateTransaction(i)))}catch(i){i instanceof Error&&l.logWithError(`failed to simulate for instructions, RPC_ERROR, ${i.message}`)}let c=[];for(let i of f){let{value:d}=i;if(l.debug(`simulate result: ${JSON.stringify(i)}`),d.logs){let g=d.logs.filter(u=>u&&u.includes(n));l.debug(`filteredLog: ${JSON.stringify(c)}`),g.length||l.logWithError(` "simulate log not match keyword, keyword: ${n}`),c.push(...g)}}return c}function H(e,t){let n=e.match(/{["\w:,]+}/g);return!n||n.length!==1?l.logWithError(`simulate log fail to match json, keyword: ${t}`):n[0]}function j(e,t){let r=new RegExp(`"${t}":(\\d+)`,"g").exec(e);return!r||r.length!==2?l.logWithError(`simulate log fail to match key", key: ${t}`):r[1]}async function z(e,t){let[n,r]=await a.PublicKey.findProgramAddress(e,t);return{publicKey:n,nonce:r}}0&&(module.exports={TxBuilder,findProgramAddress,forecastTransactionSize,getRecentBlockHash,parseSimulateLogToJson,parseSimulateValue,simulateMultipleInstruction});
//# sourceMappingURL=txTool.js.map