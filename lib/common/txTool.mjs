import{PACKET_DATA_SIZE as C,PublicKey as S,sendAndConfirmTransaction as w,Transaction as p}from"@solana/web3.js";import{get as y,set as L}from"lodash";import R from"pino";import v from"pino-pretty";var T={},B={},k=v({colorize:!0,levelFirst:!0,translateTime:"SYS:yyyymmdd HH:MM:ss.l"}),E=R({base:null,level:"silent"},k);function x(e){let t=y(T,e);if(!t){let n=y(B,e);t=E.child({name:e},{level:n}),L(T,e,t)}return t.logWithError=(...n)=>{let r=n.map(o=>typeof o=="object"?JSON.stringify(o):o).join(", ");throw new Error(r)},t}var c=x("Raydium_txTool"),P=class{constructor(t){this.instructions=[];this.endInstructions=[];this.signers=[];this.connection=t.connection,this.feePayer=t.feePayer,this.signAllTransactions=t.signAllTransactions,this.owner=t.owner}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers}}get allInstructions(){return[...this.instructions,...this.endInstructions]}addInstruction({instructions:t=[],endInstructions:n=[],signers:r=[]}){return this.instructions.push(...t),this.endInstructions.push(...n),this.signers.push(...r),this}build(t){let n=new p;return this.allInstructions.length&&n.add(...this.allInstructions),n.feePayer=this.feePayer,{transaction:n,signers:this.signers,execute:async()=>{var o;let r=await I(this.connection);if(n.recentBlockhash=r,(o=this.owner)!=null&&o.isKeyPair)return w(this.connection,n,this.signers);if(this.signAllTransactions){this.signers.length&&n.partialSign(...this.signers);let s=await this.signAllTransactions([n]);return await this.connection.sendRawTransaction(s[0].serialize(),{skipPreflight:!0})}throw new Error("please connect wallet first")},extInfo:t||{}}}buildMultiTx(t){let{extraPreBuildData:n=[],extInfo:r}=t,{transaction:o}=this.build(r),s=n.filter(i=>i.transaction.instructions.length>0),h=[...s.map(i=>i.transaction),o],a=[...s.map(i=>i.signers),this.signers];return{transactions:h,signers:a,execute:async()=>{var f;let i=await I(this.connection);if((f=this.owner)!=null&&f.isKeyPair)return await Promise.all(h.map(async(l,g)=>(l.recentBlockhash=i,await w(this.connection,l,a[g]))));if(this.signAllTransactions){let l=h.map((u,d)=>(u.recentBlockhash=i,a[d].length&&u.partialSign(...a[d]),u)),g=await this.signAllTransactions(l),m=[];for(let u=0;u<g.length;u+=1){let d=await this.connection.sendRawTransaction(g[u].serialize(),{skipPreflight:!0});m.push(d)}return m}throw new Error("please connect wallet first")},extInfo:r||{}}}};async function I(e){var t,n;try{return((n=await((t=e.getLatestBlockhash)==null?void 0:t.call(e)))==null?void 0:n.blockhash)||(await e.getRecentBlockhash()).blockhash}catch{return(await e.getRecentBlockhash()).blockhash}}function K(e,t){e.length<1&&c.logWithError(`no instructions provided: ${e.toString()}`),t.length<1&&c.logWithError(`no signers provided:, ${t.toString()}`);let n=new p;n.recentBlockhash="11111111111111111111111111111111",n.feePayer=t[0],n.add(...e);let r=n.compileMessage().serialize();return t.length+t.length*64+r.length}async function V(e,t,n){let r=new S("RaydiumSimuLateTransaction11111111111111111"),o=[],s=new p;s.feePayer=r;for(let i of t)K([...s.instructions,i],[r])>C&&(o.push(s),s=new p,s.feePayer=r),s.add(i);s.instructions.length>0&&o.push(s);let h=[];try{h=await Promise.all(o.map(i=>e.simulateTransaction(i)))}catch(i){i instanceof Error&&c.logWithError(`failed to simulate for instructions, RPC_ERROR, ${i.message}`)}let a=[];for(let i of h){let{value:f}=i;if(c.debug(`simulate result: ${JSON.stringify(i)}`),f.logs){let l=f.logs.filter(g=>g&&g.includes(n));c.debug(`filteredLog: ${JSON.stringify(a)}`),l.length||c.logWithError(` "simulate log not match keyword, keyword: ${n}`),a.push(...l)}}return a}function Y(e,t){let n=e.match(/{["\w:,]+}/g);return!n||n.length!==1?c.logWithError(`simulate log fail to match json, keyword: ${t}`):n[0]}function Z(e,t){let r=new RegExp(`"${t}":(\\d+)`,"g").exec(e);return!r||r.length!==2?c.logWithError(`simulate log fail to match key", key: ${t}`):r[1]}async function q(e,t){let[n,r]=await S.findProgramAddress(e,t);return{publicKey:n,nonce:r}}export{P as TxBuilder,q as findProgramAddress,K as forecastTransactionSize,I as getRecentBlockHash,Y as parseSimulateLogToJson,Z as parseSimulateValue,V as simulateMultipleInstruction};
//# sourceMappingURL=txTool.mjs.map