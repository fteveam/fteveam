import{PACKET_DATA_SIZE as E,PublicKey as v,sendAndConfirmTransaction as P,Transaction as m}from"@solana/web3.js";import{get as y,set as k}from"lodash";import x from"dayjs";import R from"dayjs/plugin/utc";x.extend(R);var p=class{constructor(t){this.logLevel=t.logLevel!==void 0?t.logLevel:3,this.name=t.name}set level(t){this.logLevel=t}get time(){return x().utc().format("YYYY/MM/DD HH:mm:ss UTC")}get moduleName(){return this.name}isLogLevel(t){return t<=this.logLevel}error(...t){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...t),this):this}logWithError(...t){let n=t.map(r=>typeof r=="object"?JSON.stringify(r):r).join(", ");throw new Error(n)}warning(...t){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...t),this):this}info(...t){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...t),this):this}debug(...t){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...t),this):this}},w={},B={};function L(e){let t=y(w,e);if(!t){let n=y(B,e);t=new p({name:e,logLevel:n}),k(w,e,t)}return t}var c=L("Raydium_txTool"),I=class{constructor(t){this.instructions=[];this.endInstructions=[];this.signers=[];this.connection=t.connection,this.feePayer=t.feePayer,this.signAllTransactions=t.signAllTransactions,this.owner=t.owner}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers}}get allInstructions(){return[...this.instructions,...this.endInstructions]}addInstruction({instructions:t=[],endInstructions:n=[],signers:r=[]}){return this.instructions.push(...t),this.endInstructions.push(...n),this.signers.push(...r),this}build(t){let n=new m;return this.allInstructions.length&&n.add(...this.allInstructions),n.feePayer=this.feePayer,{transaction:n,signers:this.signers,execute:async()=>{var o;let r=await b(this.connection);if(n.recentBlockhash=r,(o=this.owner)!=null&&o.isKeyPair)return P(this.connection,n,this.signers);if(this.signAllTransactions){this.signers.length&&n.partialSign(...this.signers);let s=await this.signAllTransactions([n]);return await this.connection.sendRawTransaction(s[0].serialize(),{skipPreflight:!0})}throw new Error("please connect wallet first")},extInfo:t||{}}}buildMultiTx(t){let{extraPreBuildData:n=[],extInfo:r}=t,{transaction:o}=this.build(r),s=n.filter(i=>i.transaction.instructions.length>0),h=[...s.map(i=>i.transaction),o],a=[...s.map(i=>i.signers),this.signers];return{transactions:h,signers:a,execute:async()=>{var f;let i=await b(this.connection);if((f=this.owner)!=null&&f.isKeyPair)return await Promise.all(h.map(async(l,g)=>(l.recentBlockhash=i,await P(this.connection,l,a[g]))));if(this.signAllTransactions){let l=h.map((u,d)=>(u.recentBlockhash=i,a[d].length&&u.partialSign(...a[d]),u)),g=await this.signAllTransactions(l),T=[];for(let u=0;u<g.length;u+=1){let d=await this.connection.sendRawTransaction(g[u].serialize(),{skipPreflight:!0});T.push(d)}return T}throw new Error("please connect wallet first")},extInfo:r||{}}}};async function b(e){var t,n;try{return((n=await((t=e.getLatestBlockhash)==null?void 0:t.call(e)))==null?void 0:n.blockhash)||(await e.getRecentBlockhash()).blockhash}catch{return(await e.getRecentBlockhash()).blockhash}}function D(e,t){e.length<1&&c.logWithError(`no instructions provided: ${e.toString()}`),t.length<1&&c.logWithError(`no signers provided:, ${t.toString()}`);let n=new m;n.recentBlockhash="11111111111111111111111111111111",n.feePayer=t[0],n.add(...e);let r=n.compileMessage().serialize();return t.length+t.length*64+r.length}async function _(e,t,n){let r=new v("RaydiumSimuLateTransaction11111111111111111"),o=[],s=new m;s.feePayer=r;for(let i of t)D([...s.instructions,i],[r])>E&&(o.push(s),s=new m,s.feePayer=r),s.add(i);s.instructions.length>0&&o.push(s);let h=[];try{h=await Promise.all(o.map(i=>e.simulateTransaction(i)))}catch(i){i instanceof Error&&c.logWithError(`failed to simulate for instructions, RPC_ERROR, ${i.message}`)}let a=[];for(let i of h){let{value:f}=i;if(c.debug(`simulate result: ${JSON.stringify(i)}`),f.logs){let l=f.logs.filter(g=>g&&g.includes(n));c.debug(`filteredLog: ${JSON.stringify(a)}`),l.length||c.logWithError(` "simulate log not match keyword, keyword: ${n}`),a.push(...l)}}return a}function N(e,t){let n=e.match(/{["\w:,]+}/g);return!n||n.length!==1?c.logWithError(`simulate log fail to match json, keyword: ${t}`):n[0]}function U(e,t){let r=new RegExp(`"${t}":(\\d+)`,"g").exec(e);return!r||r.length!==2?c.logWithError(`simulate log fail to match key", key: ${t}`):r[1]}async function V(e,t){let[n,r]=await v.findProgramAddress(e,t);return{publicKey:n,nonce:r}}export{I as TxBuilder,V as findProgramAddress,D as forecastTransactionSize,b as getRecentBlockHash,N as parseSimulateLogToJson,U as parseSimulateValue,_ as simulateMultipleInstruction};
//# sourceMappingURL=txTool.mjs.map