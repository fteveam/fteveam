var li=Object.defineProperty,di=Object.defineProperties;var pi=Object.getOwnPropertyDescriptors;var Tt=Object.getOwnPropertySymbols;var Zo=Object.prototype.hasOwnProperty,Xo=Object.prototype.propertyIsEnumerable;var zo=(o,e,t)=>e in o?li(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,x=(o,e)=>{for(var t in e||(e={}))Zo.call(e,t)&&zo(o,t,e[t]);if(Tt)for(var t of Tt(e))Xo.call(e,t)&&zo(o,t,e[t]);return o},K=(o,e)=>di(o,pi(e));var ee=(o,e)=>{var t={};for(var n in o)Zo.call(o,n)&&e.indexOf(n)<0&&(t[n]=o[n]);if(o!=null&&Tt)for(var n of Tt(o))e.indexOf(n)<0&&Xo.call(o,n)&&(t[n]=o[n]);return t};import Ci from"axios";import{get as $t,set as en}from"lodash";import tn from"dayjs";import fi from"dayjs/plugin/utc";tn.extend(fi);var yi=(r=>(r[r.Error=0]="Error",r[r.Warning=1]="Warning",r[r.Info=2]="Info",r[r.Debug=3]="Debug",r))(yi||{}),jt=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:0,this.name=e.name}set level(e){this.logLevel=e}get time(){return tn().utc().format("YYYY/MM/DD HH:mm:ss UTC")}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(n=>typeof n=="object"?JSON.stringify(n):n).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},Yt={},on={};function M(o){let e=$t(Yt,o);if(!e){let t=$t(on,o);e=new jt({name:o,logLevel:t}),en(Yt,o,e)}return e}function ou(o,e){en(on,o,e);let t=$t(Yt,o);t&&(t.level=e)}import{PublicKey as Mi}from"@solana/web3.js";import Bi from"bn.js";import Ti from"big.js";import Lt from"bn.js";import V from"bn.js";var At=M("Raydium_bignumber"),Qt=(n=>(n[n.ROUND_DOWN=0]="ROUND_DOWN",n[n.ROUND_HALF_UP=1]="ROUND_HALF_UP",n[n.ROUND_UP=2]="ROUND_UP",n))(Qt||{}),ae=new V(0),pe=new V(1),su=new V(2),uu=new V(3),cu=new V(5),be=new V(10),an=new V(100),mu=new V(1e3),lu=new V(1e4),nn=9007199254740991;function S(o){if(o instanceof V)return o;if(typeof o=="string"){if(o.match(/^-?[0-9]+$/))return new V(o);At.logWithError(`invalid BigNumberish string: ${o}`)}return typeof o=="number"?(o%1&&At.logWithError(`BigNumberish number underflow: ${o}`),(o>=nn||o<=-nn)&&At.logWithError(`BigNumberish number overflow: ${o}`),new V(String(o))):typeof o=="bigint"?new V(o.toString()):(At.logWithError(`invalid BigNumberish value: ${o}`),new V(0))}function Ht(o){return be.pow(S(o))}function ue(o){var u;if(o===void 0)return{denominator:"1",numerator:"0"};if(o instanceof V)return{numerator:o.toString(),denominator:"1"};if(o instanceof I)return{denominator:o.denominator.toString(),numerator:o.numerator.toString()};let e=String(o),[,t="",n="",r=""]=(u=e.replace(",","").match(/(-?)(\d*)\.?(\d*)/))!=null?u:[],i="1"+"0".repeat(r.length),a=t+(n==="0"?"":n)+r||"0";return{denominator:i,numerator:a,sign:t,int:n,dec:r}}function zt(o,e){let t=o.divmod(e);return t.mod.isZero()?t.div:t.div.negative!==0?t.div.isubn(1):t.div.iaddn(1)}function bi(o){var n;let[,e="",t=""]=(n=o.toFixed(2).match(/(-?)(\d*)\.?(\d*)/))!=null?n:[];return`${e}${t}`}function xe(o,e=0){return o instanceof V?o:new V(bi(Ke(o).mul(be.pow(new V(String(e))))))}function Ke(o){if(o instanceof oe)return new I(o.numerator,o.denominator);if(o instanceof j)return o.adjusted;if(o instanceof O)try{return Ke(o.toExact())}catch{return new I(ae)}if(o instanceof I)return o;let e=String(o),t=ue(e);return new I(t.numerator,t.denominator)}function It(o,e){let{numerator:t,denominator:n}=ue(o);return new oe(new V(t),new V(n).mul(e!=null&&e.alreadyDecimaled?new V(100):new V(1)))}function Qe(o){let{token:e,numberPrice:t,decimalDone:n}=o,r=new C({mint:"",decimals:6,symbol:"usd",name:"usd",skipMint:!0}),{numerator:i,denominator:a}=ue(t),u=n?new V(i).mul(be.pow(new V(e.decimals))):i,c=new V(a).mul(be.pow(new V(r.decimals)));return new j({baseToken:r,denominator:c.toString(),quoteToken:new C(K(x({},e),{skipMint:!0,mint:""})),numerator:u.toString()})}function sn(o,e){if(o==null||e==null)return;let t=Ke(o),n=Ke(e);return t.mul(n)}function rn(o){let e=new C({mint:"",decimals:6,symbol:"usd",name:"usd",skipMint:!0}),t=xe(sn(o,10**e.decimals));return new O(e,t)}function He(o,e){return rn(!e||!o?0:sn(o,e))}import gi from"toformat";var Pi=gi,ze=Pi;import St from"big.js";import hi from"decimal.js-light";var xt=M("module/fraction"),Zt=ze(St),Ze=ze(hi),wi={[0]:Ze.ROUND_DOWN,[1]:Ze.ROUND_HALF_UP,[2]:Ze.ROUND_UP},ki={[0]:St.roundDown,[1]:St.roundHalfUp,[2]:St.roundUp},I=class{constructor(e,t=pe){this.numerator=S(e),this.denominator=S(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new I(this.denominator,this.numerator)}add(e){let t=e instanceof I?e:new I(S(e));return this.denominator.eq(t.denominator)?new I(this.numerator.add(t.numerator),this.denominator):new I(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof I?e:new I(S(e));return this.denominator.eq(t.denominator)?new I(this.numerator.sub(t.numerator),this.denominator):new I(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof I?e:new I(S(e));return new I(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof I?e:new I(S(e));return new I(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},n=1){Number.isInteger(e)||xt.logWithError(`${e} is not an integer.`),e<=0&&xt.logWithError(`${e} is not positive.`),Ze.set({precision:e+1,rounding:wi[n]});let r=new Ze(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return r.toFormat(r.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},n=1){return Number.isInteger(e)||xt.logWithError(`${e} is not an integer.`),e<0&&xt.logWithError(`${e} is negative.`),Zt.DP=e,Zt.RM=ki[n]||1,new Zt(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var Ai=M("Raydium_amount"),un=ze(Ti);function Ii(o,e){let t="0",n="0";if(o.includes(".")){let r=o.split(".");r.length===2?([t,n]=r,n=n.padEnd(e,"0")):Ai.logWithError(`invalid number string, num: ${o}`)}else t=o;return[t,n.slice(0,e)||n]}var O=class extends I{constructor(t,n,r=!0,i){let a=new Lt(0),u=be.pow(new Lt(t.decimals));if(r)a=S(n);else{let c=new Lt(0),m=new Lt(0);if(typeof n=="string"||typeof n=="number"||typeof n=="bigint"){let[d,p]=Ii(n.toString(),t.decimals);c=S(d),m=S(p)}c=c.mul(u),a=c.add(m)}super(a,u);this.logger=M(i||"Amount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new O(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new O(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,n,r=0){return super.toSignificant(t,n,r)}toFixed(t=this.token.decimals,n,r=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,n,r)}toExact(t={groupSeparator:""}){return un.DP=this.token.decimals,new un(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};import{PublicKey as xi}from"@solana/web3.js";var cn={symbol:"SOL",name:"Solana",decimals:9},Y={symbol:"WSOL",name:"Wrapped SOL",mint:"So11111111111111111111111111111111111111112",decimals:9,extensions:{coingeckoId:"solana"}},Xe={isQuantumSOL:!0,isLp:!1,official:!0,mint:new xi(Y.mint),decimals:9,symbol:"SOL",id:"sol",name:"solana",icon:"https://img.raydium.io/icon/So11111111111111111111111111111111111111112.png",extensions:{coingeckoId:"solana"}};import{PublicKey as Xt}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as Si}from"@solana/spl-token";import{PublicKey as ne,SystemProgram as Li,SYSVAR_RENT_PUBKEY as _i}from"@solana/web3.js";function s({pubkey:o,isSigner:e=!1,isWritable:t=!0}){return{pubkey:o,isWritable:t,isSigner:e}}var Oe=[s({pubkey:Si,isWritable:!1}),s({pubkey:Li.programId,isWritable:!1}),s({pubkey:_i,isWritable:!1})];function E({publicKey:o,transformSol:e}){if(o instanceof ne)return e&&o.equals(U)?Se:o;if(e&&o===U.toBase58())return Se;if(typeof o=="string")try{return new ne(o)}catch{throw new Error("invalid public key")}throw new Error("invalid public key")}function mn(o){try{return new ne(o)}catch{return o}}var _t=new ne("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),ln=new ne("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Du=new ne("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),dn=new ne("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),pn=new ne("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),fn=new ne("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),yn=new ne("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),bn=new ne("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),Eu=new ne("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),Vu=new ne("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),gn=new ne("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Se=new ne("So11111111111111111111111111111111111111112"),U=ne.default;var eo=class{constructor({mint:e,decimals:t,symbol:n="UNKNOWN",name:r="UNKNOWN",skipMint:i=!1}){if(e===U.toBase58()||e instanceof Xt&&U.equals(e)){this.decimals=Y.decimals,this.symbol=Y.symbol,this.name=Y.name,this.mint=new Xt(Y.mint);return}this.decimals=t,this.symbol=n,this.name=r,this.mint=i?Xt.default:E({publicKey:e})}equals(e){return this===e?!0:this.mint.equals(e.mint)}},C=eo;C.WSOL=new eo(Y);var oo=class{constructor({decimals:e,symbol:t="UNKNOWN",name:n="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=n}equals(e){return this===e}},to=oo;to.SOL=new oo(cn);function Qu(o,e){return o instanceof C&&e instanceof C?o.equals(e):o instanceof C||e instanceof C?!1:o===e}var Pn=new I(an),oe=class extends I{toSignificant(e=5,t,n){return this.mul(Pn).toSignificant(e,t,n)}toFixed(e=2,t,n){return this.mul(Pn).toFixed(e,t,n)}};var Ri=M("Raydium_price"),j=class extends I{constructor(t){let{baseToken:n,quoteToken:r,numerator:i,denominator:a}=t;super(i,a);this.baseToken=n,this.quoteToken=r,this.scalar=new I(Ht(n.decimals),Ht(r.decimals))}get raw(){return new I(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new j({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&Ri.logWithError("mul token not equals");let n=super.mul(t);return new j({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:n.denominator,numerator:n.numerator})}toSignificant(t=this.quoteToken.decimals,n,r){return this.adjusted.toSignificant(t,n,r)}toFixed(t=this.quoteToken.decimals,n,r){return this.adjusted.toFixed(t,n,r)}};async function hn(o){new Promise(e=>setTimeout(e,o))}function hc(){return new Date().getTime()}var Ki=[C,O,Mi,I,Bi,j,oe];function Oi(o){return typeof o=="object"&&o!==null&&!Ki.some(e=>typeof e=="object"&&o instanceof e)}function me(o){return typeof o=="string"?mn(o):Array.isArray(o)?o.map(e=>me(e)):Oi(o)?Object.fromEntries(Object.entries(o).map(([e,t])=>[e,me(t)])):o}import{PACKET_DATA_SIZE as qi,PublicKey as Tn,sendAndConfirmTransaction as wn,Transaction as Rt}from"@solana/web3.js";var Le=M("Raydium_txTool"),Mt=class{constructor(e){this.instructions=[];this.endInstructions=[];this.signers=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers}}get allInstructions(){return[...this.instructions,...this.endInstructions]}addInstruction({instructions:e=[],endInstructions:t=[],signers:n=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...n),this}build(e){let t=new Rt;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,{transaction:t,signers:this.signers,execute:async()=>{var r;let n=await kn(this.connection);if(t.recentBlockhash=n,(r=this.owner)!=null&&r.isKeyPair)return wn(this.connection,t,this.signers);if(this.signAllTransactions){this.signers.length&&t.partialSign(...this.signers);let i=await this.signAllTransactions([t]);return await this.connection.sendRawTransaction(i[0].serialize(),{skipPreflight:!0})}throw new Error("please connect wallet first")},extInfo:e||{}}}buildMultiTx(e){let{extraPreBuildData:t=[],extInfo:n}=e,{transaction:r}=this.build(n),i=t.filter(c=>c.transaction.instructions.length>0),a=[...i.map(c=>c.transaction),r],u=[...i.map(c=>c.signers),this.signers];return{transactions:a,signers:u,execute:async()=>{var m;let c=await kn(this.connection);if((m=this.owner)!=null&&m.isKeyPair)return await Promise.all(a.map(async(d,p)=>(d.recentBlockhash=c,await wn(this.connection,d,u[p]))));if(this.signAllTransactions){let d=a.map((f,b)=>(f.recentBlockhash=c,u[b].length&&f.partialSign(...u[b]),f)),p=await this.signAllTransactions(d),y=[];for(let f=0;f<p.length;f+=1){let b=await this.connection.sendRawTransaction(p[f].serialize(),{skipPreflight:!0});y.push(b)}return y}throw new Error("please connect wallet first")},extInfo:n||{}}}};async function kn(o){var e,t;try{return((t=await((e=o.getLatestBlockhash)==null?void 0:e.call(o)))==null?void 0:t.blockhash)||(await o.getRecentBlockhash()).blockhash}catch{return(await o.getRecentBlockhash()).blockhash}}function Fi(o,e){o.length<1&&Le.logWithError(`no instructions provided: ${o.toString()}`),e.length<1&&Le.logWithError(`no signers provided:, ${e.toString()}`);let t=new Rt;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...o);let n=t.compileMessage().serialize();return e.length+e.length*64+n.length}async function An(o,e,t){let n=new Tn("RaydiumSimuLateTransaction11111111111111111"),r=[],i=new Rt;i.feePayer=n;for(let c of e)Fi([...i.instructions,c],[n])>qi&&(r.push(i),i=new Rt,i.feePayer=n),i.add(c);i.instructions.length>0&&r.push(i);let a=[];try{a=await Promise.all(r.map(c=>o.simulateTransaction(c)))}catch(c){c instanceof Error&&Le.logWithError(`failed to simulate for instructions, RPC_ERROR, ${c.message}`)}let u=[];for(let c of a){let{value:m}=c;if(Le.debug(`simulate result: ${JSON.stringify(c)}`),m.logs){let d=m.logs.filter(p=>p&&p.includes(t));Le.debug(`filteredLog: ${JSON.stringify(u)}`),d.length||Le.logWithError(` "simulate log not match keyword, keyword: ${t}`),u.push(...d)}}return u}function In(o,e){let t=o.match(/{["\w:,]+}/g);return!t||t.length!==1?Le.logWithError(`simulate log fail to match json, keyword: ${e}`):t[0]}function ge(o,e){let n=new RegExp(`"${e}":(\\d+)`,"g").exec(o);return!n||n.length!==2?Le.logWithError(`simulate log fail to match key", key: ${e}`):n[1]}async function Pe(o,e){let[t,n]=await Tn.findProgramAddress(o,e);return{publicKey:t,nonce:n}}var le=class{constructor(e){this._owner=e}get publicKey(){return le.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return le.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return le.isKeyPair(this._owner)}get isPublicKey(){return le.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!le.isKeyPair(e)}};function xn(o,e=1,t=[]){let n=[...o];if(e<=0)return t;for(;n.length;)t.push(n.splice(0,e));return t}function Mc(o,...e){return o.filter(t=>e.every(n=>n.includes(t)))}function Bc(o,...e){return o.filter(t=>e.every(n=>!n.includes(t)))}function Kc(o){return[...new Set(o)]}import{PublicKey as Ni}from"@solana/web3.js";var no=M("Raydium_accountInfo_util");async function vi(o,e,t){let{batchRequest:n,commitment:r}=x({batchRequest:!1},t),i=xn(e,100),a=new Array(i.length).fill([]);if(n){let u=i.map(m=>{let d=o._buildArgs([m.map(p=>p.toBase58())],r,"base64");return{methodName:"getMultipleAccounts",args:d}});a=(await o._rpcBatchRequest(u)).map(m=>(m.error&&no.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(d=>{if(d){let{data:p,executable:y,lamports:f,owner:b,rentEpoch:w}=d;return p.length!==2&&p[1]!=="base64"&&no.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(p[0],"base64"),executable:y,lamports:f,owner:new Ni(b),rentEpoch:w}}return null})))}else try{a=await Promise.all(i.map(u=>o.getMultipleAccountsInfo(u,r)))}catch(u){u instanceof Error&&no.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return a.flat()}async function Sn(o,e,t){let n=await vi(o,e.map(r=>r.pubkey),t);return e.map((r,i)=>K(x({},r),{accountInfo:n[i]}))}function te(o){if(o instanceof oe)return new I(o.numerator,o.denominator);if(o instanceof j)return o.adjusted;if(o instanceof O)try{return te(o.toExact())}catch{return new I(ae)}if(o instanceof I)return o;let e=String(o),t=ue(e);return new I(t.numerator,t.denominator)}function Gc(o){var n;if(o instanceof oe)return{fr:new I(o.numerator,o.denominator)};if(o instanceof j)return{fr:o.adjusted};if(o instanceof O)return{fr:te(o.toExact()),decimals:o.token.decimals};if(o instanceof I)return{fr:o};let e=String(o),t=ue(e);return{fr:new I(t.numerator,t.denominator),decimals:(n=t.dec)==null?void 0:n.length}}function Jc(o,e){if(o==null||e==null)return!1;let t=te(o),n=te(e);return t.sub(n).numerator,t.sub(n).numerator.lt(ae)}function Di(o,e){if(o==null||e==null)return!1;let t=te(o),n=te(e);return t.sub(n).numerator.gt(ae)}function $c(o,e){if(o==null||e==null)return!1;let t=te(o),n=te(e);return t.sub(n).numerator.lte(ae)}function Ln(o,e){if(o==null||e==null)return!1;let t=te(o),n=te(e);return t.sub(n).numerator.gte(ae)}function Ei(o,e){if(o==null||e==null)return!1;let t=te(o),n=te(e);return t.sub(n).numerator.eq(ae)}function ro(o,e){if(o==null||e==null)return;let t=te(o),n=te(e);try{return t.div(n)}catch{return t}}function _n(o,e){if(o==null||e==null)return;let t=te(o),n=te(e);return t.sub(n)}function Bt(o){return o==null?!1:!Ei(o,0)}function Rn(o,e){return Di(e,o)?e:o}var Mn=o=>typeof o=="number",Bn=o=>o?new Date(o):new Date,Vi=o=>Bn(o).getTime();function et(o,e,t){let n=Mn(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(o).getTime()<=n}function Ee(o,e,t){let n=Mn(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(o).getTime()>n}function io(o,e){let n=Vi(o)+(e.days?e.days*24*60*60*1e3:0)+(e.hours?e.hours*60*60*1e3:0)+(e.minutes?e.minutes*60*1e3:0)+(e.seconds?e.seconds*1e3:0)+(e.milliseconds?e.milliseconds:0);return Bn(n)}var Ve=M("Raydium_Api");async function cm(o,e,t=1e3){let n;for(;n==null;)try{Ve.debug(`Request ${o} through endlessRetry`),n=await e()}catch(r){Ve.error(`Request ${o} failed, retry after ${t} ms`,r),await hn(t)}return n}var Kt=class{constructor({cluster:e,timeout:t}){this.cluster=e,this.api=Ci.create({baseURL:"https://api.raydium.io/v2",timeout:t}),this.api.interceptors.request.use(n=>{let{method:r,baseURL:i,url:a}=n;return Ve.debug(`${r==null?void 0:r.toUpperCase()} ${i}${a}`),n},n=>(Ve.error("Request failed"),Promise.reject(n))),this.api.interceptors.response.use(n=>{let{config:r,data:i,status:a}=n,{method:u,baseURL:c,url:m}=r;return Ve.debug(`${u==null?void 0:u.toUpperCase()} ${c}${m}  ${a}`),i},n=>{let{config:r,response:i={}}=n,{status:a}=i,{method:u,baseURL:c,url:m}=r;return Ve.error(`${u.toUpperCase()} ${c}${m} ${a||n.message}`),Promise.reject(n)})}async getTokens(){return this.api.get("/sdk/token/raydium.mainnet.json")}async getLiquidityPools(){return this.api.get(`/sdk/liquidity/${this.cluster}.json`)}async getPairsInfo(){return this.api.get("https://api.raydium.io/v2/main/pairs")}async getFarmPools(){return this.api.get(`/sdk/farm-v2/${this.cluster}.json`)}async getCoingeckoPrice(e){return this.api.get(`https://api.coingecko.com/api/v3/simple/price?ids=${e.join(",")}&vs_currencies=usd`)}async getRaydiumTokenPrice(){return this.api.get("https://api.raydium.io/v2/main/price")}async getBlockSlotCountForSecond(e){if(!e)return 2;let n=(await this.api.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(r=>r.numSlots);return n.reduce((r,i)=>r+i,0)/n.length/60}};import{merge as zs}from"lodash";var Ot="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",Kn="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{getAssociatedTokenAddress as Wn,createAssociatedTokenAccountInstruction as Un,TOKEN_PROGRAM_ID as Qa}from"@solana/spl-token";import{PublicKey as Ha}from"@solana/web3.js";var ao=(...o)=>o.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),ie=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=M(t)}createTxBuilder(e){return this.scope.checkOwner(),new Mt({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,owner:this.scope.owner,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(ao(e))}logInfo(...e){this.logger.info(ao(e))}logAndCreateError(...e){let t=ao(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{createInitializeAccountInstruction as va,createCloseAccountInstruction as Da,createTransferInstruction as Ea,TOKEN_PROGRAM_ID as Va}from"@solana/spl-token";import{Keypair as Ca,PublicKey as Wa,SystemProgram as Ua}from"@solana/web3.js";import Ga from"bn.js";import{PublicKey as Oa}from"@solana/web3.js";import Dn,{isBN as En}from"bn.js";import{bits as Wi,BitStructure as Ui,blob as Gi,Blob as Ji,cstr as $i,f32 as ji,f32be as Yi,f64 as Qi,f64be as Hi,greedy as zi,Layout as Zi,ns64 as Xi,ns64be as ea,nu64 as ta,nu64be as oa,offset as na,s16 as ra,s16be as ia,s24 as aa,s24be as sa,s32 as ua,s32be as ca,s40 as ma,s40be as la,s48 as da,s48be as pa,s8 as fa,seq as ya,struct as wm,Structure as ba,u16 as ga,u16be as Pa,u24 as ha,u24be as wa,u32 as ka,u32be as Ta,u40 as Aa,u40be as Ia,u48 as xa,u48be as Sa,u8 as La,UInt as _a,union as Ra,Union as Ma,unionLayoutDiscriminator as Ba,utf8 as Ka}from"@solana/buffer-layout";var tt=Zi,On=ba,qn=Ma,km=Ui,so=_a,Fn=Ji,Tm=zi,qt=La,Am=ga,Im=ha,ot=ka,xm=Aa,Sm=xa,Lm=ta,_m=Pa,Rm=wa,Mm=Ta,Bm=Ia,Km=Sa,Om=oa,qm=fa,Fm=ra,Nm=aa,vm=ua,Dm=ma,Em=da,Vm=Xi,Cm=ia,Wm=sa,Um=ca,Gm=la,Jm=pa,$m=ea,jm=ji,Ym=Yi,Qm=Qi,Hm=Hi;var Nn=ya,vn=Ra,zm=Ba,Ce=Gi,Zm=$i,Xm=Ka,uo=Wi,co=na;var We=class extends tt{constructor(t,n,r){super(t,r);this.blob=Ce(t),this.signed=n}decode(t,n=0){let r=new Dn(this.blob.decode(t,n),10,"le");return this.signed?r.fromTwos(this.span*8).clone():r}encode(t,n,r=0){return typeof t=="number"&&(t=new Dn(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),n,r)}},Vn=class extends tt{constructor(t){super(8,t);this._lower=uo(ot(),!1),this._upper=uo(ot(),!1)}addBoolean(t){this._lower.fields.length<32?this._lower.addBoolean(t):this._upper.addBoolean(t)}decode(t,n=0){let r=this._lower.decode(t,n),i=this._upper.decode(t,n+this._lower.span);return x(x({},r),i)}encode(t,n,r=0){return this._lower.encode(t,n,r)+this._upper.encode(t,n,r+this._lower.span)}};function v(o){return new so(1,o)}function qe(o){return new so(4,o)}function l(o){return new We(8,!1,o)}function Q(o){return new We(16,!1,o)}function rl(o){return new We(8,!0,o)}function il(o){return new We(16,!0,o)}var he=class extends tt{constructor(t,n,r,i){super(t.span,i);this.layout=t,this.decoder=n,this.encoder=r}decode(t,n){return this.decoder(this.layout.decode(t,n))}encode(t,n,r){return this.layout.encode(this.encoder(t),n,r)}getSpan(t,n){return this.layout.getSpan(t,n)}};function k(o){return new he(Ce(32),e=>new Oa(e),e=>e.toBuffer(),o)}var mo=class extends tt{constructor(t,n){super(-1,n);this.layout=t,this.discriminator=qt()}encode(t,n,r=0){return t==null?this.discriminator.encode(0,n,r):(this.discriminator.encode(1,n,r),this.layout.encode(t,n,r+1)+1)}decode(t,n=0){let r=this.discriminator.decode(t,n);if(r===0)return null;if(r===1)return this.layout.decode(t,n+1);throw new Error("Invalid option "+this.property)}getSpan(t,n=0){let r=this.discriminator.decode(t,n);if(r===0)return 1;if(r===1)return this.layout.getSpan(t,n+1)+1;throw new Error("Invalid option "+this.property)}};function al(o,e){return new mo(o,e)}function sl(o){return new he(qt(),qa,Fa,o)}function qa(o){if(o===0)return!1;if(o===1)return!0;throw new Error("Invalid bool: "+o)}function Fa(o){return o?1:0}function ul(o,e){let t=ot("length"),n=R([t,H(o,co(t,-t.span),"values")]);return new he(n,({values:r})=>r,r=>({values:r}),e)}function cl(o,e,t){let n=R([l("tag"),e.replicate("data")]);function r({tag:i,data:a}){if(!i.eq(o))throw new Error("Invalid tag, expected: "+o.toString("hex")+", got: "+i.toString("hex"));return a}return new he(n,r,i=>({tag:o,data:i}),t)}function Na(o){let e=ot("length"),t=R([e,Ce(co(e,-e.span),"data")]);return new he(t,({data:n})=>n,n=>({data:n}),o)}function ml(o){return new he(Na(),e=>e.toString("utf-8"),e=>Buffer.from(e,"utf-8"),o)}function ll(o,e){let t=vn(qt(),e);return o.forEach((n,r)=>t.addVariant(r,n,n.property)),t}function dl(o,e,t){let n=R([H(o,e,"values")]);return new he(n,({values:r})=>r,r=>({values:r}),t)}var lo=class extends On{decode(e,t){return super.decode(e,t)}};function R(o,e,t){return new lo(o,e,t)}var po=class extends qn{encodeInstruction(e){let t=Math.max(...Object.values(this.registry).map(r=>r.span)),n=Buffer.alloc(t);return n.slice(0,this.encode(e,n))}decodeInstruction(e){return this.decode(e)}};function pl(o,e,t){return new po(o,e,t)}var fo=class extends Fn{decode(e,t){let n=super.decode(e,t);if(!n.every(r=>r===0))throw new Error("nonzero padding bytes");return n}};function fl(o){return new fo(o)}function H(o,e,t){let n,r=typeof e=="number"?e:En(e)?e.toNumber():new Proxy(e,{get(i,a){if(!n){let u=Reflect.get(i,"count");n=En(u)?u.toNumber():u,Reflect.set(i,"count",n)}return Reflect.get(i,a)},set(i,a,u){return a==="count"&&(n=u),Reflect.set(i,a,u)}});return Nn(o,r,t)}var we=R([k("mint"),k("owner"),l("amount"),qe("delegateOption"),k("delegate"),v("state"),qe("isNativeOption"),l("isNative"),l("delegatedAmount"),qe("closeAuthorityOption"),k("closeAuthority")]);function Ja(o){let{mint:e,tokenAccount:t,owner:n}=o;return va(t,e,n)}function Fe(o){let{tokenAccount:e,payer:t,multiSigners:n=[],owner:r}=o;return Da(e,t,r,n)}async function _e(o){let{connection:e,amount:t,commitment:n,payer:r,owner:i,skipCloseAccount:a}=o,u=await e.getMinimumBalanceForRentExemption(we.span,n),c=S(t).add(new Ga(u)),m=Ca.generate();return{signers:[m],instructions:[Ua.createAccount({fromPubkey:r,newAccountPubkey:m.publicKey,lamports:c.toNumber(),space:we.span,programId:Va}),Ja({mint:new Wa(Y.mint),tokenAccount:m.publicKey,owner:i})],endInstructions:a?[]:[Fe({tokenAccount:m.publicKey,payer:r,owner:i})]}}function Ue({source:o,destination:e,owner:t,amount:n,multiSigners:r=[]}){return Ea(o,e,t,S(n).toNumber(),r)}import{PublicKey as $a}from"@solana/web3.js";import ja from"bn.js";var Ya=M("Raydium_Util");function Cn({solAccountResp:o,tokenAccountResp:e}){let t=[],n=[];for(let{pubkey:r,account:i}of e.value){if(i.data.length!==we.span)throw Ya.error("invalid token account layout length","publicKey",r.toBase58()),new Error("invalid token account layout length");let a=we.decode(i.data),{mint:u,amount:c}=a;t.push({publicKey:r,mint:u,amount:c,isNative:!1}),n.push({pubkey:r,accountInfo:a})}return o&&t.push({mint:$a.default,amount:new ja(o.lamports),isNative:!0}),{tokenAccounts:t,tokenAccountRawInfos:n}}var nt=class extends ie{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._ataCache=new Map;this._accountListener=[];this._clientOwnedToken=!1;let{tokenAccounts:n,tokenAccountRawInfos:r}=t;this._tokenAccounts=n||[],this._tokenAccountRawInfos=r||[],this._clientOwnedToken=!!(n||r)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:n}){return t&&(this._tokenAccounts=t),n&&(this._tokenAccountRawInfos=n),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(n=>n!==t),this}async getAssociatedTokenAccount(t){this.scope.checkOwner();let n=`${this.scope.ownerPubKey.toBase58()}_${t.toBase58()}`;if(this._ataCache.has(n))return this._ataCache.get(n);let r=await Wn(t,this.scope.ownerPubKey,!0);return this._ataCache.set(n,r),r}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length)return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let r=x(x({},{}),t),i=await this.scope.connection.getAccountInfo(this.scope.ownerPubKey,r.commitment),a=await this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Qa},r.commitment),{tokenAccounts:u,tokenAccountRawInfos:c}=Cn({solAccountResp:i,tokenAccountResp:a});return this._tokenAccounts=u,this._tokenAccountRawInfos=c,this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>this.fetchWalletTokenAccounts({forceUpdate:!0}),"confirmed"),{tokenAccounts:u,tokenAccountRawInfos:c}}async getCreatedTokenAccount({mint:t,associatedOnly:n=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:a})=>a==null?void 0:a.equals(t)).sort((a,u)=>a.amount.lt(u.amount)?1:-1),i=await this.getAssociatedTokenAccount(t);for(let a of r){let{publicKey:u}=a;if(u)return n&&i.equals(u),u}}async checkOrCreateAta({mint:t,autoUnwrapWSOLToSOL:n}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:c})=>(c==null?void 0:c.toBase58())===t.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,a={};if(!r){let c=await this.getAssociatedTokenAccount(t),m=await Un(i,c,i,t);a.instructions=[m],r=c}return n&&Y.mint===t.toBase58()&&(a.endInstructions=[Fe({owner:i,payer:i,tokenAccount:r})]),{pubKey:r,newInstructions:a}}async handleTokenAccount(t){let{side:n,amount:r,mint:i,tokenAccount:a,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:c,skipCloseAccount:m}=t,d=this.createTxBuilder(),p=await Wn(i,this.scope.ownerPubKey,!0);if(new Ha(Y.mint).equals(i)){let y=await _e({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:r,skipCloseAccount:m});return d.addInstruction(y),x({tokenAccount:y.signers[0].publicKey},y)}else if(!a||n==="out"&&!p.equals(a)&&!c)return{tokenAccount:p,instructions:[Un(this.scope.ownerPubKey,p,this.scope.ownerPubKey,i)]};return{tokenAccount:a}}};import{TOKEN_PROGRAM_ID as ut,createAssociatedTokenAccountInstruction as bs}from"@solana/spl-token";import{Keypair as gs,PublicKey as Z,SystemProgram as Pr,SYSVAR_CLOCK_PUBKEY as Ps,TransactionInstruction as ct}from"@solana/web3.js";import Ao from"bn.js";import{PublicKey as at}from"@solana/web3.js";var yo=R([v("instruction")]),bo=R([v("instruction")]),za=R([l("rewardState"),l("rewardOpenTime"),l("rewardEndTime"),l("rewardLastUpdateTime"),l("totalReward"),l("totalRewardEmissioned"),l("rewardClaimed"),l("rewardPerSecond"),Q("accRewardPerShare"),k("rewardVault"),k("rewardMint"),k("rewardSender"),l("rewardType"),H(l(),15,"padding")]),Za=R([l("state"),l("nonce"),k("lpVault"),k("rewardVault"),k(),k(),l(),l(),l("totalReward"),Q("perShareReward"),l("lastSlot"),l("perSlotReward")]),Xa=R([l("state"),l("nonce"),k("lpVault"),k("rewardVaultA"),l("totalRewardA"),Q("perShareRewardA"),l("perSlotRewardA"),v("option"),k("rewardVaultB"),Ce(7),l("totalRewardB"),Q("perShareRewardB"),l("perSlotRewardB"),l("lastSlot"),k()]),es=R([l(),l("state"),l("nonce"),l("validRewardTokenNum"),Q("rewardMultiplier"),l("rewardPeriodMax"),l("rewardPeriodMin"),l("rewardPeriodExtend"),k("lpMint"),k("lpVault"),H(za,5,"rewardInfos"),k("creator"),k(),H(l(),32,"padding")]),Gn=new Proxy(Za,{get(o,e,t){return e==="decode"?(...n)=>{let r=o.decode(...n);return K(x({},r),{version:3,rewardInfos:[{rewardVault:r.rewardVault,totalReward:r.totalReward,perSlotReward:r.perSlotReward,perShareReward:r.perShareReward}]})}:Reflect.get(o,e,t)}}),Jn=new Proxy(Xa,{get(o,e,t){return e==="decode"?(...n)=>{let r=o.decode(...n);return K(x({},r),{version:5,rewardInfos:[{rewardVault:r.rewardVaultA,totalReward:r.totalRewardA,perSlotReward:r.perSlotRewardA,perShareReward:r.perShareRewardA},{rewardVault:r.rewardVaultB,totalReward:r.totalRewardB,perSlotReward:r.perSlotRewardB,perShareReward:r.perShareRewardB}]})}:Reflect.get(o,e,t)}}),rt=new Proxy(es,{get(o,e,t){return e==="decode"?(...n)=>{let r=o.decode(...n);return K(x({},r),{version:6,rewardInfos:r.rewardInfos.map(i=>{var a;return K(x({},i),{rewardType:((a=Object.entries(Ft).find(u=>String(u[1])===i.rewardType.toString()))!=null?a:["Standard SPL"])[0]})})})}:Reflect.get(o,e,t)}}),ts=R([l("isSet"),l("rewardPerSecond"),l("rewardOpenTime"),l("rewardEndTime"),l("rewardType")]),go=R([v("instruction"),l("nonce"),H(ts,5,"rewardTimeInfo")]),Po=R([v("instruction"),l("rewardReopenTime"),l("rewardEndTime"),l("rewardPerSecond")]),ho=R([v("instruction"),l("isSet"),l("rewardPerSecond"),l("rewardOpenTime"),l("rewardEndTime")]),Zl=R([l("state"),k("id"),k("owner"),l("deposited"),H(l(),1,"rewardDebts")]),$n=R([l("state"),k("id"),k("owner"),l("deposited"),H(Q(),1,"rewardDebts"),H(l(),17)]),Xl=R([l("state"),k("id"),k("owner"),l("deposited"),H(l(),2,"rewardDebts")]),jn=R([l("state"),k("id"),k("owner"),l("deposited"),H(Q(),2,"rewardDebts"),H(l(),17)]),Yn=R([l(),l("state"),k("id"),k("owner"),l("deposited"),H(Q(),5,"rewardDebts"),H(l(),16)]),it=R([v("instruction"),l("amount")]);var Qn=M("Raydium_farm_config"),Hn="EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q",os=new at(Hn),zn="9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z",ns=new at(zn),Zn="FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG",rs=new at(Zn),Xn={[Hn]:3,[zn]:5,[Zn]:6},er={3:os,5:ns,6:rs},tr=new at("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),or=new at("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),nr={3:Gn,5:Jn,6:rt},rr={3:$n,5:jn,6:Yn},wo=o=>[3,5,6].indexOf(o)!==-1,is={3:10,5:11,6:1},ir=o=>{let e=is[o];return e||Qn.logWithError("invalid deposit farm version"),e},as={3:11,5:12,6:2},ar=o=>{let e=as[o];return e||Qn.logWithError("invalid withdraw farm version"),e},sr=o=>{var a;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:n}=o,r=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(n)}`,i={3:()=>{if(t.length!==1||n.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${r}`},5:()=>{if(t.length!==n.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${r}`},6:()=>{if(!n.length||t.length!==n.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${r}`}};return(a=i[e])==null?void 0:a.call(i)},Ft={"Standard SPL":0,"Option tokens":1};import{SystemProgram as ss,SYSVAR_RENT_PUBKEY as us,TransactionInstruction as ur}from"@solana/web3.js";import cs from"bn.js";var ms=M("Raydium_farm_instruction");async function cr(o){let{version:e,id:t,ledger:n,programId:r,owner:i}=o,a={3:9,5:10}[e];a||ms.logWithError(`invalid farm pool version: ${e}`);let u=Buffer.alloc(yo.span);yo.encode({instruction:a},u);let c=[s({pubkey:t}),s({pubkey:n}),s({pubkey:i,isWritable:!1}),s({pubkey:ss.programId,isWritable:!1}),s({pubkey:us,isWritable:!1})];return new ur({programId:r,keys:c,data:u})}function mr(o){var n;let e=Buffer.alloc(go.span);go.encode({instruction:0,nonce:new cs(o.nonce),rewardTimeInfo:o.rewardInfoConfig},e);let t=[...Oe,s({pubkey:o.farmKeyPair.publicKey}),s({pubkey:o.farmAuthority,isWritable:!1}),s({pubkey:o.lpVault}),s({pubkey:o.lpMint,isWritable:!1}),s({pubkey:o.lockVault}),s({pubkey:o.lockMint,isWritable:!1}),s({pubkey:(n=o.lockUserAccount)!=null?n:U}),s({pubkey:o.owner,isWritable:!1,isSigner:!0})];for(let r of o.rewardInfo)t.push(s({pubkey:r.rewardMint,isWritable:!1}),s({pubkey:r.rewardVault}),s({pubkey:r.userRewardToken}));return new ur({programId:o.programId,keys:t,data:e})}import z from"bn.js";var st=M("Raydium.farm.util");async function Nt({programId:o,poolId:e,mint:t,type:n}){let{publicKey:r}=await Pe([e.toBuffer(),t.toBuffer(),Buffer.from(n==="lpVault"?"lp_vault_associated_seed":n==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],o);return r}function ls(o){let t=E({publicKey:o}).toBase58();return Xn[t]}async function ko({programId:o,poolId:e,owner:t}){let{publicKey:n}=await Pe([e.toBuffer(),t.toBuffer(),Buffer.from(ls(o)===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],o);return n}var lr=async({programId:o,poolId:e})=>await Pe([e.toBuffer()],o);function dr(o){return er[o]}function pr(o){return{isSet:new z(1),rewardPerSecond:S(o.rewardPerSecond),rewardOpenTime:S(o.rewardOpenTime),rewardEndTime:S(o.rewardEndTime),rewardType:S(o.rewardType)}}function To(o){return S(o.rewardEndTime).sub(S(o.rewardOpenTime)).mul(S(o.rewardPerSecond))}function ds(o){let e=rr[o];return e||st.logWithError("invalid version",o),e}function ps(o){let e=nr[o];return e||st.logWithError("invalid version",o),e}function fs(o,e,t,n){if(o.version===3||o.version===5){if(o.lastSlot.gte(new z(t)))return o;let r=new z(t).sub(o.lastSlot);o.lastSlot=new z(t);for(let i of o.rewardInfos){if(e.amount.eq(new z(0)))continue;let a=i.perSlotReward.mul(r);i.perShareReward=i.perShareReward.add(a.mul(new z(10).pow(new z(o.version===3?9:15))).div(e.amount)),i.totalReward=i.totalReward.add(a)}}else if(o.version===6)for(let r of o.rewardInfos){if(r.rewardState.eq(new z(0)))continue;let i=z.min(new z(n),r.rewardEndTime);if(r.rewardOpenTime.gte(i))continue;let u=i.sub(r.rewardLastUpdateTime).mul(r.rewardPerSecond),c=r.totalReward.sub(r.totalRewardEmissioned);c.lt(u)?(u=c,r.rewardLastUpdateTime=r.rewardLastUpdateTime.add(c.div(r.rewardPerSecond))):r.rewardLastUpdateTime=i,!e.amount.eq(new z(0))&&(r.accRewardPerShare=r.accRewardPerShare.add(u.mul(o.rewardMultiplier).div(e.amount)),r.totalRewardEmissioned=r.totalRewardEmissioned.add(u))}return o}async function ys({connection:o,farmPools:e,owner:t,config:n}){var y;let r=!1,i=!1,a=new z(10),u=[];for(let f of e){let b=me(f);b.version===6?i=!0:r=!0,u.push({pubkey:b.id,version:b.version,key:"state",poolId:b.id},{pubkey:b.lpVault,version:b.version,key:"lpVault",poolId:b.id}),t&&u.push({pubkey:await ko({programId:b.programId,poolId:b.id,owner:t}),version:b.version,key:"ledger",poolId:b.id})}let c={},m=await Sn(o,u,n);for(let{pubkey:f,version:b,key:w,poolId:L,accountInfo:g}of m){let T=L.toBase58();if(c[T]=x({},c[T]),w==="state"){let _=ps(b);(!g||!g.data||g.data.length!==_.span)&&st.logWithError(`invalid farm state account info, pools.id, ${f}`),c[T].state=_.decode(g.data)}else if(w==="lpVault")(!g||!g.data||g.data.length!==we.span)&&st.logWithError(`invalid farm lp vault account info, pools.lpVault, ${f}`),c[T].lpVault=we.decode(g.data);else if(w==="ledger"){let _=ds(b);g&&g.data&&(g.data.length!==_.span&&st.logWithError(`invalid farm ledger account info, ledger, ${f}`),c[T].ledger=_.decode(g.data))}}let d=i||r?await o.getSlot():0,p=i&&(y=await o.getBlockTime(d))!=null?y:0;for(let f of Object.keys(c))c[f].state=fs(c[f].state,c[f].lpVault,d,p);for(let[f,{state:b,ledger:w}]of Object.entries(c))if(w){let L=b.version===6?b.rewardMultiplier:b.rewardInfos.length===1?a.pow(new z(9)):a.pow(new z(15)),g=b.rewardInfos.map((T,_)=>{let A=w.rewardDebts[_];return w.deposited.mul(b.version===6?T.accRewardPerShare:T.perShareReward).div(L).sub(A)});c[f].wrapped=K(x({},c[f].wrapped),{pendingRewards:g})}return c}async function fr(o){let{farmPools:e}=o,t=await ys(o);return e.map((r,i)=>K(x(x(x({},e[i]),me(r)),t[r.id]),{jsonInfo:e[i]}))}function yr(o,e=Date.now()){if(o.version===6){let t=o.state.rewardInfos;if(t.every(({rewardOpenTime:n})=>et(e,n.toNumber(),{unit:"s"})))return"upcoming pool";if(t.every(({rewardEndTime:n})=>Ee(e,n.toNumber(),{unit:"s"})))return"closed pool"}else{let t=o.state.rewardInfos.map(({perSlotReward:n})=>n);if(t.length===2){if(String(t[0])==="0"&&String(t[1])!=="0")return"normal fusion pool";if(String(t[0])!=="0"&&String(t[1])!=="0")return"dual fusion pool";if(String(t[0])==="0"&&String(t[1])==="0")return"closed pool"}else if(t.length===1&&String(t[0])==="0")return"closed pool"}}function br(o){return o.state.rewardInfos.length===1&&String(o.lpMint)===_t.toBase58()}function gr(o,e){return o.version===6?o.state.rewardInfos.map(({rewardPerSecond:t,rewardOpenTime:n,rewardEndTime:r},i)=>{var y;let a=et(e.currentBlockChainDate,n.toNumber(),{unit:"s"}),u=Ee(e.currentBlockChainDate,r.toNumber(),{unit:"s"});if(a||u)return;let c=e.rewardTokens[i];if(!c)return;let m=e.rewardTokenPrices[i];if(!m)return;let d=He(new I(t,pe).div(be.pow(new z(c.decimals||1))).mul(new z(60*60*24*365)),m);return e.tvl?e.tvl.isZero()?Ke(0):d.div((y=e.tvl)!=null?y:pe):void 0}):o.state.rewardInfos.map(({perSlotReward:n},r)=>{var m;let i=e.rewardTokens[r];if(!i)return;let a=e.rewardTokenPrices[r];if(!a)return;let u=He(new I(n,pe).div(be.pow(new z(i.decimals||1))).mul(new z(e.blockSlotCountForSecond*60*60*24*365)),a);return e.tvl?e.tvl.isZero()?Ke(0):u.div((m=e.tvl)!=null?m:pe):void 0})}var mt=class extends ie{constructor(){super(...arguments);this._farmPools=[];this._hydratedFarmPools=[];this._hydratedFarmMap=new Map;this._sdkParsedFarmPools=[];this._lpTokenInfoMap=new Map}async load(t){var r;await this.scope.liquidity.load(t),await this.scope.fetchFarms(t==null?void 0:t.forceUpdate);let n=((r=this.scope.apiData.farmPools)==null?void 0:r.data)||{};this._farmPools=Object.keys(n||{}).reduce((i,a)=>{var u,c;return i.concat(((c=(u=n[a]).map)==null?void 0:c.call(u,m=>{let d=this.scope.token.allTokenMap.get(m.baseMint),p=this.scope.token.allTokenMap.get(m.quoteMint);return d&&p&&this._lpTokenInfoMap.set(m.lpMint,new C({mint:m.lpMint,decimals:d.decimals,symbol:`${d.symbol} - ${p.name}`,name:`${d.symbol} - ${p.name} LP`})),K(x({},m),{name:m.symbol,category:a})}))||[])},[]),await this.fetchSdkFarmInfo()}async fetchSdkFarmInfo(){var t;this._sdkParsedFarmPools=await fr({connection:this.scope.connection,farmPools:this._farmPools,owner:(t=this.scope.owner)==null?void 0:t.publicKey,config:{commitment:"confirmed"}})}async loadHydratedFarmInfo(t){let{forceUpdate:n,skipPrice:r}=t||{};if(this._hydratedFarmPools.length&&!n)return this._hydratedFarmPools;await this.scope.farm.load();try{await this.scope.account.fetchWalletTokenAccounts()}catch{}!r&&await this.scope.token.fetchTokenPrices(),await this.scope.liquidity.loadPairs();let i=await this.scope.chainTimeOffset(),a=io(Date.now()+i,{minutes:0}),u=await this.scope.api.getBlockSlotCountForSecond(this.scope.connection.rpcEndpoint),c=Object.fromEntries(this.scope.liquidity.allPairs.map(m=>[m.ammId,{apr30d:m.apr30d,apr7d:m.apr7d,apr24h:m.apr24h}]));return this._hydratedFarmPools=this._sdkParsedFarmPools.map(m=>{let d=this.hydrateFarmInfo({farmInfo:m,blockSlotCountForSecond:u,farmAprs:c,currentBlockChainDate:a,chainTimeOffset:i});return this._hydratedFarmMap.set(m.id.toBase58(),d),d}),this._hydratedFarmPools}get allFarms(){return this._farmPools}get allParsedFarms(){return this._sdkParsedFarmPools}get allHydratedFarms(){return this._hydratedFarmPools}get allHydratedFarmMap(){return this._hydratedFarmMap}getFarm(t){let n=E({publicKey:t}),r=this.allFarms.find(i=>i.id===n.toBase58());return r||this.logAndCreateError("invalid farm id"),r}getParsedFarm(t){let n=E({publicKey:t}),r=this.allParsedFarms.find(i=>n.equals(i.id));return r||this.logAndCreateError("invalid farm id"),r}getLpTokenInfo(t){let n=E({publicKey:t}),r=this._lpTokenInfoMap.get(n.toBase58());return r||this.logAndCreateError("LP Token not found",n.toBase58()),r}lpDecimalAmount({mint:t,amount:n}){let r=ue(n),i=this.getLpTokenInfo(t);return xe(new I(r.numerator,r.denominator).mul(new Ao(10).pow(new Ao(i.decimals))))}hydrateFarmInfo(t){var gt,Pt,Je,$e,je,ht,Do,Eo,Vo,Co,Wo,Uo;let{farmInfo:n,blockSlotCountForSecond:r,farmAprs:i,currentBlockChainDate:a,chainTimeOffset:u=0}=t,c=yr(n,a),m=br(n),d=c==="dual fusion pool",p=c==="normal fusion pool",y=c==="closed pool"&&!n.upcoming,f=n.version!==6?n.upcoming&&y:n.upcoming,b=n.version!==6&&n.upcoming&&!y,w=((gt=this.scope.liquidity.allPools.find(B=>B.lpMint===n.lpMint.toBase58()))==null?void 0:gt.version)===5,L=m?this.scope.mintToToken(n.lpMint):this.getLpTokenInfo(n.lpMint),g=this.scope.mintToToken(m?n.lpMint:n.baseMint),T=this.scope.mintToToken(m?n.lpMint:n.quoteMint);g!=null&&g.symbol;let _=m?`${(Pt=g==null?void 0:g.symbol)!=null?Pt:"unknown"}`:`${(Je=g==null?void 0:g.symbol)!=null?Je:"unknown"}-${($e=T==null?void 0:T.symbol)!=null?$e:"unknown"}`,A=n.jsonInfo.rewardInfos.map(({rewardMint:B})=>this.scope.mintToToken(B)),q=(je=n.wrapped)==null?void 0:je.pendingRewards.map((B,W)=>A[W]?new O(A[W],xe(Rn(B,0))):void 0),F=m?this.scope.token.tokenPrices.get(n.lpMint.toBase58()):this.scope.liquidity.lpPriceMap.get(n.lpMint.toBase58()),N=L&&new O(L,n.lpVault.amount),J=F&&L?He(new O(L,n.lpVault.amount),F):void 0,D=gr(n,{tvl:J,currentBlockChainDate:a,rewardTokens:A,rewardTokenPrices:(ht=n.rewardInfos.map(({rewardMint:B})=>this.scope.token.tokenPrices.get(B.toBase58())))!=null?ht:[],blockSlotCountForSecond:r}),G=(Do=this.scope.liquidity.allPools.find(B=>B.lpMint===n.lpMint.toBase58()))==null?void 0:Do.id,X=G?It((Eo=i[G])==null?void 0:Eo.apr7d,{alreadyDecimaled:!0}):void 0,$=G?It((Vo=i[G])==null?void 0:Vo.apr30d,{alreadyDecimaled:!0}):void 0,re=G?It((Co=i[G])==null?void 0:Co.apr24h,{alreadyDecimaled:!0}):void 0,se=D.reduce((B,W)=>B?W?B.add(W):B:W,X),Ie=D.reduce((B,W)=>B?W?B.add(W):B:W,$),ce=D.reduce((B,W)=>B?W?B.add(W):B:W,re),fe=n.version===6?n.state.rewardInfos.map((B,W)=>{var jo,Yo,Qo,Ho;let{rewardOpenTime:Ye,rewardEndTime:wt,rewardPerSecond:Gt}=B,Be=Ye.toNumber()?new Date(Ye.toNumber()*1e3+u):void 0,ye=wt.toNumber()?new Date(wt.toNumber()*1e3+u):void 0,Jt=Date.now()+u;if(!Be&&!ye)return;let De=this.scope.mintToToken((Qo=(Yo=B.rewardMint)!=null?Yo:(jo=n.rewardInfos[W])==null?void 0:jo.rewardMint)==null?void 0:Qo.toBase58()),Go=Boolean(Be&&et(Jt,Be)),Jo=Boolean(ye&&Ee(Jt,ye)),$o=!Be&&!ye||!Jo&&!Go,ai=$o&&Ee(Jt,io(ye,{seconds:-((Ho=n.jsonInfo.rewardPeriodExtend)!=null?Ho:72*60*60)})),si=De&&this.scope.mintToTokenAmount({mint:De.mint,amount:_n(B.totalReward,B.totalRewardEmissioned).toFixed(De.decimals)}),ui=q==null?void 0:q[W],ci=D[W],mi=Boolean(ye),kt=n.rewardInfos[W];return K(x(x({},kt),B),{owner:kt==null?void 0:kt.rewardSender,apr:ci,token:De,userPendingReward:ui,userHavedReward:mi,perSecond:De&&this.scope.mintToTokenAmount({mint:De.mint,amount:Gt}).toSignificant(),openTime:Be,endTime:ye,isOptionToken:B.rewardType==="Option tokens",isRewardBeforeStart:Go,isRewardEnded:Jo,isRewarding:$o,isRwardingBeforeEnd72h:ai,claimableRewards:si,version:6})}).filter(B=>!!B):n.state.rewardInfos.map((B,W)=>{let Ye=q==null?void 0:q[W],wt=D[W],Gt=A[W],{perSlotReward:Be}=B,ye=Bt(Ye)||Bt(Be);return K(x({},B),{apr:wt,token:Gt,userPendingReward:Ye,userHavedReward:ye,version:n.version})}),de=L&&((Wo=n.ledger)==null?void 0:Wo.deposited)?new O(L,(Uo=n.ledger)==null?void 0:Uo.deposited):void 0;return K(x({},n),{lp:L,lpPrice:F,base:g,quote:T,name:_,isStakePool:m,isDualFusionPool:d,isNormalFusionPool:p,isClosedPool:y,isUpcomingPool:f,isStablePool:w,isNewPool:b,totalApr7d:se,raydiumFeeApr7d:X,totalApr24h:ce,raydiumFeeApr24h:re,totalApr30d:Ie,raydiumFeeApr30d:$,ammId:G,tvl:J,userHasStaked:Bt(de),rewards:fe,userStakedLpAmount:de,stakedLpAmount:N})}async _getUserRewardInfo({payer:t,rewardInfo:n}){if(n.rewardMint.equals(U)){let r=await _e({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:t,amount:To(n)});return{rewardPubKey:r.signers[0].publicKey,newInstruction:r}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:n.rewardMint})}}async create({poolId:t,rewardInfos:n,payer:r}){this.checkDisabled(),this.scope.checkOwner();let i=E({publicKey:t}),a=this.scope.liquidity.allPools.find(A=>A.id===i.toBase58());a||this.logAndCreateError("invalid pool id");let c={lpMint:new Z(a.lpMint),lockInfo:{lockMint:tr,lockVault:or},version:6,rewardInfos:n,programId:dr(6)},m=this.createTxBuilder(),d=r!=null?r:this.scope.ownerPubKey,p=gs.generate(),y=await this.scope.connection.getMinimumBalanceForRentExemption(rt.span);m.addInstruction({instructions:[Pr.createAccount({fromPubkey:d,newAccountPubkey:p.publicKey,lamports:y,space:rt.span,programId:c.programId})],signers:[p]});let{publicKey:f,nonce:b}=await lr({programId:c.programId,poolId:p.publicKey}),w=await Nt({programId:c.programId,poolId:p.publicKey,mint:c.lpMint,type:"lpVault"}),L=[],g=[];for(let A of c.rewardInfos){A.rewardOpenTime>=A.rewardEndTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",A.rewardOpenTime.toString()),Ft[A.rewardType]||this.logAndCreateError("rewardType error",A.rewardType),A.rewardPerSecond<=0&&this.logAndCreateError("rewardPerSecond error",A.rewardPerSecond.toString()),L.push(pr(A));let{rewardPubKey:q,newInstruction:F}=await this._getUserRewardInfo({rewardInfo:A,payer:d});F&&m.addInstruction(F),q||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let N=A.rewardMint.equals(U)?new Z(Y.mint):A.rewardMint;g.push({rewardMint:N,rewardVault:await Nt({programId:c.programId,poolId:p.publicKey,mint:N,type:"rewardVault"}),userRewardToken:q})}let T=await this.scope.account.getCreatedTokenAccount({mint:c.lockInfo.lockMint});T||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let _=mr({farmKeyPair:p,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:w,lpMint:c.lpMint,lockVault:c.lockInfo.lockVault,lockMint:c.lockInfo.lockMint,lockUserAccount:T,programId:c.programId,rewardInfo:g,rewardInfoConfig:L,nonce:b});return await m.addInstruction({instructions:[_]}).build()}async restartReward({farmId:t,payer:n,newRewardInfo:r}){let i=this.getFarm(t);i.version!==6&&this.logAndCreateError("invalid farm version",i.version);let a={id:new Z(i.id),rewardInfos:i.rewardInfos,lpVault:new Z(i.lpVault),programId:new Z(i.programId)};r.rewardOpenTime>=r.rewardEndTime&&this.logAndCreateError("start time error","newRewardInfo",r);let u=n||this.scope.ownerPubKey,c=r.rewardMint.equals(U)?new Z(Y.mint):r.rewardMint,m=a.rewardInfos.find(L=>new Z(L.rewardMint).equals(c));m||this.logAndCreateError("configuration does not exist","rewardMint",c);let d=m.rewardVault?new Z(m.rewardVault):U,p=this.createTxBuilder(),{rewardPubKey:y,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:r,payer:u});f&&p.addInstruction(f),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=Buffer.alloc(Po.span);Po.encode({instruction:3,rewardReopenTime:S(r.rewardOpenTime),rewardEndTime:S(r.rewardEndTime),rewardPerSecond:S(r.rewardPerSecond)},b);let w=[s({pubkey:ut,isWritable:!1}),s({pubkey:a.id}),s({pubkey:a.lpVault,isWritable:!1}),s({pubkey:d}),s({pubkey:y}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await p.addInstruction({instructions:[new ct({programId:a.programId,keys:w,data:b})]}).build()}async addNewRewardToken(t){let{farmId:n,newRewardInfo:r,payer:i}=t,a=this.getFarm(n);a.version!==6&&this.logAndCreateError("invalid farm version",a.version);let u=i!=null?i:this.scope.ownerPubKey,c=this.createTxBuilder(),m=await Nt({programId:new Z(a.programId),poolId:new Z(a.id),mint:r.rewardMint,type:"rewardVault"}),{rewardPubKey:d,newInstruction:p}=await this._getUserRewardInfo({rewardInfo:r,payer:u});p&&c.addInstruction(p),d||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts);let y=r.rewardMint.equals(U)?new Z(Y.mint):r.rewardMint,f=Buffer.alloc(ho.span);ho.encode({instruction:4,isSet:new Ao(1),rewardPerSecond:S(r.rewardPerSecond),rewardOpenTime:S(r.rewardOpenTime),rewardEndTime:S(r.rewardEndTime)},f);let b=[...Oe,s({pubkey:new Z(a.id)}),s({pubkey:new Z(a.authority),isWritable:!1}),s({pubkey:y,isWritable:!1}),s({pubkey:m}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await c.addInstruction({instructions:[new ct({programId:new Z(a.programId),keys:b,data:f})]}).build()}async _prepareFarmAccounts(t){let n=this.createTxBuilder(),{farmInfo:r}=t,{pubKey:i,newInstructions:a}=await this.scope.account.checkOrCreateAta({mint:r.lpMint});n.addInstruction(a);let u=await Promise.all(r.rewardInfos.map(async({rewardMint:d})=>{let{pubKey:p,newInstructions:y}=await this.scope.account.checkOrCreateAta({mint:d,autoUnwrapWSOLToSOL:!0});return n.addInstruction(y),p})),c=await ko({programId:new Z(r.programId),poolId:new Z(r.id),owner:this.scope.ownerPubKey});if(!r.ledger&&r.version<6){let d=await cr({id:r.id,programId:r.programId,version:r.version,ledger:c,owner:this.scope.ownerPubKey});n.addInstruction({instructions:[d]})}let m=[s({pubkey:r.id}),s({pubkey:r.authority,isWritable:!1}),s({pubkey:c}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:i}),s({pubkey:new Z(r.jsonInfo.lpVault)}),s({pubkey:u[0]}),s({pubkey:r.rewardInfos[0].rewardVault}),s({pubkey:Ps,isWritable:!1}),s({pubkey:ut,isWritable:!1})];return{txBuilder:n,lpTokenAccount:i,rewardTokenAccountsPublicKeys:u,ledgerAddress:c,lowVersionKeys:m}}async deposit(t){this.scope.checkOwner();let{farmId:n,amount:r}=t,i=this.getParsedFarm(n),a=i.lpMint,{version:u,rewardInfos:c}=i;wo(u)||this.logAndCreateError("invalid farm version:",u);let{txBuilder:m,ledgerAddress:d,lpTokenAccount:p,lowVersionKeys:y,rewardTokenAccountsPublicKeys:f}=await this._prepareFarmAccounts({mint:a,farmInfo:i}),b=sr({version:u,rewardInfos:c,rewardTokenAccountsPublicKeys:f});b&&this.logAndCreateError(b);let w=Buffer.alloc(it.span);it.encode({instruction:ir(u),amount:S(r)},w);let L=u===6?[s({pubkey:ut,isWritable:!1}),s({pubkey:Pr.programId,isWritable:!1}),s({pubkey:i.id}),s({pubkey:i.authority,isWritable:!1}),s({pubkey:i.lpVault.mint}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:p})]:y;if(u!==3)for(let T=1;T<c.length;T++)L.push(s({pubkey:f[T]})),L.push(s({pubkey:c[T].rewardVault}));let g=new ct({programId:i.programId,keys:L,data:w});return await m.addInstruction({instructions:[g]}).build()}async withdraw(t){this.scope.checkOwner();let{farmId:n,amount:r}=t,i=this.getParsedFarm(n),a=i.lpMint,{version:u,rewardInfos:c}=i;wo(u)||this.logAndCreateError("invalid farm version:",u);let{txBuilder:m,ledgerAddress:d,lpTokenAccount:p,lowVersionKeys:y,rewardTokenAccountsPublicKeys:f}=await this._prepareFarmAccounts({mint:a,farmInfo:i}),b=Buffer.alloc(it.span);it.encode({instruction:ar(u),amount:S(r)},b);let w=u===6?[s({pubkey:ut,isWritable:!1}),s({pubkey:i.id}),s({pubkey:i.authority,isWritable:!1}),s({pubkey:i.lpVault.mint}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:p})]:y;if(u!==3)for(let g=1;g<c.length;g++)w.push(s({pubkey:f[g]})),w.push(s({pubkey:c[g].rewardVault}));let L=new ct({programId:i.programId,keys:w,data:b});return await m.addInstruction({instructions:[L]}).build()}async withdrawFarmReward({farmId:t,withdrawMint:n}){var y;this.scope.checkOwner();let r=this.getParsedFarm(t),{version:i}=r;i!==6&&this.logAndCreateError("invalid farm version",r.version);let a=r.rewardInfos.find(f=>f.rewardMint.equals(n.equals(U)?new Z(Y.mint):n));a||this.logAndCreateError("withdraw mint error","rewardInfos",r);let u=(y=a==null?void 0:a.rewardVault)!=null?y:U,c=this.createTxBuilder(),m;if(this._getUserRewardInfo({payer:this.scope.ownerPubKey,rewardInfo:a}),n.equals(U)){let f=await _e({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:To(a)});m=f.signers[0].publicKey,c.addInstruction(f)}else{let f=await this.scope.account.getCreatedTokenAccount({mint:n});f===null?(m=await this.scope.account.getAssociatedTokenAccount(n),c.addInstruction({instructions:[bs(this.scope.ownerPubKey,m,this.scope.ownerPubKey,n)]})):m=f}let d=Buffer.alloc(bo.span);bo.encode({instruction:5},d);let p=[s({pubkey:ut,isWritable:!1}),s({pubkey:r.id}),s({pubkey:r.authority,isWritable:!1}),s({pubkey:r.lpVault.mint,isWritable:!1}),s({pubkey:u}),s({pubkey:m}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await c.addInstruction({instructions:[new ct({programId:r.programId,keys:p,data:d})]}).build()}};import{ComputeBudgetProgram as Us}from"@solana/web3.js";import Ae from"bn.js";import{PublicKey as hr}from"@solana/web3.js";import wr from"bn.js";var kr=(c=>(c[c.Uninitialized=0]="Uninitialized",c[c.Initialized=1]="Initialized",c[c.Disabled=2]="Disabled",c[c.RemoveLiquidityOnly=3]="RemoveLiquidityOnly",c[c.LiquidityOnly=4]="LiquidityOnly",c[c.OrderBook=5]="OrderBook",c[c.Swap=6]="Swap",c[c.WaitingForStart=7]="WaitingForStart",c))(kr||{}),Tr=new wr(25),Ar=new wr(1e4),Ir="675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",hs=new hr(Ir),xr="5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h",ws=new hr(xr),sp={[Ir]:4,[xr]:5},Sr={4:hs,5:ws},Lr={4:3,5:3};import{TOKEN_PROGRAM_ID as Ko}from"@solana/spl-token";import{SystemProgram as qs,TransactionInstruction as Te}from"@solana/web3.js";var Io=R([v("instruction"),l("amountIn"),l("minAmountOut")]),xo=R([v("instruction"),l("maxAmountIn"),l("amountOut")]),So=R([v("instruction"),v("nonce")]),Lo=R([v("instruction"),v("nonce"),l("startTime")]),_o=R([l("status"),l("nonce"),l("maxOrder"),l("depth"),l("baseDecimal"),l("quoteDecimal"),l("state"),l("resetFlag"),l("minSize"),l("volMaxCutRatio"),l("amountWaveRatio"),l("baseLotSize"),l("quoteLotSize"),l("minPriceMultiplier"),l("maxPriceMultiplier"),l("systemDecimalValue"),l("minSeparateNumerator"),l("minSeparateDenominator"),l("tradeFeeNumerator"),l("tradeFeeDenominator"),l("pnlNumerator"),l("pnlDenominator"),l("swapFeeNumerator"),l("swapFeeDenominator"),l("baseNeedTakePnl"),l("quoteNeedTakePnl"),l("quoteTotalPnl"),l("baseTotalPnl"),Q("quoteTotalDeposited"),Q("baseTotalDeposited"),Q("swapBaseInAmount"),Q("swapQuoteOutAmount"),l("swapBase2QuoteFee"),Q("swapQuoteInAmount"),Q("swapBaseOutAmount"),l("swapQuote2BaseFee"),k("baseVault"),k("quoteVault"),k("baseMint"),k("quoteMint"),k("lpMint"),k("openOrders"),k("marketId"),k("marketProgramId"),k("targetOrders"),k("withdrawQueue"),k("lpVault"),k("owner"),l("lpReserve"),H(l(),3,"padding")]),ks=R([l("accountType"),l("status"),l("nonce"),l("maxOrder"),l("depth"),l("baseDecimal"),l("quoteDecimal"),l("state"),l("resetFlag"),l("minSize"),l("volMaxCutRatio"),l("amountWaveRatio"),l("baseLotSize"),l("quoteLotSize"),l("minPriceMultiplier"),l("maxPriceMultiplier"),l("systemDecimalsValue"),l("abortTradeFactor"),l("priceTickMultiplier"),l("priceTick"),l("minSeparateNumerator"),l("minSeparateDenominator"),l("tradeFeeNumerator"),l("tradeFeeDenominator"),l("pnlNumerator"),l("pnlDenominator"),l("swapFeeNumerator"),l("swapFeeDenominator"),l("baseNeedTakePnl"),l("quoteNeedTakePnl"),l("quoteTotalPnl"),l("baseTotalPnl"),l("poolOpenTime"),l("punishPcAmount"),l("punishCoinAmount"),l("orderbookToInitTime"),Q("swapBaseInAmount"),Q("swapQuoteOutAmount"),Q("swapQuoteInAmount"),Q("swapBaseOutAmount"),l("swapQuote2BaseFee"),l("swapBase2QuoteFee"),k("baseVault"),k("quoteVault"),k("baseMint"),k("quoteMint"),k("lpMint"),k("modelDataAccount"),k("openOrders"),k("marketId"),k("marketProgramId"),k("targetOrders"),k("owner"),H(l(),64,"padding")]),Ro=R([v("instruction"),l("baseAmountIn"),l("quoteAmountIn"),l("fixedSide")]),Mo=R([v("instruction"),l("amountIn")]),_r={4:_o,5:ks};import{PublicKey as Ts}from"@solana/web3.js";var ke=new Ts("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),ve=5e4,As=R([l("x"),l("y"),l("price")]),Is=R([l("accountType"),l("status"),l("multiplier"),l("validDataCount"),H(As,ve,"DataElement")]);function xs(o,e){return[0,ve-2]}function Ss(o){return[0,ve-2]}function Ls(o){return[0,ve-2]}function _s(o,e,t){let[n,r]=xs(e,t),i=n,a=r,u=0,c=e*o.multiplier/t;for(;i<=a;){if(u=Math.floor((a+i)/2),u===0||u>=ve-2)return[u,u,!1];let m=o.DataElement[u].x*o.multiplier/o.DataElement[u].y,d=o.DataElement[u-1].x*o.multiplier/o.DataElement[u-1].y,p=o.DataElement[u+1].x*o.multiplier/o.DataElement[u+1].y;if(c===m)return[u,u,!0];if(c===d)return[u-1,u-1,!0];if(c===p)return[u+1,u+1,!0];if(c<d)a=u-1;else{if(c>d&&c<m)return[u-1,u,!0];if(c>m&&c<p)return[u,u+1,!0];i=u+1}}return[u,u,!1]}function Bo(o,e,t){let[n,r,i]=_s(o,e,t);if(!i)return 0;if(n===r){let a=o.DataElement[n].x;return e*o.multiplier/a}else{let a=o.DataElement[n].x,u=o.DataElement[n].y,c=o.DataElement[r].x,m=o.DataElement[r].y,d=t*(c*u-a*m),p=a*d,y=(c-a)*(e*u-a*t)*m,f=p+y;return e*o.multiplier*d/f}}function Ne(o,e,t){return e*o.multiplier/t}function Rr(o,e,t){return e*t/o.multiplier}function Rs(o,e){let[t,n]=Ss(e),r=t,i=n,a=0,u=e;for(;r<i;){if(a=Math.floor((i+r)/2),a<=0||a>ve-2)return[a,a,!1];let c=o.DataElement[a].x,m=o.DataElement[a-1].x,d=o.DataElement[a+1].x;if(u===c)return[a,a,!0];if(u===m)return[a-1,a-1,!0];if(u===d)return[a+1,a+1,!0];if(u<m)i=a-1;else{if(u>m&&u<c)return[a-1,a,!0];if(u>c&&u<d)return[a,a+1,!0];r=a+1}}return[a,a,!1]}function Ms(o,e){let[t,n]=Ls(e),r=t,i=n,a=0,u=e;for(;r<=i;){if(a=Math.floor((i+r)/2),a<=0||a>=ve-2)return[a,a,!1];let c=o.DataElement[a].y,m=o.DataElement[a-1].y,d=o.DataElement[a+1].y;if(u===c)return[a,a,!0];if(u===m)return[a-1,a-1,!0];if(u===d)return[a+1,a+1,!0];if(u<d)r=a+1;else{if(u<m&&u>c)return[a-1,a,!0];if(u<c&&u>d)return[a,a+1,!0];i=a-1}}return[a,a,!1]}function Mr(o,e,t,n){let r=n?e+t:e-t,[i,a,u]=Rs(o,r);if(!u)return[0,0,!1,u];if(i===a)return[o.DataElement[a].price,o.DataElement[a].y,!1,u];{let c=o.DataElement[i].x,m=o.DataElement[a].x,d=o.DataElement[i].price,p=o.DataElement[a].price,y=o.DataElement[i].y,f=o.DataElement[a].y;if(e>=c&&e<=m)return n?[p,f,!0,u]:[d,y,!0,u];{let b,w;return n?(b=d+(p-d)*(e-c)/(m-c),w=y-(r-c)*o.multiplier/p):(b=d+(p-d)*(e-c)/(m-c),w=f+(m-r)*o.multiplier/d),[b,w,!1,u]}}}function Bs(o,e,t,n){let r=n?e-t:e+t,[i,a,u]=Ms(o,r);if(!u)return[0,0,!1,u];if(i===a)return[o.DataElement[a].price,o.DataElement[a].x,!1,u];{let c=o.DataElement[i].x,m=o.DataElement[a].x,d=o.DataElement[i].price,p=o.DataElement[a].price,y=o.DataElement[i].y,f=o.DataElement[a].y;if(e>=f&&e<=y)return n?[p,m,!0,u]:[d,c,!0,u];{let b,w;return n?(b=d+(p-d)*(y-e)/(y-f),w=c+p*(y-r)/o.multiplier):(b=d+(p-d)*(y-e)/(y-f),w=m-d*(r-f)/o.multiplier),[b,w,!1,u]}}}function Ks(o,e){let t=Mr(o,e,0,!1);return t[3]?t[0]:0}function Br(o,e,t,n){let r=Bo(o,e,t),i=Ne(o,e,r),a=Ne(o,t,r),u=Ne(o,n,r),c=!0,[m,d,p,y]=Mr(o,i,u,c);if(!y)return 0;if(p)return n*o.multiplier/m;{let f=a-d;return Rr(o,f,r)}}function Kr(o,e,t,n){let r=Bo(o,e,t),i=Ne(o,e,r),a=Ne(o,t,r),u=Ne(o,n,r),c=!1,[m,d,p,y]=Bs(o,a,u,c);if(!y)return 0;if(p)return n*m/o.multiplier;{let f=i-d;return Rr(o,f,r)}}function Os(o){let e=Is.decode(o);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function Or(o,e,t,n){let r=Ks(o,Ne(o,e,Bo(o,e,t)))/o.multiplier;return n?r:1/r}var vt=class{constructor({connection:e}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(ke);e&&(this._layoutData=Os(e==null?void 0:e.data))}}};var Dt=M("Raydium_liquidity_instruction");function qr(o){let{poolKeys:e,userKeys:t,amountIn:n,amountOut:r,fixedSide:i}=o,{version:a}=e;if(a===4||a===5){let u={poolKeys:e,userKeys:t};if(i==="in")return Fs(K(x({},u),{amountIn:n,minAmountOut:r}),a);if(i==="out")return Ns(K(x({},u),{maxAmountIn:n,amountOut:r}),a);Dt.logWithError("invalid params","params",o)}throw Dt.logWithError("invalid version","poolKeys.version",a),new Error("invalid version")}function Fr(o){let e=R([v("instruction"),v("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let n=[s({pubkey:o.id,isWritable:!1}),s({pubkey:o.authority,isWritable:!1}),s({pubkey:o.openOrders,isWritable:!1}),s({pubkey:o.baseVault,isWritable:!1}),s({pubkey:o.quoteVault,isWritable:!1}),s({pubkey:o.lpMint,isWritable:!1}),s({pubkey:o.marketId,isWritable:!1})];return new Te({programId:o.programId,keys:n,data:t})}function Fs({poolKeys:o,userKeys:e,amountIn:t,minAmountOut:n},r){let i=Buffer.alloc(Io.span);Io.encode({instruction:9,amountIn:S(t),minAmountOut:S(n)},i);let a=[s({pubkey:Ko,isWritable:!1}),s({pubkey:o.id}),s({pubkey:o.authority,isWritable:!1}),s({pubkey:o.openOrders})];return r===4&&a.push(s({pubkey:o.targetOrders})),a.push(s({pubkey:o.baseVault}),s({pubkey:o.quoteVault})),r===5&&a.push(s({pubkey:ke})),a.push(s({pubkey:o.marketProgramId,isWritable:!1}),s({pubkey:o.marketId}),s({pubkey:o.marketBids}),s({pubkey:o.marketAsks}),s({pubkey:o.marketEventQueue}),s({pubkey:o.marketBaseVault}),s({pubkey:o.marketQuoteVault}),s({pubkey:o.marketAuthority,isWritable:!1}),s({pubkey:e.tokenAccountIn}),s({pubkey:e.tokenAccountOut}),s({pubkey:e.owner,isWritable:!1})),new Te({programId:o.programId,keys:a,data:i})}function Ns({poolKeys:o,userKeys:e,maxAmountIn:t,amountOut:n},r){let i=Buffer.alloc(xo.span);xo.encode({instruction:11,maxAmountIn:S(t),amountOut:S(n)},i);let a=[s({pubkey:qs.programId,isWritable:!1}),s({pubkey:o.id}),s({pubkey:o.authority,isWritable:!1}),s({pubkey:o.openOrders}),s({pubkey:o.targetOrders}),s({pubkey:o.baseVault}),s({pubkey:o.quoteVault})];return r===5&&a.push(s({pubkey:ke})),a.push(s({pubkey:o.marketProgramId,isWritable:!1}),s({pubkey:o.marketId}),s({pubkey:o.marketBids}),s({pubkey:o.marketAsks}),s({pubkey:o.marketEventQueue}),s({pubkey:o.marketBaseVault}),s({pubkey:o.marketQuoteVault}),s({pubkey:o.marketAuthority,isWritable:!1}),s({pubkey:e.tokenAccountIn}),s({pubkey:e.tokenAccountOut}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Te({programId:o.programId,keys:a,data:i})}function Nr(o){let i=o,{owner:e}=i,t=ee(i,["owner"]),n=Buffer.alloc(So.span);So.encode({instruction:10,nonce:t.nonce},n);let r=[...Oe,s({pubkey:t.targetOrders}),s({pubkey:t.withdrawQueue}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.lpMint}),s({pubkey:t.baseMint,isWritable:!1}),s({pubkey:t.quoteMint,isWritable:!1}),s({pubkey:t.baseVault}),s({pubkey:t.quoteVault}),s({pubkey:t.lpVault}),s({pubkey:t.marketId,isWritable:!1}),s({pubkey:e,isSigner:!0})];return new Te({programId:t.programId,keys:r,data:n})}function vr(o){let{poolKeys:e,userKeys:t,startTime:n}=o,r=Buffer.alloc(Lo.span);Lo.encode({instruction:0,nonce:e.nonce,startTime:S(n)},r);let i=[...Oe,s({pubkey:e.id}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.openOrders}),s({pubkey:e.lpMint}),s({pubkey:e.baseMint,isWritable:!1}),s({pubkey:e.quoteMint,isWritable:!1}),s({pubkey:e.baseVault,isWritable:!1}),s({pubkey:e.quoteVault,isWritable:!1}),s({pubkey:e.withdrawQueue}),s({pubkey:e.targetOrders}),s({pubkey:t.lpTokenAccount}),s({pubkey:e.lpVault,isWritable:!1}),s({pubkey:e.marketProgramId,isWritable:!1}),s({pubkey:e.marketId,isWritable:!1}),s({pubkey:t.payer,isSigner:!0})];return new Te({programId:e.programId,keys:i,data:r})}function Dr(o){let{poolKeys:e,userKeys:t,baseAmountIn:n,quoteAmountIn:r,fixedSide:i}=o,{version:a}=e;if(a===4||a===5){let u=Buffer.alloc(Ro.span);Ro.encode({instruction:3,baseAmountIn:S(n),quoteAmountIn:S(r),fixedSide:S(i==="base"?0:1)},u);let c=[s({pubkey:Ko,isWritable:!1}),s({pubkey:e.id}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.openOrders,isWritable:!1}),s({pubkey:e.targetOrders}),s({pubkey:e.lpMint}),s({pubkey:e.baseVault}),s({pubkey:e.quoteVault})];return a===5&&c.push(s({pubkey:ke})),c.push(s({pubkey:e.marketId,isWritable:!1}),s({pubkey:t.baseTokenAccount}),s({pubkey:t.quoteTokenAccount}),s({pubkey:t.lpTokenAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})),new Te({programId:e.programId,keys:c,data:u})}return Dt.logWithError("invalid version","poolKeys.version",a),new Te({programId:e.programId,keys:[]})}function Er(o){let{poolKeys:e,userKeys:t,amountIn:n}=o,{version:r}=e;if(r===4||r===5){let i=Buffer.alloc(Mo.span);Mo.encode({instruction:4,amountIn:S(n)},i);let a=[s({pubkey:Ko,isWritable:!1}),s({pubkey:e.id}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.openOrders}),s({pubkey:e.targetOrders}),s({pubkey:e.lpMint}),s({pubkey:e.baseVault}),s({pubkey:e.quoteVault})];return r===5?a.push(s({pubkey:ke})):a.push(s({pubkey:e.withdrawQueue}),s({pubkey:e.lpVault})),a.push(s({pubkey:e.marketProgramId,isWritable:!1}),s({pubkey:e.marketId}),s({pubkey:e.marketBaseVault}),s({pubkey:e.marketQuoteVault}),s({pubkey:e.marketAuthority,isWritable:!1}),s({pubkey:t.lpTokenAccount}),s({pubkey:t.baseTokenAccount}),s({pubkey:t.quoteTokenAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0}),s({pubkey:e.marketEventQueue}),s({pubkey:e.marketBids}),s({pubkey:e.marketAsks})),new Te({programId:e.programId,keys:a,data:i})}return Dt.logWithError("invalid version","poolKeys.version",r),new Te({programId:e.programId,keys:[]})}import{OpenOrders as Es}from"@project-serum/serum";import lt from"bn.js";import{PublicKey as Vr}from"@solana/web3.js";var Oo=M("Raydium_liquidity_serum"),Cr="9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin",vs=new Vr(Cr),Rp={[Cr]:3},Ds={3:vs};function Wr(o){let e=Lr[o];return e||Oo.logWithError("invalid version","version",o),e}function Ur(o){let e=Ds[o];return e||Oo.logWithError("invalid version","version",o),e}async function Gr({programId:o,marketId:e}){let t=[e.toBuffer()],n=0,r;for(;n<100;){try{let i=t.concat(Buffer.from([n]),Buffer.alloc(7));r=await Vr.createProgramAddress(i,o)}catch(i){if(i instanceof TypeError)throw i;n++;continue}return{publicKey:r,nonce:n}}throw Oo.logWithError("unable to find a viable program address nonce","params",{programId:o,marketId:e}),new Error("unable to find a viable program address nonce")}var Et=M("Raydium_liquidity_util");function qo(o,e){let t=o instanceof O?o.token:C.WSOL,{baseMint:n,quoteMint:r}=e;if(t.mint.equals(n))return"base";if(t.mint.equals(r))return"quote";let i=`liquidity getTokenSide - token not match with pool, params: ${JSON.stringify({token:t.mint,baseMint:n,quoteMint:r})}`;throw console.error(i),new Error(i)}function Ge(o,e){let{baseMint:t,quoteMint:n}=e;return o.mint.equals(t)||o.mint.equals(n)}function Fo(o){let{status:e,startTime:t}=o,n=e.toNumber();return{[0]:{swap:!1,addLiquidity:!1,removeLiquidity:!1},[1]:{swap:!0,addLiquidity:!0,removeLiquidity:!0},[2]:{swap:!1,addLiquidity:!1,removeLiquidity:!1},[3]:{swap:!1,addLiquidity:!1,removeLiquidity:!0},[4]:{swap:!1,addLiquidity:!0,removeLiquidity:!0},[5]:{swap:!1,addLiquidity:!0,removeLiquidity:!0},[6]:{swap:!0,addLiquidity:!0,removeLiquidity:!0},[7]:{swap:Date.now()/1e3>=t.toNumber(),addLiquidity:!0,removeLiquidity:!0}}[n]||{swap:!1,addLiquidity:!1,removeLiquidity:!1}}function Up(o){let e=_r[o];return e||Et.logWithError("invalid version","version",o),e}function Vs(o){let e=Sr[o];return e||Et.logWithError("invalid version","version",o),e}async function Re({name:o,programId:e,marketId:t}){let{publicKey:n}=await Pe([e.toBuffer(),t.toBuffer(),Buffer.from(o,"utf-8")],e);return n}async function Cs({programId:o}){return Pe([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],o)}async function No({version:o,marketId:e,baseMint:t,quoteMint:n}){let r=Vs(o),[i,a,u]=[E({publicKey:e}),E({publicKey:t,transformSol:!0}),E({publicKey:n,transformSol:!0})],c=await Re({name:"amm_associated_seed",programId:r,marketId:i}),m=await Re({name:"lp_mint_associated_seed",programId:r,marketId:i}),{publicKey:d,nonce:p}=await Cs({programId:r}),y=await Re({name:"coin_vault_associated_seed",programId:r,marketId:i}),f=await Re({name:"pc_vault_associated_seed",programId:r,marketId:i}),b=await Re({name:"temp_lp_token_associated_seed",programId:r,marketId:i}),w=await Re({name:"open_order_associated_seed",programId:r,marketId:i}),L=await Re({name:"target_associated_seed",programId:r,marketId:i}),g=await Re({name:"withdraw_associated_seed",programId:r,marketId:i}),T=Wr(o),_=Ur(T),{publicKey:A}=await Gr({programId:_,marketId:i});return{id:c,baseMint:a,quoteMint:u,lpMint:m,version:o,programId:r,authority:d,nonce:p,baseVault:y,quoteVault:f,lpVault:b,openOrders:w,targetOrders:L,withdrawQueue:g,marketVersion:T,marketProgramId:_,marketId:i,marketAuthority:A}}async function $r({connection:o,pools:e}){let t=e.map(r=>Fr(r));return(await An(o,t,"GetPoolData")).map(r=>{let i=In(r,"GetPoolData"),a=new lt(ge(i,"status")),u=Number(ge(i,"coin_decimals")),c=Number(ge(i,"pc_decimals")),m=Number(ge(i,"lp_decimals")),d=new lt(ge(i,"pool_coin_amount")),p=new lt(ge(i,"pool_pc_amount")),y=new lt(ge(i,"pool_lp_supply")),f="0";try{f=ge(i,"pool_open_time")}catch{f="0"}return{status:a,baseDecimals:u,quoteDecimals:c,lpDecimals:m,baseReserve:d,quoteReserve:p,lpSupply:y,startTime:new lt(f)}})}function jr(o,e,t){return Ws(o.token,e.token,t)}function Ws(o,e,t){let{baseMint:n,quoteMint:r}=t,i=Jr(o,t),a=Jr(e,t);return i===a&&Et.logWithError("tokens not match with pool","params",{tokenA:o.mint,tokenB:e.mint,baseMint:n,quoteMint:r}),[i,a]}function Jr(o,e){let{baseMint:t,quoteMint:n}=e;return o.mint.equals(t)?"base":o.mint.equals(n)?"quote":(Et.logWithError("token not match with pool","params",{token:o.mint,baseMint:t,quoteMint:n}),"base")}var Yr=o=>o==="a"||o==="b";async function Gp(o,e,t){let n=await o.getAccountInfo(e);if(n===null)return null;let r=_o.decode(n.data),i=await o.getTokenAccountBalance(r.baseVault),a=await o.getTokenAccountBalance(r.quoteVault),u=await Es.load(o,r.openOrders,t),c=10**r.baseDecimal.toNumber(),m=10**r.quoteDecimal.toNumber(),d=u.baseTokenTotal.toNumber()/c,p=u.quoteTokenTotal.toNumber()/m,y=r.baseNeedTakePnl.toNumber()/c,f=r.quoteNeedTakePnl.toNumber()/m,b=i.value.uiAmount+d-y,w=a.value.uiAmount+p-f,L=parseFloat(r.lpReserve.toString()),g=b/w;return{baseAmount:b,quoteAmount:w,lpSupply:L,baseVaultKey:r.baseVault,quoteVaultKey:r.quoteVault,baseVaultBalance:i.value.uiAmount,quoteVaultBalance:a.value.uiAmount,openOrdersKey:r.openOrders,openOrdersTotalBase:d,openOrdersTotalQuote:p,basePnl:y,quotePnl:f,priceInQuote:g}}var dt=class extends ie{constructor(t){super(t);this._poolInfos=[];this._poolInfoMap=new Map;this._pairsInfo=[];this._pairsInfoMap=new Map;this._lpTokenMap=new Map;this._lpPriceMap=new Map;this._officialIds=new Set;this._unOfficialIds=new Set;this._sdkParseInfoCache=new Map;this._stableLayout=new vt({connection:this.scope.connection})}async load(t){if(await this.scope.fetchLiquidity(t==null?void 0:t.forceUpdate),!this.scope.apiData.liquidityPools)return;let{data:n}=this.scope.apiData.liquidityPools,[r,i]=[n.official||[],n.unOfficial||[]];this._poolInfos=[...r,...i],this._officialIds=new Set(r.map(a=>{var c,m;let u=`${(c=this.scope.token.allTokenMap.get(a.baseMint))==null?void 0:c.symbol} - ${(m=this.scope.token.allTokenMap.get(a.quoteMint))==null?void 0:m.symbol}`;return this._poolInfoMap.set(a.id,a),this._lpTokenMap.set(a.lpMint,new C({mint:a.lpMint,decimals:a.lpDecimals,symbol:u,name:`${u} LP`})),a.id})),this._unOfficialIds=new Set(i.map(a=>{var c,m;let u=`${(c=this.scope.token.allTokenMap.get(a.baseMint))==null?void 0:c.symbol} - ${(m=this.scope.token.allTokenMap.get(a.quoteMint))==null?void 0:m.symbol}`;return this._poolInfoMap.set(a.id,a),this._lpTokenMap.set(a.lpMint,new C({mint:a.lpMint,decimals:a.lpDecimals,symbol:u,name:`${u} LP`})),a.id}))}async loadPairs(t){var n;return await this.scope.fetchPairs(t==null?void 0:t.forceUpdate),this._pairsInfo=((n=this.scope.apiData.liquidityPairsInfo)==null?void 0:n.data)||[],this._pairsInfoMap=new Map(this._pairsInfo.map(r=>{let i=this._lpTokenMap.get(r.lpMint),a=i&&r.lpPrice?Qe({token:i,numberPrice:r.lpPrice,decimalDone:!0}):null;return a&&this._lpPriceMap.set(r.lpMint,a),[r.ammId,r]})),this._pairsInfo}get allPools(){return this._poolInfos}get allPoolIdSet(){return{official:this._officialIds,unOfficial:this._unOfficialIds}}get allPoolMap(){return this._poolInfoMap}get allPairs(){return this._pairsInfo}get allPairsMap(){return this._pairsInfoMap}get lpTokenMap(){return this._lpTokenMap}get lpPriceMap(){return this._lpPriceMap}async fetchMultipleInfo(t){return await this._stableLayout.initStableModelLayout(),await $r(K(x({},t),{connection:this.scope.connection}))}async sdkParseJsonLiquidityInfo(t){if(!t.length)return[];let n=t.map(r=>r.id).join("-");if(this._sdkParseInfoCache.has(n))return this._sdkParseInfoCache.get(n);try{let i=(await this.fetchMultipleInfo({pools:t.map(me)})).map((a,u)=>x(x({jsonInfo:t[u]},me(t[u])),a));return this._sdkParseInfoCache.set(n,i),i}catch(r){return console.error(r),[]}}computeAmountOut({poolKeys:t,poolInfo:n,amountIn:r,outputToken:i,slippage:a}){this.checkDisabled();let u=M("Raydium_computeAmountOut"),c=r.token,m=i;(!Ge(c,t)||!Ge(m,t))&&u.logWithError("token not match with pool","poolKeys",t);let{baseReserve:d,quoteReserve:p}=n;this.logDebug("baseReserve:",d.toString(),"quoteReserve:",p.toString());let y=r.token;this.logDebug("inputToken:",y),this.logDebug("amountIn:",r.toFixed()),this.logDebug("outputToken:",i),this.logDebug("slippage:",`${a.toSignificant()}%`);let f=[d,p],b=qo(r,t);b==="quote"&&f.reverse(),this.logDebug("input side:",b);let[w,L]=f,g;if(t.version===4)g=new j({baseToken:y,denominator:w,quoteToken:i,numerator:L});else{let $=Or(this._stableLayout.stableModelData,d.toNumber(),p.toNumber(),!1);g=new j({baseToken:y,denominator:b==="quote"?new Ae($*1e6):new Ae(1e6),quoteToken:i,numerator:b==="quote"?new Ae(1e6):new Ae($*1e6)})}this.logDebug("currentPrice:",`1 ${y.symbol} \u2248 ${g.toFixed()} ${i.symbol}`),this.logDebug("currentPrice invert:",`1 ${i.symbol} \u2248 ${g.invert().toFixed()} ${y.symbol}`);let T=r.raw,_=ae,A=ae;if(!T.isZero())if(t.version===4){A=T.mul(Tr).div(Ar);let $=T.sub(A),re=w.add($);_=L.mul($).div(re)}else{A=T.mul(new Ae(2)).div(new Ae(1e4));let $=T.sub(A),re=b==="quote"?Br:Kr;_=new Ae(re(this._stableLayout.stableModelData,p.toNumber(),d.toNumber(),$.toNumber()))}let F=new oe(pe).add(a).invert().mul(_).quotient,N=new O(i,_),J=new O(i,F);this.logDebug("amountOut:",N.toFixed(),"minAmountOut:",J.toFixed());let D=new j({baseToken:y,denominator:T.sub(A),quoteToken:i,numerator:_});!T.isZero()&&!_.isZero()&&(D=new j({baseToken:y,denominator:T.sub(A),quoteToken:i,numerator:_}),this.logDebug("executionPrice:",`1 ${y.symbol} \u2248 ${D.toFixed()} ${i.symbol}`),this.logDebug("executionPrice invert:",`1 ${i.symbol} \u2248 ${D.invert().toFixed()} ${y.symbol}`));let G=new oe(parseInt(String(Math.abs(parseFloat(D.toFixed())-parseFloat(g.toFixed()))*1e9)),parseInt(String(parseFloat(g.toFixed())*1e9))),X=new O(y,A);return{amountOut:N,minAmountOut:J,currentPrice:g,executionPrice:D,priceImpact:G,fee:X}}async computePairAmount({poolId:t,amount:n,anotherToken:r,slippage:i}){let a=E({publicKey:t}),u=this._poolInfoMap.get(a.toBase58());u||this.logAndCreateError("pool not found",a.toBase58());let c=(await this.sdkParseJsonLiquidityInfo([u]))[0];c||this.logAndCreateError("pool parseInfo not found",a.toBase58());let{baseReserve:m,quoteReserve:d}=c;this.logDebug("baseReserve:",m.toString(),"quoteReserve:",d.toString());let p=n.token;this.logDebug("tokenIn:",p,"amount:",n.toFixed(),"anotherToken:",r,"slippage:",`${i.toSignificant()}%`);let y=qo(n,me(u));this.logDebug("input side:",y);let f=ae;n.isZero()||(f=y==="base"?zt(n.raw.mul(d),m):zt(n.raw.mul(m),d));let w=new oe(pe).add(i).mul(f).quotient,L=new O(r,f),g=new O(r,w);return this.logDebug("anotherAmount:",L.toFixed(),"maxAnotherAmount:",g.toFixed()),{anotherAmount:L,maxAnotherAmount:g}}async swapWithAMM(t){let{poolKeys:n,payer:r,amountIn:i,amountOut:a,fixedSide:u,config:c}=t;this.logDebug("amountIn:",i),this.logDebug("amountOut:",a),(i.isZero()||a.isZero())&&this.logAndCreateError("amounts must greater than zero","amounts",{amountIn:i.toFixed(),amountOut:a.toFixed()});let{account:m}=this.scope,d=this.createTxBuilder(),{bypassAssociatedCheck:p=!1}=c||{},[y,f]=[i.token,a.token],b=await m.getCreatedTokenAccount({mint:y.mint,associatedOnly:!1}),w=await m.getCreatedTokenAccount({mint:f.mint}),[L,g]=[i.raw,a.raw],F=await m.handleTokenAccount({side:"in",amount:L,mint:y.mint,tokenAccount:b,bypassAssociatedCheck:p}),{tokenAccount:T}=F,_=ee(F,["tokenAccount"]);d.addInstruction(_);let N=await m.handleTokenAccount({side:"out",amount:0,mint:f.mint,tokenAccount:w,payer:r,bypassAssociatedCheck:p}),{tokenAccount:A}=N,q=ee(N,["tokenAccount"]);return d.addInstruction(q),d.addInstruction({instructions:[qr({poolKeys:n,userKeys:{tokenAccountIn:T,tokenAccountOut:A,owner:this.scope.ownerPubKey},amountIn:L,amountOut:g,fixedSide:u})]}),d.buildMultiTx({extInfo:{amountOut:a}})}async createPool(t){this.checkDisabled(),this.scope.checkOwner(),t.version!==4&&this.logAndCreateError("invalid version","poolKeys.version",t.version);let n=this.createTxBuilder(),r=await No(t);return await n.addInstruction({instructions:[Nr(K(x({},r),{owner:this.scope.ownerPubKey}))]}).build()}async initPool(t){t.version!==4&&this.logAndCreateError("invalid version","poolKeys.version",t.version);let{baseAmount:n,quoteAmount:r,startTime:i=0,config:a}=t,u=await No(t),{baseMint:c,quoteMint:m,lpMint:d,baseVault:p,quoteVault:y}=u,f=this.createTxBuilder(),{account:b}=this.scope,w=!!(a!=null&&a.bypassAssociatedCheck),L=await b.getCreatedTokenAccount({mint:c,associatedOnly:!1}),g=await b.getCreatedTokenAccount({mint:m,associatedOnly:!1});!L&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",b.tokenAccounts);let T=await b.getCreatedTokenAccount({mint:d,associatedOnly:!1}),D=await b.handleTokenAccount({side:"in",amount:n.raw,mint:c,tokenAccount:L,bypassAssociatedCheck:w}),{tokenAccount:_}=D,A=ee(D,["tokenAccount"]);f.addInstruction(A);let G=await b.handleTokenAccount({side:"in",amount:r.raw,mint:m,tokenAccount:g,bypassAssociatedCheck:w}),{tokenAccount:q}=G,F=ee(G,["tokenAccount"]);f.addInstruction(F);let X=await b.handleTokenAccount({side:"out",amount:0,mint:d,tokenAccount:T,bypassAssociatedCheck:w}),{tokenAccount:N}=X,J=ee(X,["tokenAccount"]);return f.addInstruction(J),f.addInstruction({instructions:[Ue({source:_,destination:p,owner:this.scope.ownerPubKey,amount:n.raw}),Ue({source:q,destination:y,owner:this.scope.ownerPubKey,amount:r.raw}),vr({poolKeys:u,userKeys:{lpTokenAccount:N,payer:this.scope.ownerPubKey},startTime:i})]}),await f.build()}async addLiquidity(t){let{poolId:n,amountInA:r,amountInB:i,fixedSide:a,config:u}=t,c=E({publicKey:n}),m=this.allPools.find(ht=>ht.id===c.toBase58());m||this.logAndCreateError("pool not found",n);let p=(await this.sdkParseJsonLiquidityInfo([m]))[0];p||this.logAndCreateError("pool parse error",p),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:y}=this.scope,f=(u==null?void 0:u.bypassAssociatedCheck)||!1,[b,w]=[r.token,i.token],L=await y.getCreatedTokenAccount({mint:b.mint,associatedOnly:!1}),g=await y.getCreatedTokenAccount({mint:w.mint,associatedOnly:!1});!L&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",y.tokenAccounts);let T=await y.getCreatedTokenAccount({mint:p.lpMint}),_=[b,w],A=[L,g],q=[r.raw,i.raw],[F]=jr(r,i,p),N="base";(!["quote","base"].includes(F)||!Yr(a))&&this.logAndCreateError("invalid fixedSide","fixedSide",a),F==="quote"?(_.reverse(),A.reverse(),q.reverse(),N=a==="a"?"quote":"base"):F==="base"&&(N=a==="a"?"base":"quote");let[J,D]=_,[G,X]=A,[$,re]=q,se=this.createTxBuilder(),Je=await y.handleTokenAccount({side:"in",amount:$,mint:J.mint,tokenAccount:G,bypassAssociatedCheck:f}),{tokenAccount:Ie}=Je,ce=ee(Je,["tokenAccount"]);se.addInstruction(ce);let $e=await y.handleTokenAccount({side:"in",amount:re,mint:D.mint,tokenAccount:X,bypassAssociatedCheck:f}),{tokenAccount:fe}=$e,de=ee($e,["tokenAccount"]);se.addInstruction(de);let je=await y.handleTokenAccount({side:"out",amount:0,mint:p.lpMint,tokenAccount:T,bypassAssociatedCheck:f}),{tokenAccount:gt}=je,Pt=ee(je,["tokenAccount"]);return se.addInstruction(Pt),se.addInstruction({instructions:[Dr({poolKeys:p,userKeys:{baseTokenAccount:Ie,quoteTokenAccount:fe,lpTokenAccount:gt,owner:this.scope.ownerPubKey},baseAmountIn:$,quoteAmountIn:re,fixedSide:N})]}),await se.build()}async removeLiquidity(t){let{poolId:n,amountIn:r,config:i}=t,a=E({publicKey:n}),u=this.allPools.find(D=>D.id===a.toBase58());u||this.logAndCreateError("pool not found",n);let m=(await this.sdkParseJsonLiquidityInfo([u]))[0];m||this.logAndCreateError("pool pass error",m);let{baseMint:d,quoteMint:p,lpMint:y}=m;this.logDebug("amountIn:",r),r.isZero()&&this.logAndCreateError("amount must greater than zero","amountIn",r.toFixed()),r.token.mint.equals(y)||this.logAndCreateError("amountIn's token not match lpMint","amountIn",r);let{account:f}=this.scope,b=await f.getCreatedTokenAccount({mint:y,associatedOnly:!1});b||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",f.tokenAccounts);let w=await f.getCreatedTokenAccount({mint:d}),L=await f.getCreatedTokenAccount({mint:p}),g=this.createTxBuilder(),T=(i==null?void 0:i.bypassAssociatedCheck)||!1,N=await f.handleTokenAccount({side:"out",amount:0,mint:d,tokenAccount:w,bypassAssociatedCheck:T}),{tokenAccount:_}=N,A=ee(N,["tokenAccount"]);g.addInstruction(A);let J=await f.handleTokenAccount({side:"out",amount:0,mint:p,tokenAccount:L,bypassAssociatedCheck:T}),{tokenAccount:q}=J,F=ee(J,["tokenAccount"]);return g.addInstruction(F),g.addInstruction({instructions:[Us.requestUnits({units:4e5,additionalFee:0}),Er({poolKeys:m,userKeys:{lpTokenAccount:b,baseTokenAccount:_,quoteTokenAccount:q,owner:this.scope.ownerPubKey},amountIn:r.raw})]}),await g.build()}lpMintToTokenAmount({poolId:t,amount:n,decimalDone:r}){let i=E({publicKey:t});i||this.logAndCreateError("pool not found");let a=this._poolInfoMap.get(i.toBase58()),u=ue(n),c=new C({mint:a.lpMint,decimals:a.lpDecimals}),m=r?new I(u.numerator,u.denominator):new I(u.numerator,u.denominator).mul(new Ae(10).pow(new Ae(c.decimals)));return new O(c,xe(m))}getFixedSide({poolId:t,inputMint:n}){let[r,i]=[E({publicKey:t}),E({publicKey:n})],a=this._poolInfoMap.get(r.toBase58());a||this.logAndCreateError("pool not found",r.toBase58());let u=a.baseMint===i.toBase58();return(i.equals(Se)||i.equals(U))&&(u=!u),u?"a":"b"}};import{PublicKey as ti}from"@solana/web3.js";import{intersection as oi,xor as Qs}from"lodash";import{PublicKey as Gs}from"@solana/web3.js";var Js="routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS",pt=new Gs(Js),Qr=["amm","serum","route"],Hr=[dn,_t,Se,fn,ln,yn,bn,pn,gn].map(o=>o.toBase58());import{TOKEN_PROGRAM_ID as Wt}from"@solana/spl-token";import{SystemProgram as zr,TransactionInstruction as Zr}from"@solana/web3.js";var Vt=R([v("instruction"),l("amountIn"),l("amountOut")]),Ct=R([v("instruction")]);var $s=M("Raydium_route_instruction");function Xr(o){let{fixedSide:e}=o;if(e==="in")return[js(o),Ys(o)];throw $s.logWithError("invalid params","params",o),new Error(`invalid params, params: ${o}`)}function js({fromPoolKeys:o,toPoolKeys:e,userKeys:t,amountIn:n,amountOut:r}){let i=Buffer.alloc(Vt.span),a;return o.version===4?(Vt.encode({instruction:0,amountIn:S(n),amountOut:S(r)},i),a=[s({pubkey:zr.programId,isWritable:!1}),s({pubkey:Wt,isWritable:!1}),s({pubkey:o.programId,isWritable:!1}),s({pubkey:o.id}),s({pubkey:e.id,isWritable:!1}),s({pubkey:o.authority,isWritable:!1}),s({pubkey:o.openOrders}),s({pubkey:o.baseVault}),s({pubkey:o.quoteVault}),s({pubkey:o.marketProgramId,isWritable:!1}),s({pubkey:o.marketId}),s({pubkey:o.marketBids}),s({pubkey:o.marketAsks}),s({pubkey:o.marketEventQueue}),s({pubkey:o.marketBaseVault}),s({pubkey:o.marketQuoteVault}),s({pubkey:o.marketAuthority,isWritable:!1}),s({pubkey:t.inTokenAccount}),s({pubkey:t.middleTokenAccount}),s({pubkey:t.middleStatusAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})]):(Vt.encode({instruction:2,amountIn:S(n),amountOut:S(r)},i),a=[s({pubkey:zr.programId,isWritable:!1}),s({pubkey:Wt,isWritable:!1}),s({pubkey:o.programId,isWritable:!1}),s({pubkey:o.id}),s({pubkey:e.id,isWritable:!1}),s({pubkey:o.authority,isWritable:!1}),s({pubkey:o.openOrders}),s({pubkey:o.baseVault}),s({pubkey:o.quoteVault}),s({pubkey:ke,isWritable:!1}),s({pubkey:o.marketProgramId,isWritable:!1}),s({pubkey:o.marketId}),s({pubkey:o.marketBids}),s({pubkey:o.marketAsks}),s({pubkey:o.marketEventQueue}),s({pubkey:o.id}),s({pubkey:o.id}),s({pubkey:o.id}),s({pubkey:t.inTokenAccount}),s({pubkey:t.middleTokenAccount}),s({pubkey:t.middleStatusAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})]),new Zr({programId:pt,keys:a,data:i})}function Ys({fromPoolKeys:o,toPoolKeys:e,userKeys:t}){let n=Buffer.alloc(Ct.span),r;return e.version===4?(Ct.encode({instruction:1},n),r=[s({pubkey:Wt,isWritable:!1}),s({pubkey:e.programId,isWritable:!1}),s({pubkey:o.id,isWritable:!1}),s({pubkey:e.id}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.openOrders}),s({pubkey:e.baseVault}),s({pubkey:e.quoteVault}),s({pubkey:e.marketProgramId,isWritable:!1}),s({pubkey:e.marketId}),s({pubkey:e.marketBids}),s({pubkey:e.marketAsks}),s({pubkey:e.marketEventQueue}),s({pubkey:e.marketBaseVault}),s({pubkey:e.marketQuoteVault}),s({pubkey:e.marketAuthority,isWritable:!1}),s({pubkey:t.middleTokenAccount}),s({pubkey:t.outTokenAccount}),s({pubkey:t.middleStatusAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})]):(Ct.encode({instruction:3},n),r=[s({pubkey:Wt,isWritable:!1}),s({pubkey:e.programId,isWritable:!1}),s({pubkey:o.id,isWritable:!1}),s({pubkey:e.id}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.openOrders}),s({pubkey:e.baseVault}),s({pubkey:e.quoteVault}),s({pubkey:ke,isWritable:!1}),s({pubkey:e.marketProgramId,isWritable:!1}),s({pubkey:e.marketId}),s({pubkey:e.marketBids}),s({pubkey:e.marketAsks}),s({pubkey:e.marketEventQueue}),s({pubkey:e.id}),s({pubkey:e.id}),s({pubkey:e.id}),s({pubkey:t.middleTokenAccount}),s({pubkey:t.outTokenAccount}),s({pubkey:t.middleStatusAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})]),new Zr({programId:pt,keys:r,data:n})}async function ei({programId:o,fromPoolId:e,middleMint:t,owner:n}){let{publicKey:r}=await Pe([e.toBuffer(),t.toBuffer(),n.toBuffer()],o);return r}var ft=class extends ie{constructor(e){super(e)}computeRouteAmountOut({fromPoolKeys:e,toPoolKeys:t,fromPoolInfo:n,toPoolInfo:r,amountIn:i,outputToken:a,slippage:u}){let{swap:c}=Fo(n),{swap:m}=Fo(r);(!c||!m)&&this.logAndCreateError("pools swap not enabled","pools",{fromPoolKeys:e,toPoolKeys:t,fromPoolInfo:n,toPoolInfo:r});let d=i.token,p=a;(!Ge(d,e)||!Ge(p,t))&&this.logAndCreateError("pools cannot be routed","pools",{fromPoolKeys:e,toPoolKeys:t});let y=[e.baseMint.toBase58(),e.quoteMint.toBase58()],f=[t.baseMint.toBase58(),t.quoteMint.toBase58()],b=[...y,...f],w=[n.baseDecimals,n.quoteDecimals,r.baseDecimals,r.quoteDecimals],[L,g]=[d.mint.toBase58(),p.mint.toBase58()],T=Qs(y,f);(T.length!==2||!T.includes(L)||!T.includes(g))&&this.logAndCreateError("xor tokens not match","pools",{fromPoolKeys:e,toPoolKeys:t});let _=oi(y,f);_.length!==1&&this.logAndCreateError("cannot found middle token of two pools","pools",{fromPoolKeys:e,toPoolKeys:t});let A=_[0],q=b.indexOf(A);q===-1&&this.logAndCreateError("cannot found middle token","pools",{fromPoolKeys:e,toPoolKeys:t});let F=w[q],N=new ti(A),J=new C({mint:N,decimals:F});this.logInfo("from pool:",e),this.logInfo("to pool:",t),this.logInfo("intersection mints:",_),this.logInfo("xor mints:",T),this.logInfo("middleMint:",A);let{minAmountOut:D,priceImpact:G,fee:X}=this.scope.liquidity.computeAmountOut({poolKeys:e,poolInfo:n,amountIn:i,outputToken:J,slippage:u}),{amountOut:$,minAmountOut:re,priceImpact:se,fee:Ie}=this.scope.liquidity.computeAmountOut({poolKeys:t,poolInfo:r,amountIn:D,outputToken:a,slippage:u}),ce=null,[fe,de]=[i.raw,$.raw];return!fe.isZero()&&!de.isZero()&&(ce=new j({baseToken:d,denominator:fe,quoteToken:a,numerator:de}),this.logDebug("executionPrice:",`1 ${d.symbol} \u2248 ${ce.toFixed()} ${a.symbol}`),this.logDebug("executionPrice invert:",`1 ${a.symbol} \u2248 ${ce.invert().toFixed()} ${d.symbol}`)),{amountOut:$,minAmountOut:re,executionPrice:ce,priceImpact:G.add(se),fee:[X,Ie]}}async swapWithRoute(e){let{fromPoolKeys:t,toPoolKeys:n,amountIn:r,amountOut:i,fixedSide:a,config:u}=e;this.logDebug("amountIn:",r,"amountOut:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amounts",{amountIn:r.toFixed(),amountOut:i.toFixed()});let{account:c}=this.scope,{bypassAssociatedCheck:m=!1}=u||{},[d,p]=[r.token,i.token],y=await this.scope.account.getCreatedTokenAccount({mint:d.mint,associatedOnly:!1}),f=await this.scope.account.getCreatedTokenAccount({mint:p.mint}),b=[t.baseMint.toBase58(),t.quoteMint.toBase58()],w=[n.baseMint.toBase58(),n.quoteMint.toBase58()],g=oi(b,w)[0],T=new ti(g),_=await this.scope.account.getCreatedTokenAccount({mint:T}),[A,q]=[r.raw,i.raw],F=this.createTxBuilder(),N=this.createTxBuilder(),ce=await c.handleTokenAccount({side:"in",amount:A,mint:d.mint,tokenAccount:y,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:J}=ce,D=ee(ce,["tokenAccount"]);F.addInstruction(D);let fe=await c.handleTokenAccount({side:"out",amount:0,mint:p.mint,tokenAccount:f,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:G}=fe,X=ee(fe,["tokenAccount"]);F.addInstruction(X);let de=await c.handleTokenAccount({side:"in",amount:0,mint:T,tokenAccount:_,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:$}=de,re=ee(de,["tokenAccount"]);F.addInstruction(re),N.addInstruction({instructions:Xr({fromPoolKeys:t,toPoolKeys:n,userKeys:{inTokenAccount:J,outTokenAccount:G,middleTokenAccount:$,middleStatusAccount:await ei({programId:pt,fromPoolId:t.id,middleMint:T,owner:this.scope.ownerPubKey}),owner:this.scope.ownerPubKey},amountIn:A,amountOut:q,fixedSide:a})});let se=F.build();return await N.buildMultiTx({extraPreBuildData:[se],extInfo:{amountOut:q}})}};import{PublicKey as Hs}from"@solana/web3.js";import ri from"bn.js";var vo=R([qe("mintAuthorityOption"),k("mintAuthority"),l("supply"),v("decimals"),v("isInitialized"),qe("freezeAuthorityOption"),k("freezeAuthority")]);function ni(o,e){return o.sort((t,n)=>{let{official:r,unOfficial:i}=e,a=new Set(r),u=new Set(i),c=p=>a.has(p.mint)?1:u.has(p.mint)?2:3,m=c(t)-c(n),d=p=>!/^[a-zA-Z]/.test(p);if(m===0){let p=d(t.symbol),y=d(n.symbol);return p&&!y?1:!p&&y?-1:t.symbol.localeCompare(n.symbol)}else return m})}async function Wf(o,e){try{if(!o)return;let t=await o.getAccountInfo(E({publicKey:e}));return!t||t.data.length!==vo.span?void 0:vo.decode(t.data)}catch{return}}var yt=class extends ie{constructor(t){super(t);this._tokens=[];this._tokenMap=new Map;this._tokenPrice=new Map;this._mintList={official:[],unOfficial:[],unNamed:[]}}async load(t){this.checkDisabled(),await this.scope.fetchTokens(t==null?void 0:t.forceUpdate),this._mintList={official:[],unOfficial:[],unNamed:[]},this._tokens=[],this._tokenMap=new Map;let{data:n}=this.scope.apiData.tokens||{data:{official:[],unOfficial:[],unNamed:[],blacklist:[]}},r=new Set(n.blacklist);[n.official,n.unOfficial,n.unNamed].forEach((i,a)=>{i.forEach(u=>{let c=["official","unOfficial","unNamed"][a];!r.has(u.mint)&&u.mint!==U.toBase58()&&(this._tokens.push(K(x({},u),{symbol:u.symbol||"",name:u.name||""})),this._mintList[c].push(u.mint))})}),this._mintList.official.push(Xe.mint.toBase58()),this._tokens=ni(this._tokens,this._mintList),this._tokens.push(K(x({},Xe),{mint:U.toBase58()})),this._tokens.forEach(i=>{this._tokenMap.set(i.mint,K(x({},i),{id:i.mint}))}),this._tokenMap.set(Y.mint,K(x({},Y),{icon:Xe.icon,id:"wsol"})),this._tokenMap.set(U.toBase58(),K(x({},Xe),{mint:U.toBase58()}))}get allTokens(){return this._tokens}get allTokenMap(){return this._tokenMap}get tokenMints(){return this._mintList}get tokenPrices(){return this._tokenPrice}async fetchTokenPrices(t){let n=this.allTokens.filter(m=>{var d;return!!((d=m.extensions)!=null&&d.coingeckoId)&&m.mint!==Hs.default.toBase58()}),r=n.map(m=>m.extensions.coingeckoId),i=await this.scope.api.getCoingeckoPrice(r),a=n.reduce((m,d)=>i[d.extensions.coingeckoId].usd?K(x({},m),{[d.mint]:Qe({token:this._tokenMap.get(d.mint),numberPrice:i[d.extensions.coingeckoId].usd,decimalDone:!0})}):m,{}),u=t||await this.scope.api.getRaydiumTokenPrice(),c=Object.keys(u).reduce((m,d)=>this._tokenMap.get(d)?K(x({},m),{[d]:Qe({token:this._tokenMap.get(d),numberPrice:u[d],decimalDone:!0})}):m,{});return this._tokenPrice=new Map([...Object.entries(a),...Object.entries(c)]),this._tokenPrice}mintToToken(t){let n=E({publicKey:t,transformSol:!0}),r=this.allTokenMap.get(n.toBase58());r||this.logAndCreateError("token not found, mint:",n.toBase58());let{decimals:i,name:a,symbol:u}=r;return new C({mint:t,decimals:i,name:a,symbol:u})}mintToTokenAmount({mint:t,amount:n,decimalDone:r}){let i=this.mintToToken(t);return r?new O(i,S(n)):new O(i,this.decimalAmount({mint:t,amount:n,decimalDone:r}))}decimalAmount({mint:t,amount:n}){let r=ue(n),i=this.mintToToken(t);return xe(new I(r.numerator,r.denominator).mul(new ri(10**i.decimals)))}uiAmount({mint:t,amount:n}){let r=ue(n),i=this.mintToToken(t);return i?new I(r.numerator,r.denominator).div(new ri(10**i.decimals)).toSignificant(i.decimals):""}};function ii(o){let e=[];for(let t=0;t<o.length;t++)for(let n=0;n<o.length;n++)t!=n&&e.push([o[t],o[n]]);return e}var bt=class extends ie{async load(){this.checkDisabled(),await this.scope.fetchLiquidity()}async _getBestSwapPool({availablePools:e,officialPoolIdSet:t}){if(e.length===0)return;if(e.length===1)return e[0];let n=e.filter(a=>t.has(a.id));return n.length===1?n[0]:(await this.scope.liquidity.sdkParseJsonLiquidityInfo(n.length?n:e)).reduce((a,u)=>{let c=a.version===5,m=u.version===5;return c&&!m?a:!c&&m?u:Ln(ro(a.lpSupply,10**a.lpDecimals),ro(u.lpSupply,10**u.lpDecimals))?a:u}).jsonInfo}async getAvailablePools(e){this.checkDisabled();let{inputMint:t,outputMint:n}=e,[r,i]=[E({publicKey:t,transformSol:!0}).toBase58(),E({publicKey:n,transformSol:!0}).toBase58()],a=this.scope.liquidity.allPools.filter(p=>p.baseMint===r&&p.quoteMint===i||p.baseMint===i&&p.quoteMint===r),u=new Set([...Hr,r,i]),c=new Set(JSON.parse(JSON.stringify([...u])));c.delete(r),c.delete(i);let m=this.scope.liquidity.allPools.filter(p=>{let y=u.has(p.baseMint)&&u.has(p.quoteMint),f=c.has(p.baseMint)&&c.has(p.quoteMint);return y&&!f}),d=await this._getBestSwapPool({availablePools:a,officialPoolIdSet:this.scope.liquidity.allPoolIdSet.official});return{availablePools:a,best:d,routedPools:m}}async getBestAmountOut({pools:e,amountIn:t,inputToken:n,outputToken:r,slippage:i,features:a}){if(this.checkDisabled(),!e){let{routedPools:_}=await this.getAvailablePools({inputMint:n.mint,outputMint:r.mint});e=_}let u=await this.scope.liquidity.sdkParseJsonLiquidityInfo(e||[]),c=(e||[]).map((_,A)=>({poolKeys:me(_),poolInfo:u[A]})),m=a||Qr;this.logDebug("features:",m),c.length||this.logAndCreateError("please provide at least one source of trade or (inputMint & outputMint)",c);let d=[],p="amm",y=new O(n,t),f=new O(r,0),b=f,w=null,L=null,g=new oe(ae),T=[];if(m.includes("amm"))for(let{poolKeys:_,poolInfo:A}of c)try{let{amountOut:q,minAmountOut:F,currentPrice:N,executionPrice:J,priceImpact:D,fee:G}=this.scope.liquidity.computeAmountOut({poolKeys:_,poolInfo:A,amountIn:y,outputToken:r,slippage:i});q.gt(f)&&(console.log("amm",A),d=[{source:"amm",keys:_}],p="amm",f=q,b=F,w=N,L=J,g=D,T=[G])}catch{}if(m.includes("route")){let _=ii(c);for(let A of _){if(A.length!==2)continue;let[q,F]=A,{poolKeys:N,poolInfo:J}=q,{poolKeys:D,poolInfo:G}=F;try{let{amountOut:X,minAmountOut:$,executionPrice:re,priceImpact:se,fee:Ie}=this.scope.route.computeRouteAmountOut({fromPoolKeys:N,toPoolKeys:D,fromPoolInfo:J,toPoolInfo:G,amountIn:y,outputToken:r,slippage:i});X.gt(f)&&(d=[{source:"amm",keys:N},{source:"amm",keys:D}],p="route",f=X,b=$,L=re,g=se,T=Ie)}catch{}}}return{routes:d,routeType:p,amountOut:f,minAmountOut:b,fixedSide:"in",currentPrice:w,executionPrice:L,priceImpact:g,fee:T}}async directSwap(e){this.checkDisabled();let{amountOut:t,amountIn:n,slippage:r,config:i}=e,a=n.token,u=t.token,{routes:c,routeType:m,minAmountOut:d}=await this.getBestAmountOut({inputToken:a,outputToken:u,amountIn:n.raw,slippage:r});return await this.swap({routes:c,routeType:m,amountIn:n,amountOut:d,fixedSide:"in",config:i})}async swap(e){this.checkDisabled(),this.scope.checkOwner();let{routes:t,routeType:n,amountIn:r,amountOut:i,fixedSide:a,config:u}=e;if(n==="amm"&&t.length===1)return await this.scope.liquidity.swapWithAMM({poolKeys:t[0].keys,amountIn:r,amountOut:i,fixedSide:a,config:u});if(n==="route"&&t.length===2)return await this.scope.route.swapWithRoute({fromPoolKeys:t[0].keys,toPoolKeys:t[1].keys,amountIn:r,amountOut:i,fixedSide:a,config:u});throw this.logAndCreateError("invalid routes with routeType","routes",{routeType:n,routes:t}),new Error("invalid routes with routeType")}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(Se));return e.sort((t,n)=>t.isAssociated?1:n.isAssociated||t.amount.lt(n.amount)?-1:1),e}async unWrapWSol(e){let t=await this.getWSolAccounts(),n=this.createTxBuilder(),r=await _e({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:0});n.addInstruction(r);let i=S(e);for(let a=0;a<t.length;a++)i.gte(t[a].amount)?(n.addInstruction({instructions:[Fe({tokenAccount:t[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),i.sub(t[a].amount)):(n.addInstruction({instructions:[Fe({tokenAccount:t[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),Ue({destination:r.signers[0].publicKey,source:t[a].publicKey,amount:i,owner:this.scope.ownerPubKey}));return n.build()}async wrapWSol(e){let t=await this.getWSolAccounts(),n=this.createTxBuilder(),r=await _e({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return n.addInstruction(r),t.length&&n.addInstruction({instructions:[Ue({destination:t[0].publicKey,source:r.signers[0].publicKey,amount:e,owner:this.scope.ownerPubKey})],endInstructions:[Fe({tokenAccount:r.signers[0].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),n.build()}};var Me={},Ut=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:n,owner:r,api:i,defaultApiTokens:a,defaultApiLiquidityPools:u,defaultApiFarmPools:c,defaultApiPairsInfo:m,apiCacheTime:d}=e;this._connection=t,this.cluster=n,this._owner=r?new le(r):void 0,this._signAllTransactions=e.signAllTransactions,this.api=i,this._apiCacheTime=d||5*60*1e3,this.logger=M("Raydium"),this.farm=new mt({scope:this,moduleName:"Raydium_Farm"}),this.account=new nt({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new dt({scope:this,moduleName:"Raydium_Liquidity"}),this.token=new yt({scope:this,moduleName:"Raydium_token"}),this.trade=new bt({scope:this,moduleName:"Raydium_trade"}),this.route=new ft({scope:this,moduleName:"Raydium_route"});let p=new Date().getTime(),[y,f,b,w]=[a?{fetched:p,data:a}:Me.tokens,u?{fetched:p,data:u}:Me.liquidityPools,c?{fetched:p,data:c}:Me.farmPools,m?{fetched:p,data:m}:Me.liquidityPairsInfo];this.apiData=x(x(x(x({},y?{tokens:y}:{}),f?{liquidityPools:f}:{}),b?{farmPools:b}:{}),w?{liquidityPairsInfo:w}:{})}static async load(e){let t=zs({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:n,apiRequestTimeout:r}=t,i=new Kt({cluster:n,timeout:r}),a=new Ut(K(x({},t),{api:i}));return await a.token.load(),await a.liquidity.load(),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(Ot);return this._owner.publicKey}setOwner(e){return this._owner=e?new le(e):void 0,this}get connection(){if(!this._connection)throw new Error(Kn);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw this.logger.error(Ot),new Error(Ot)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchTokens(e){if(this.apiData.tokens&&!this.isCacheInvalidate(this.apiData.tokens.fetched)&&!e)return this.apiData.tokens.data;let t={fetched:Date.now(),data:await this.api.getTokens()};return this.apiData.tokens=t,Me.tokens=t,t.data}async fetchLiquidity(e){if(this.apiData.liquidityPools&&!this.isCacheInvalidate(this.apiData.liquidityPools.fetched)&&!e)return this.apiData.liquidityPools.data;let t={fetched:Date.now(),data:await this.api.getLiquidityPools()};return this.apiData.liquidityPools=t,Me.liquidityPools=t,t.data}async fetchPairs(e){var n;if(this.apiData.liquidityPairsInfo&&!this.isCacheInvalidate(this.apiData.liquidityPairsInfo.fetched)&&!e)return((n=this.apiData.liquidityPairsInfo)==null?void 0:n.data)||[];let t={fetched:Date.now(),data:await this.api.getPairsInfo()};return this.apiData.liquidityPairsInfo=t,Me.liquidityPairsInfo=t,t.data}async fetchFarms(e){if(this.apiData.farmPools&&!this.isCacheInvalidate(this.apiData.farmPools.fetched)&&!e)return this.apiData.farmPools.data;let t={fetched:Date.now(),data:await this.api.getFarmPools()};return this.apiData.farmPools=t,Me.farmPools=t,t.data}async chainTimeOffset(){let e=await this.connection.getBlockTime(await this.connection.getSlot());return e?(e*1e3,Number((e*1e3-Date.now()).toFixed(0))):0}mintToToken(e){return this.token.mintToToken(e)}mintToTokenAmount(e){return this.token.mintToTokenAmount(e)}decimalAmount(e){return this.token.decimalAmount(e)}uiAmount(e){return this.token.uiAmount(e)}};var yb=o=>o;export{Vu as ANAMint,Kt as Api,We as BNLayout,an as BN_100,mu as BN_1000,lu as BN_10000,cu as BN_FIVE,pe as BN_ONE,be as BN_TEN,uu as BN_THREE,su as BN_TWO,ae as BN_ZERO,km as BitStructure,Fn as Blob,to as Currency,As as DataElement,gn as ETHMint,tr as FARM_LOCK_MINT,or as FARM_LOCK_VAULT,Xn as FARM_PROGRAMID_TO_VERSION,Hn as FARM_PROGRAM_ID_V3,os as FARM_PROGRAM_ID_V3_PUBKEY,zn as FARM_PROGRAM_ID_V5,ns as FARM_PROGRAM_ID_V5_PUBKEY,Zn as FARM_PROGRAM_ID_V6,rs as FARM_PROGRAM_ID_V6_PUBKEY,rr as FARM_VERSION_TO_LEDGER_LAYOUT,er as FARM_VERSION_TO_PROGRAMID,nr as FARM_VERSION_TO_STATE_LAYOUT,I as Fraction,Ar as LIQUIDITY_FEES_DENOMINATOR,Tr as LIQUIDITY_FEES_NUMERATOR,sp as LIQUIDITY_PROGRAMID_TO_VERSION,hs as LIQUIDITY_PROGRAM_ID_V4,ws as LIQUIDITY_PROGRAM_ID_V5,Sr as LIQUIDITY_VERSION_TO_PROGRAM_ID,Lr as LIQUIDITY_VERSION_TO_SERUM_VERSION,_r as LIQUIDITY_VERSION_TO_STATE_LAYOUT,tt as Layout,kr as LiquidityPoolStatus,yi as LogLevel,jt as Logger,ke as MODEL_DATA_PUBKEY,Eu as NRVMint,mo as OptionLayout,le as Owner,ln as PAIMint,oe as Percent,j as Price,_t as RAYMint,pt as ROUTE_PROGRAM_ID_V1,Ut as Raydium,Qt as Rounding,Rp as SERUM_PROGRAMID_TO_VERSION,vs as SERUM_PROGRAM_ID_V3,Ds as SERUM_VERSION_TO_PROGRAM_ID,U as SOLMint,vo as SPL_MINT_LAYOUT,Du as SRMMint,vt as StableLayout,lo as Structure,cn as TOKEN_SOL,Y as TOKEN_WSOL,C as Token,O as TokenAmount,Mt as TxBuilder,so as UInt,dn as USDCMint,bn as USDHMint,pn as USDTMint,po as Union,Se as WSOLMint,Vn as WideBits,he as WrappedLayout,Pn as _100_PERCENT,Ir as _LIQUIDITY_PROGRAM_ID_V4,xr as _LIQUIDITY_PROGRAM_ID_V5,Js as _ROUTE_PROGRAM_ID_V1,Cr as _SERUM_PROGRAM_ID_V3,s as accountMeta,Ro as addLiquidityLayout,dl as array,yo as associatedLedgerAccountLayout,uo as bits,Ce as blob,sl as bool,To as calFarmRewardAmount,gr as calculateFarmPoolAprList,xn as chunkArray,Fe as closeAccountInstruction,Oe as commonSystemAccountMeta,cr as createAssociatedLedgerAccountInstruction,M as createLogger,So as createPoolV4Layout,_e as createWSolAccountInstructions,Zm as cstr,Qu as currencyEquals,qa as decodeBool,Qr as defaultRoutes,ro as div,zt as divCeil,it as dwLayout,Fa as encodeBool,cm as endlessRetry,Ei as eq,jm as f32,Ym as f32be,Qm as f64,Hm as f64be,ho as farmAddRewardLayout,ir as farmDespotVersionToInstruction,Zl as farmLedgerLayoutV3_1,$n as farmLedgerLayoutV3_2,Xl as farmLedgerLayoutV5_1,jn as farmLedgerLayoutV5_2,Yn as farmLedgerLayoutV6_1,pr as farmRewardInfoToConfig,go as farmRewardLayout,Po as farmRewardRestartLayout,ts as farmRewardTimeInfoLayout,Gn as farmStateV3Layout,Jn as farmStateV5Layout,rt as farmStateV6Layout,ar as farmWithdrawVersionToInstruction,ys as fetchMultipleFarmInfoAndUpdate,Pe as findProgramAddress,Io as fixedSwapInLayout,xo as fixedSwapOutLayout,Fi as forecastTransactionSize,Os as formatLayout,qo as getAmountSide,jr as getAmountsSide,lr as getAssociatedAuthority,ko as getAssociatedLedgerAccount,Nt as getAssociatedLedgerPoolAccount,ei as getAssociatedMiddleStatusAccount,No as getAssociatedPoolKeys,Bn as getDate,Kr as getDxByDyBaseIn,Br as getDyByDxBaseIn,ds as getFarmLedgerLayout,dr as getFarmProgramId,ps as getFarmStateLayout,ls as getFarmVersion,Cs as getLiquidityAssociatedAuthority,Re as getLiquidityAssociatedId,Gp as getLiquidityInfo,Vs as getLiquidityProgramId,Up as getLiquidityStateLayout,Rn as getMax,vi as getMultipleAccountsInfo,Sn as getMultipleAccountsInfoWithCustomFlags,Fo as getPoolEnabledFeatures,kn as getRecentBlockHash,Wf as getSPLTokenInfo,Gr as getSerumAssociatedAuthority,Ur as getSerumProgramId,Wr as getSerumVersion,Or as getStablePrice,Vi as getTime,hc as getTimestamp,Jr as getTokenSide,Ws as getTokensSide,Tm as greedy,ii as groupPools,Di as gt,Ln as gte,il as i128,rl as i64,Ge as includesToken,Lo as initPoolLayout,Ja as initTokenAccountInstruction,Mc as intersection,Ee as isDateAfter,et as isDateBefore,Bt as isMeaningfulNumber,Mn as isNumber,wo as isValidFarmVersion,Yr as isValidFixedSide,me as jsonInfo2PoolKeys,yr as judgeFarmType,_o as liquidityStateV4Layout,ks as liquidityStateV5Layout,Jc as lt,$c as lte,fn as mSOLMint,qr as makeAMMSwapInstruction,Dr as makeAddLiquidityInstruction,mr as makeCreateFarmInstruction,Nr as makeCreatePoolInstruction,vr as makeInitPoolInstruction,Er as makeRemoveLiquidityInstruction,Xr as makeRouteSwapInstruction,Fr as makeSimulatePoolInfoInstruction,$r as makeSimulationPoolInfo,Fs as makeSwapFixedInInstruction,Ns as makeSwapFixedOutInstruction,js as makeSwapInFixedInInstruction,Ys as makeSwapOutFixedInInstruction,Ue as makeTransferInstruction,fr as mergeSdkFarmInfo,Is as modelDataInfoLayout,sn as mul,Vm as ns64,$m as ns64be,Lm as nu64,Om as nu64be,co as offset,io as offsetDateTime,al as option,S as parseBigNumberish,ue as parseNumberInfo,In as parseSimulateLogToJson,ge as parseSimulateValue,Cn as parseTokenAccountResp,Ft as poolTypeV6,k as publicKey,Xe as quantumSOLHydratedTokenJsonInfo,Za as realFarmStateV3Layout,Xa as realFarmStateV5Layout,es as realFarmV6Layout,Mo as removeLiquidityLayout,Vt as routeSwapInLayout,Ct as routeSwapOutLayout,ll as rustEnum,Fm as s16,Cm as s16be,Nm as s24,Wm as s24be,vm as s32,Um as s32be,Dm as s40,Gm as s40be,Em as s48,Jm as s48be,qm as s8,H as seq,ou as setLoggerLevel,bi as shakeFractionDecimal,An as simulateMultipleInstruction,hn as sleep,ni as sortTokens,we as splAccountLayout,Ii as splitNumber,yn as stSOLMint,ml as str,R as struct,_n as sub,Hr as swapRouteMiddleMints,cl as tagged,Ht as tenExponential,xe as toBN,Ke as toFraction,Gc as toFractionWithDecimals,It as toPercent,Qe as toTokenPrice,He as toTotalPrice,rn as toUsdCurrency,mn as tryParsePublicKey,Q as u128,Am as u16,_m as u16be,Im as u24,Rm as u24be,qe as u32,Mm as u32be,xm as u40,Bm as u40be,Sm as u48,Km as u48be,l as u64,v as u8,pl as union,yb as unionArr,zm as unionLayoutDiscriminator,Kc as uniq,fs as updateFarmPoolInfo,Xm as utf8,E as validateAndParsePublicKey,sr as validateFarmRewards,ul as vec,Na as vecU8,br as whetherIsStakeFarmPool,bo as withdrawRewardLayout,Bc as xor,fl as zeros};
//# sourceMappingURL=index.mjs.map