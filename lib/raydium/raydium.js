var li=Object.create;var nt=Object.defineProperty,di=Object.defineProperties,pi=Object.getOwnPropertyDescriptor,fi=Object.getOwnPropertyDescriptors,bi=Object.getOwnPropertyNames,Bt=Object.getOwnPropertySymbols,yi=Object.getPrototypeOf,Xt=Object.prototype.hasOwnProperty,no=Object.prototype.propertyIsEnumerable;var to=(n,e,t)=>e in n?nt(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,S=(n,e)=>{for(var t in e||(e={}))Xt.call(e,t)&&to(n,t,e[t]);if(Bt)for(var t of Bt(e))no.call(e,t)&&to(n,t,e[t]);return n},O=(n,e)=>di(n,fi(e));var ne=(n,e)=>{var t={};for(var o in n)Xt.call(n,o)&&e.indexOf(o)<0&&(t[o]=n[o]);if(n!=null&&Bt)for(var o of Bt(n))e.indexOf(o)<0&&no.call(n,o)&&(t[o]=n[o]);return t};var gi=(n,e)=>{for(var t in e)nt(n,t,{get:e[t],enumerable:!0})},oo=(n,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of bi(e))!Xt.call(n,r)&&r!==t&&nt(n,r,{get:()=>e[r],enumerable:!(o=pi(e,r))||o.enumerable});return n};var Q=(n,e,t)=>(t=n!=null?li(yi(n)):{},oo(e||!n||!n.__esModule?nt(t,"default",{value:n,enumerable:!0}):t,n)),hi=n=>oo(nt({},"__esModule",{value:!0}),n);var Sa={};gi(Sa,{Raydium:()=>xt});module.exports=hi(Sa);var ii=require("lodash");var Vo=Q(require("axios"));var ot=require("lodash"),tn=Q(require("dayjs")),io=Q(require("dayjs/plugin/utc"));tn.default.extend(io.default);var en=class{constructor(e){this.logLevel=e.logLevel!==void 0?e.logLevel:3,this.name=e.name}set level(e){this.logLevel=e}get time(){return(0,tn.default)().utc().format("YYYY/MM/DD HH:mm:ss UTC")}get moduleName(){return this.name}isLogLevel(e){return e<=this.logLevel}error(...e){return this.isLogLevel(0)?(console.error(this.time,this.name,"sdk logger error",...e),this):this}logWithError(...e){let t=e.map(o=>typeof o=="object"?JSON.stringify(o):o).join(", ");throw new Error(t)}warning(...e){return this.isLogLevel(1)?(console.warn(this.time,this.name,"sdk logger warning",...e),this):this}info(...e){return this.isLogLevel(2)?(console.info(this.time,this.name,"sdk logger info",...e),this):this}debug(...e){return this.isLogLevel(3)?(console.debug(this.time,this.name,"sdk logger debug",...e),this):this}},ro={},wi={};function M(n){let e=(0,ot.get)(ro,n);if(!e){let t=(0,ot.get)(wi,n);e=new en({name:n,logLevel:t}),(0,ot.set)(ro,n,e)}return e}var Lo=require("@solana/web3.js"),_o=Q(require("bn.js"));var fo=Q(require("big.js")),ct=Q(require("bn.js"));var V=Q(require("bn.js"));var Ot=M("Raydium_bignumber");var ue=new V.default(0),ye=new V.default(1),Ba=new V.default(2),Oa=new V.default(3),Fa=new V.default(5),ke=new V.default(10),uo=new V.default(100),qa=new V.default(1e3),Na=new V.default(1e4),ao=9007199254740991;function T(n){if(n instanceof V.default)return n;if(typeof n=="string"){if(n.match(/^-?[0-9]+$/))return new V.default(n);Ot.logWithError(`invalid BigNumberish string: ${n}`)}return typeof n=="number"?(n%1&&Ot.logWithError(`BigNumberish number underflow: ${n}`),(n>=ao||n<=-ao)&&Ot.logWithError(`BigNumberish number overflow: ${n}`),new V.default(String(n))):typeof n=="bigint"?new V.default(n.toString()):(Ot.logWithError(`invalid BigNumberish value: ${n}`),new V.default(0))}function nn(n){return ke.pow(T(n))}function ce(n){var u;if(n===void 0)return{denominator:"1",numerator:"0"};if(n instanceof V.default)return{numerator:n.toString(),denominator:"1"};if(n instanceof A)return{denominator:n.denominator.toString(),numerator:n.numerator.toString()};let e=String(n),[,t="",o="",r=""]=(u=e.replace(",","").match(/(-?)(\d*)\.?(\d*)/))!=null?u:[],i="1"+"0".repeat(r.length),a=t+(o==="0"?"":o)+r||"0";return{denominator:i,numerator:a,sign:t,int:o,dec:r}}function on(n,e){let t=n.divmod(e);return t.mod.isZero()?t.div:t.div.negative!==0?t.div.isubn(1):t.div.iaddn(1)}function ki(n){var o;let[,e="",t=""]=(o=n.toFixed(2).match(/(-?)(\d*)\.?(\d*)/))!=null?o:[];return`${e}${t}`}function Se(n,e=0){return n instanceof V.default?n:new V.default(ki(ve(n).mul(ke.pow(new V.default(String(e))))))}function ve(n){if(n instanceof re)return new A(n.numerator,n.denominator);if(n instanceof Z)return n.adjusted;if(n instanceof F)try{return ve(n.toExact())}catch{return new A(ue)}if(n instanceof A)return n;let e=String(n),t=ce(e);return new A(t.numerator,t.denominator)}function Ft(n,e){let{numerator:t,denominator:o}=ce(n);return new re(new V.default(t),new V.default(o).mul(e!=null&&e.alreadyDecimaled?new V.default(100):new V.default(1)))}function rt(n){let{token:e,numberPrice:t,decimalDone:o}=n,r=new $({mint:"",decimals:6,symbol:"usd",name:"usd",skipMint:!0}),{numerator:i,denominator:a}=ce(t),u=o?new V.default(i).mul(ke.pow(new V.default(e.decimals))):i,c=new V.default(a).mul(ke.pow(new V.default(r.decimals)));return new Z({baseToken:r,denominator:c.toString(),quoteToken:new $(O(S({},e),{skipMint:!0,mint:""})),numerator:u.toString()})}function co(n,e){if(n==null||e==null)return;let t=ve(n),o=ve(e);return t.mul(o)}function so(n){let e=new $({mint:"",decimals:6,symbol:"usd",name:"usd",skipMint:!0}),t=Se(co(n,10**e.decimals));return new F(e,t)}function it(n,e){return so(!e||!n?0:co(n,e))}var mo=Q(require("toformat")),Pi=mo.default,at=Pi;var st=Q(require("big.js")),lo=Q(require("decimal.js-light"));var qt=M("module/fraction"),rn=at(st.default),ut=at(lo.default),Ai={[0]:ut.ROUND_DOWN,[1]:ut.ROUND_HALF_UP,[2]:ut.ROUND_UP},Ti={[0]:st.default.roundDown,[1]:st.default.roundHalfUp,[2]:st.default.roundUp},A=class{constructor(e,t=ye){this.numerator=T(e),this.denominator=T(t)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new A(this.denominator,this.numerator)}add(e){let t=e instanceof A?e:new A(T(e));return this.denominator.eq(t.denominator)?new A(this.numerator.add(t.numerator),this.denominator):new A(this.numerator.mul(t.denominator).add(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}sub(e){let t=e instanceof A?e:new A(T(e));return this.denominator.eq(t.denominator)?new A(this.numerator.sub(t.numerator),this.denominator):new A(this.numerator.mul(t.denominator).sub(t.numerator.mul(this.denominator)),this.denominator.mul(t.denominator))}mul(e){let t=e instanceof A?e:new A(T(e));return new A(this.numerator.mul(t.numerator),this.denominator.mul(t.denominator))}div(e){let t=e instanceof A?e:new A(T(e));return new A(this.numerator.mul(t.denominator),this.denominator.mul(t.numerator))}toSignificant(e,t={groupSeparator:""},o=1){Number.isInteger(e)||qt.logWithError(`${e} is not an integer.`),e<=0&&qt.logWithError(`${e} is not positive.`),ut.set({precision:e+1,rounding:Ai[o]});let r=new ut(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(e);return r.toFormat(r.decimalPlaces(),t)}toFixed(e,t={groupSeparator:""},o=1){return Number.isInteger(e)||qt.logWithError(`${e} is not an integer.`),e<0&&qt.logWithError(`${e} is negative.`),rn.DP=e,rn.RM=Ti[o]||1,new rn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e,t)}isZero(){return this.numerator.isZero()}};var xi=M("Raydium_amount"),po=at(fo.default);function Si(n,e){let t="0",o="0";if(n.includes(".")){let r=n.split(".");r.length===2?([t,o]=r,o=o.padEnd(e,"0")):xi.logWithError(`invalid number string, num: ${n}`)}else t=n;return[t,o.slice(0,e)||o]}var F=class extends A{constructor(t,o,r=!0,i){let a=new ct.default(0),u=ke.pow(new ct.default(t.decimals));if(r)a=T(o);else{let c=new ct.default(0),m=new ct.default(0);if(typeof o=="string"||typeof o=="number"||typeof o=="bigint"){let[d,p]=Si(o.toString(),t.decimals);c=T(d),m=T(p)}c=c.mul(u),a=c.add(m)}super(a,u);this.logger=M(i||"Amount"),this.token=t}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(t){return this.token.equals(t.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(t.raw)}lt(t){return this.token.equals(t.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(t.raw)}add(t){return this.token.equals(t.token)||this.logger.logWithError("add token not equals"),new F(this.token,this.raw.add(t.raw))}subtract(t){return this.token.equals(t.token)||this.logger.logWithError("sub token not equals"),new F(this.token,this.raw.sub(t.raw))}toSignificant(t=this.token.decimals,o,r=0){return super.toSignificant(t,o,r)}toFixed(t=this.token.decimals,o,r=0){return t>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(t,o,r)}toExact(t={groupSeparator:""}){return po.DP=this.token.decimals,new po(this.numerator.toString()).div(this.denominator.toString()).toFormat(t)}};var bo=require("@solana/web3.js"),yo={symbol:"SOL",name:"Solana",decimals:9},H={symbol:"WSOL",name:"Wrapped SOL",mint:"So11111111111111111111111111111111111111112",decimals:9,extensions:{coingeckoId:"solana"}},mt={isQuantumSOL:!0,isLp:!1,official:!0,mint:new bo.PublicKey(H.mint),decimals:9,symbol:"SOL",id:"sol",name:"solana",icon:"https://img.raydium.io/icon/So11111111111111111111111111111111111111112.png",extensions:{coingeckoId:"solana"}};var vt=require("@solana/web3.js");var go=require("@solana/spl-token"),j=require("@solana/web3.js");function s({pubkey:n,isSigner:e=!1,isWritable:t=!0}){return{pubkey:n,isWritable:t,isSigner:e}}var De=[s({pubkey:go.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:j.SystemProgram.programId,isWritable:!1}),s({pubkey:j.SYSVAR_RENT_PUBKEY,isWritable:!1})];function C({publicKey:n,transformSol:e}){if(n instanceof j.PublicKey)return e&&n.equals(U)?Le:n;if(e&&n===U.toBase58())return Le;if(typeof n=="string")try{return new j.PublicKey(n)}catch{throw new Error("invalid public key")}throw new Error("invalid public key")}function ho(n){try{return new j.PublicKey(n)}catch{return n}}var Nt=new j.PublicKey("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),wo=new j.PublicKey("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),es=new j.PublicKey("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),ko=new j.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Po=new j.PublicKey("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Io=new j.PublicKey("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),Ao=new j.PublicKey("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),To=new j.PublicKey("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),ts=new j.PublicKey("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),ns=new j.PublicKey("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),xo=new j.PublicKey("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),Le=new j.PublicKey("So11111111111111111111111111111111111111112"),U=j.PublicKey.default;var an=class{constructor({mint:e,decimals:t,symbol:o="UNKNOWN",name:r="UNKNOWN",skipMint:i=!1}){if(e===U.toBase58()||e instanceof vt.PublicKey&&U.equals(e)){this.decimals=H.decimals,this.symbol=H.symbol,this.name=H.name,this.mint=new vt.PublicKey(H.mint);return}this.decimals=t,this.symbol=o,this.name=r,this.mint=i?vt.PublicKey.default:C({publicKey:e})}equals(e){return this===e?!0:this.mint.equals(e.mint)}},$=an;$.WSOL=new an(H);var un=class{constructor({decimals:e,symbol:t="UNKNOWN",name:o="UNKNOWN"}){this.decimals=e,this.symbol=t,this.name=o}equals(e){return this===e}},sn=un;sn.SOL=new un(yo);var So=new A(uo),re=class extends A{toSignificant(e=5,t,o){return this.mul(So).toSignificant(e,t,o)}toFixed(e=2,t,o){return this.mul(So).toFixed(e,t,o)}};var Li=M("Raydium_price"),Z=class extends A{constructor(t){let{baseToken:o,quoteToken:r,numerator:i,denominator:a}=t;super(i,a);this.baseToken=o,this.quoteToken=r,this.scalar=new A(nn(o.decimals),nn(r.decimals))}get raw(){return new A(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Z({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(t){this.quoteToken!==t.baseToken&&Li.logWithError("mul token not equals");let o=super.mul(t);return new Z({baseToken:this.baseToken,quoteToken:t.quoteToken,denominator:o.denominator,numerator:o.numerator})}toSignificant(t=this.quoteToken.decimals,o,r){return this.adjusted.toSignificant(t,o,r)}toFixed(t=this.quoteToken.decimals,o,r){return this.adjusted.toFixed(t,o,r)}};var _i=[$,F,Lo.PublicKey,A,_o.default,Z,re];function Ri(n){return typeof n=="object"&&n!==null&&!_i.some(e=>typeof e=="object"&&n instanceof e)}function pe(n){return typeof n=="string"?ho(n):Array.isArray(n)?n.map(e=>pe(e)):Ri(n)?Object.fromEntries(Object.entries(n).map(([e,t])=>[e,pe(t)])):n}var se=require("@solana/web3.js");var _e=M("Raydium_txTool"),Dt=class{constructor(e){this.instructions=[];this.endInstructions=[];this.signers=[];this.connection=e.connection,this.feePayer=e.feePayer,this.signAllTransactions=e.signAllTransactions,this.owner=e.owner}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers}}get allInstructions(){return[...this.instructions,...this.endInstructions]}addInstruction({instructions:e=[],endInstructions:t=[],signers:o=[]}){return this.instructions.push(...e),this.endInstructions.push(...t),this.signers.push(...o),this}build(e){let t=new se.Transaction;return this.allInstructions.length&&t.add(...this.allInstructions),t.feePayer=this.feePayer,{transaction:t,signers:this.signers,execute:async()=>{var r;let o=await Ro(this.connection);if(t.recentBlockhash=o,(r=this.owner)!=null&&r.isKeyPair)return(0,se.sendAndConfirmTransaction)(this.connection,t,this.signers);if(this.signAllTransactions){this.signers.length&&t.partialSign(...this.signers);let i=await this.signAllTransactions([t]);return await this.connection.sendRawTransaction(i[0].serialize(),{skipPreflight:!0})}throw new Error("please connect wallet first")},extInfo:e||{}}}buildMultiTx(e){let{extraPreBuildData:t=[],extInfo:o}=e,{transaction:r}=this.build(o),i=t.filter(c=>c.transaction.instructions.length>0),a=[...i.map(c=>c.transaction),r],u=[...i.map(c=>c.signers),this.signers];return{transactions:a,signers:u,execute:async()=>{var m;let c=await Ro(this.connection);if((m=this.owner)!=null&&m.isKeyPair)return await Promise.all(a.map(async(d,p)=>(d.recentBlockhash=c,await(0,se.sendAndConfirmTransaction)(this.connection,d,u[p]))));if(this.signAllTransactions){let d=a.map((f,y)=>(f.recentBlockhash=c,u[y].length&&f.partialSign(...u[y]),f)),p=await this.signAllTransactions(d),b=[];for(let f=0;f<p.length;f+=1){let y=await this.connection.sendRawTransaction(p[f].serialize(),{skipPreflight:!0});b.push(y)}return b}throw new Error("please connect wallet first")},extInfo:o||{}}}};async function Ro(n){var e,t;try{return((t=await((e=n.getLatestBlockhash)==null?void 0:e.call(n)))==null?void 0:t.blockhash)||(await n.getRecentBlockhash()).blockhash}catch{return(await n.getRecentBlockhash()).blockhash}}function Mi(n,e){n.length<1&&_e.logWithError(`no instructions provided: ${n.toString()}`),e.length<1&&_e.logWithError(`no signers provided:, ${e.toString()}`);let t=new se.Transaction;t.recentBlockhash="11111111111111111111111111111111",t.feePayer=e[0],t.add(...n);let o=t.compileMessage().serialize();return e.length+e.length*64+o.length}async function Mo(n,e,t){let o=new se.PublicKey("RaydiumSimuLateTransaction11111111111111111"),r=[],i=new se.Transaction;i.feePayer=o;for(let c of e)Mi([...i.instructions,c],[o])>se.PACKET_DATA_SIZE&&(r.push(i),i=new se.Transaction,i.feePayer=o),i.add(c);i.instructions.length>0&&r.push(i);let a=[];try{a=await Promise.all(r.map(c=>n.simulateTransaction(c)))}catch(c){c instanceof Error&&_e.logWithError(`failed to simulate for instructions, RPC_ERROR, ${c.message}`)}let u=[];for(let c of a){let{value:m}=c;if(_e.debug(`simulate result: ${JSON.stringify(c)}`),m.logs){let d=m.logs.filter(p=>p&&p.includes(t));_e.debug(`filteredLog: ${JSON.stringify(u)}`),d.length||_e.logWithError(` "simulate log not match keyword, keyword: ${t}`),u.push(...d)}}return u}function Bo(n,e){let t=n.match(/{["\w:,]+}/g);return!t||t.length!==1?_e.logWithError(`simulate log fail to match json, keyword: ${e}`):t[0]}function Pe(n,e){let o=new RegExp(`"${e}":(\\d+)`,"g").exec(n);return!o||o.length!==2?_e.logWithError(`simulate log fail to match key", key: ${e}`):o[1]}async function Ie(n,e){let[t,o]=await se.PublicKey.findProgramAddress(n,e);return{publicKey:t,nonce:o}}var fe=class{constructor(e){this._owner=e}get publicKey(){return fe.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return fe.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return fe.isKeyPair(this._owner)}get isPublicKey(){return fe.isPublicKey(this._owner)}static isKeyPair(e){return e.secretKey!==void 0}static isPublicKey(e){return!fe.isKeyPair(e)}};function Oo(n,e=1,t=[]){let o=[...n];if(e<=0)return t;for(;o.length;)t.push(o.splice(0,e));return t}var Fo=require("@solana/web3.js");var cn=M("Raydium_accountInfo_util");async function Bi(n,e,t){let{batchRequest:o,commitment:r}=S({batchRequest:!1},t),i=Oo(e,100),a=new Array(i.length).fill([]);if(o){let u=i.map(m=>{let d=n._buildArgs([m.map(p=>p.toBase58())],r,"base64");return{methodName:"getMultipleAccounts",args:d}});a=(await n._rpcBatchRequest(u)).map(m=>(m.error&&cn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(d=>{if(d){let{data:p,executable:b,lamports:f,owner:y,rentEpoch:h}=d;return p.length!==2&&p[1]!=="base64"&&cn.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(p[0],"base64"),executable:b,lamports:f,owner:new Fo.PublicKey(y),rentEpoch:h}}return null})))}else try{a=await Promise.all(i.map(u=>n.getMultipleAccountsInfo(u,r)))}catch(u){u instanceof Error&&cn.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return a.flat()}async function qo(n,e,t){let o=await Bi(n,e.map(r=>r.pubkey),t);return e.map((r,i)=>O(S({},r),{accountInfo:o[i]}))}function me(n){if(n instanceof re)return new A(n.numerator,n.denominator);if(n instanceof Z)return n.adjusted;if(n instanceof F)try{return me(n.toExact())}catch{return new A(ue)}if(n instanceof A)return n;let e=String(n),t=ce(e);return new A(t.numerator,t.denominator)}function Oi(n,e){if(n==null||e==null)return!1;let t=me(n),o=me(e);return t.sub(o).numerator.gt(ue)}function No(n,e){if(n==null||e==null)return!1;let t=me(n),o=me(e);return t.sub(o).numerator.gte(ue)}function Fi(n,e){if(n==null||e==null)return!1;let t=me(n),o=me(e);return t.sub(o).numerator.eq(ue)}function mn(n,e){if(n==null||e==null)return;let t=me(n),o=me(e);try{return t.div(o)}catch{return t}}function vo(n,e){if(n==null||e==null)return;let t=me(n),o=me(e);return t.sub(o)}function Et(n){return n==null?!1:!Fi(n,0)}function Do(n,e){return Oi(e,n)?e:n}var Eo=n=>typeof n=="number",Ko=n=>n?new Date(n):new Date,qi=n=>Ko(n).getTime();function lt(n,e,t){let o=Eo(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(n).getTime()<=o}function Ge(n,e,t){let o=Eo(e)?e*((t==null?void 0:t.unit)==="s"?1e3:1):e;return new Date(n).getTime()>o}function ln(n,e){let o=qi(n)+(e.days?e.days*24*60*60*1e3:0)+(e.hours?e.hours*60*60*1e3:0)+(e.minutes?e.minutes*60*1e3:0)+(e.seconds?e.seconds*1e3:0)+(e.milliseconds?e.milliseconds:0);return Ko(o)}var Kt=M("Raydium_Api");var Vt=class{constructor({cluster:e,timeout:t}){this.cluster=e,this.api=Vo.default.create({baseURL:"https://api.raydium.io/v2",timeout:t}),this.api.interceptors.request.use(o=>{let{method:r,baseURL:i,url:a}=o;return Kt.debug(`${r==null?void 0:r.toUpperCase()} ${i}${a}`),o},o=>(Kt.error("Request failed"),Promise.reject(o))),this.api.interceptors.response.use(o=>{let{config:r,data:i,status:a}=o,{method:u,baseURL:c,url:m}=r;return Kt.debug(`${u==null?void 0:u.toUpperCase()} ${c}${m}  ${a}`),i},o=>{let{config:r,response:i={}}=o,{status:a}=i,{method:u,baseURL:c,url:m}=r;return Kt.error(`${u.toUpperCase()} ${c}${m} ${a||o.message}`),Promise.reject(o)})}async getTokens(){return this.api.get("/sdk/token/raydium.mainnet.json")}async getLiquidityPools(){return this.api.get(`/sdk/liquidity/${this.cluster}.json`)}async getPairsInfo(){return this.api.get("https://api.raydium.io/v2/main/pairs")}async getFarmPools(){return this.api.get(`/sdk/farm-v2/${this.cluster}.json`)}async getCoingeckoPrice(e){return this.api.get(`https://api.coingecko.com/api/v3/simple/price?ids=${e.join(",")}&vs_currencies=usd`)}async getRaydiumTokenPrice(){return this.api.get("https://api.raydium.io/v2/main/price")}async getBlockSlotCountForSecond(e){if(!e)return 2;let o=(await this.api.post(e,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(r=>r.numSlots);return o.reduce((r,i)=>r+i,0)/o.length/60}};var Ct="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",Co="please provide connection in load() initialization or set it by raydium.setConnection(connection)";var Be=require("@solana/spl-token"),Qo=require("@solana/web3.js");var dn=(...n)=>n.map(e=>{try{return typeof e=="object"?JSON.stringify(e):e}catch{return e}}).join(", "),ie=class{constructor({scope:e,moduleName:t}){this.disabled=!1;this.scope=e,this.logger=M(t)}createTxBuilder(e){return this.scope.checkOwner(),new Dt({connection:this.scope.connection,feePayer:e||this.scope.ownerPubKey,owner:this.scope.owner,signAllTransactions:this.scope.signAllTransactions})}logDebug(...e){this.logger.debug(dn(e))}logInfo(...e){this.logger.info(dn(e))}logAndCreateError(...e){let t=dn(e);throw new Error(t)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};var Re=require("@solana/spl-token"),je=require("@solana/web3.js"),$o=Q(require("bn.js"));var Go=require("@solana/web3.js"),$e=Q(require("bn.js"));var x=require("@solana/buffer-layout"),pn=x.Layout,Wo=x.Structure;var fn=x.UInt;var Uo=x.seq;var dt=x.blob;var Wt=class extends pn{constructor(t,o,r){super(t,r);this.blob=dt(t),this.signed=o}decode(t,o=0){let r=new $e.default(this.blob.decode(t,o),10,"le");return this.signed?r.fromTwos(this.span*8).clone():r}encode(t,o,r=0){return typeof t=="number"&&(t=new $e.default(t)),this.signed&&(t=t.toTwos(this.span*8)),this.blob.encode(t.toArrayLike(Buffer,"le",this.span),o,r)}};function E(n){return new fn(1,n)}function Ee(n){return new fn(4,n)}function l(n){return new Wt(8,!1,n)}function z(n){return new Wt(16,!1,n)}var bn=class extends pn{constructor(t,o,r,i){super(t.span,i);this.layout=t,this.decoder=o,this.encoder=r}decode(t,o){return this.decoder(this.layout.decode(t,o))}encode(t,o,r){return this.layout.encode(this.encoder(t),o,r)}getSpan(t,o){return this.layout.getSpan(t,o)}};function w(n){return new bn(dt(32),e=>new Go.PublicKey(e),e=>e.toBuffer(),n)}var yn=class extends Wo{decode(e,t){return super.decode(e,t)}};function R(n,e,t){return new yn(n,e,t)}function ee(n,e,t){let o,r=typeof e=="number"?e:(0,$e.isBN)(e)?e.toNumber():new Proxy(e,{get(i,a){if(!o){let u=Reflect.get(i,"count");o=(0,$e.isBN)(u)?u.toNumber():u,Reflect.set(i,"count",o)}return Reflect.get(i,a)},set(i,a,u){return a==="count"&&(o=u),Reflect.set(i,a,u)}});return Uo(n,r,t)}var Ae=R([w("mint"),w("owner"),l("amount"),Ee("delegateOption"),w("delegate"),E("state"),Ee("isNativeOption"),l("isNative"),l("delegatedAmount"),Ee("closeAuthorityOption"),w("closeAuthority")]);function Ni(n){let{mint:e,tokenAccount:t,owner:o}=n;return(0,Re.createInitializeAccountInstruction)(t,e,o)}function Ke(n){let{tokenAccount:e,payer:t,multiSigners:o=[],owner:r}=n;return(0,Re.createCloseAccountInstruction)(e,t,r,o)}async function Me(n){let{connection:e,amount:t,commitment:o,payer:r,owner:i,skipCloseAccount:a}=n,u=await e.getMinimumBalanceForRentExemption(Ae.span,o),c=T(t).add(new $o.default(u)),m=je.Keypair.generate();return{signers:[m],instructions:[je.SystemProgram.createAccount({fromPubkey:r,newAccountPubkey:m.publicKey,lamports:c.toNumber(),space:Ae.span,programId:Re.TOKEN_PROGRAM_ID}),Ni({mint:new je.PublicKey(H.mint),tokenAccount:m.publicKey,owner:i})],endInstructions:a?[]:[Ke({tokenAccount:m.publicKey,payer:r,owner:i})]}}function Ye({source:n,destination:e,owner:t,amount:o,multiSigners:r=[]}){return(0,Re.createTransferInstruction)(n,e,t,T(o).toNumber(),r)}var jo=require("@solana/web3.js"),Yo=Q(require("bn.js"));var vi=M("Raydium_Util");function Jo({solAccountResp:n,tokenAccountResp:e}){let t=[],o=[];for(let{pubkey:r,account:i}of e.value){if(i.data.length!==Ae.span)throw vi.error("invalid token account layout length","publicKey",r.toBase58()),new Error("invalid token account layout length");let a=Ae.decode(i.data),{mint:u,amount:c}=a;t.push({publicKey:r,mint:u,amount:c,isNative:!1}),o.push({pubkey:r,accountInfo:a})}return n&&t.push({mint:jo.PublicKey.default,amount:new Yo.default(n.lamports),isNative:!0}),{tokenAccounts:t,tokenAccountRawInfos:o}}var pt=class extends ie{constructor(t){super(t);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._ataCache=new Map;this._accountListener=[];this._clientOwnedToken=!1;let{tokenAccounts:o,tokenAccountRawInfos:r}=t;this._tokenAccounts=o||[],this._tokenAccountRawInfos=r||[],this._clientOwnedToken=!!(o||r)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}updateTokenAccount({tokenAccounts:t,tokenAccountRawInfos:o}){return t&&(this._tokenAccounts=t),o&&(this._tokenAccountRawInfos=o),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(t){return this._accountListener.push(t),this}removeAccountChangeListener(t){return this._accountListener=this._accountListener.filter(o=>o!==t),this}async getAssociatedTokenAccount(t){this.scope.checkOwner();let o=`${this.scope.ownerPubKey.toBase58()}_${t.toBase58()}`;if(this._ataCache.has(o))return this._ataCache.get(o);let r=await(0,Be.getAssociatedTokenAddress)(t,this.scope.ownerPubKey,!0);return this._ataCache.set(o,r),r}async fetchWalletTokenAccounts(t){if(this._clientOwnedToken||!(t!=null&&t.forceUpdate)&&this._tokenAccounts.length)return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let r=S(S({},{}),t),i=await this.scope.connection.getAccountInfo(this.scope.ownerPubKey,r.commitment),a=await this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Be.TOKEN_PROGRAM_ID},r.commitment),{tokenAccounts:u,tokenAccountRawInfos:c}=Jo({solAccountResp:i,tokenAccountResp:a});return this._tokenAccounts=u,this._tokenAccountRawInfos=c,this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>this.fetchWalletTokenAccounts({forceUpdate:!0}),"confirmed"),{tokenAccounts:u,tokenAccountRawInfos:c}}async getCreatedTokenAccount({mint:t,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:a})=>a==null?void 0:a.equals(t)).sort((a,u)=>a.amount.lt(u.amount)?1:-1),i=await this.getAssociatedTokenAccount(t);for(let a of r){let{publicKey:u}=a;if(u)return o&&i.equals(u),u}}async checkOrCreateAta({mint:t,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:c})=>(c==null?void 0:c.toBase58())===t.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,a={};if(!r){let c=await this.getAssociatedTokenAccount(t),m=await(0,Be.createAssociatedTokenAccountInstruction)(i,c,i,t);a.instructions=[m],r=c}return o&&H.mint===t.toBase58()&&(a.endInstructions=[Ke({owner:i,payer:i,tokenAccount:r})]),{pubKey:r,newInstructions:a}}async handleTokenAccount(t){let{side:o,amount:r,mint:i,tokenAccount:a,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:c,skipCloseAccount:m}=t,d=this.createTxBuilder(),p=await(0,Be.getAssociatedTokenAddress)(i,this.scope.ownerPubKey,!0);if(new Qo.PublicKey(H.mint).equals(i)){let b=await Me({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:r,skipCloseAccount:m});return d.addInstruction(b),S({tokenAccount:b.signers[0].publicKey},b)}else if(!a||o==="out"&&!p.equals(a)&&!c)return{tokenAccount:p,instructions:[(0,Be.createAssociatedTokenAccountInstruction)(this.scope.ownerPubKey,p,this.scope.ownerPubKey,i)]};return{tokenAccount:a}}};var Oe=require("@solana/spl-token"),q=require("@solana/web3.js"),$t=Q(require("bn.js"));var Je=require("@solana/web3.js");var gn=R([E("instruction")]),hn=R([E("instruction")]),Di=R([l("rewardState"),l("rewardOpenTime"),l("rewardEndTime"),l("rewardLastUpdateTime"),l("totalReward"),l("totalRewardEmissioned"),l("rewardClaimed"),l("rewardPerSecond"),z("accRewardPerShare"),w("rewardVault"),w("rewardMint"),w("rewardSender"),l("rewardType"),ee(l(),15,"padding")]),Ei=R([l("state"),l("nonce"),w("lpVault"),w("rewardVault"),w(),w(),l(),l(),l("totalReward"),z("perShareReward"),l("lastSlot"),l("perSlotReward")]),Ki=R([l("state"),l("nonce"),w("lpVault"),w("rewardVaultA"),l("totalRewardA"),z("perShareRewardA"),l("perSlotRewardA"),E("option"),w("rewardVaultB"),dt(7),l("totalRewardB"),z("perShareRewardB"),l("perSlotRewardB"),l("lastSlot"),w()]),Vi=R([l(),l("state"),l("nonce"),l("validRewardTokenNum"),z("rewardMultiplier"),l("rewardPeriodMax"),l("rewardPeriodMin"),l("rewardPeriodExtend"),w("lpMint"),w("lpVault"),ee(Di,5,"rewardInfos"),w("creator"),w(),ee(l(),32,"padding")]),Ho=new Proxy(Ei,{get(n,e,t){return e==="decode"?(...o)=>{let r=n.decode(...o);return O(S({},r),{version:3,rewardInfos:[{rewardVault:r.rewardVault,totalReward:r.totalReward,perSlotReward:r.perSlotReward,perShareReward:r.perShareReward}]})}:Reflect.get(n,e,t)}}),zo=new Proxy(Ki,{get(n,e,t){return e==="decode"?(...o)=>{let r=n.decode(...o);return O(S({},r),{version:5,rewardInfos:[{rewardVault:r.rewardVaultA,totalReward:r.totalRewardA,perSlotReward:r.perSlotRewardA,perShareReward:r.perShareRewardA},{rewardVault:r.rewardVaultB,totalReward:r.totalRewardB,perSlotReward:r.perSlotRewardB,perShareReward:r.perShareRewardB}]})}:Reflect.get(n,e,t)}}),ft=new Proxy(Vi,{get(n,e,t){return e==="decode"?(...o)=>{let r=n.decode(...o);return O(S({},r),{version:6,rewardInfos:r.rewardInfos.map(i=>{var a;return O(S({},i),{rewardType:((a=Object.entries(Ut).find(u=>String(u[1])===i.rewardType.toString()))!=null?a:["Standard SPL"])[0]})})})}:Reflect.get(n,e,t)}}),Ci=R([l("isSet"),l("rewardPerSecond"),l("rewardOpenTime"),l("rewardEndTime"),l("rewardType")]),wn=R([E("instruction"),l("nonce"),ee(Ci,5,"rewardTimeInfo")]),kn=R([E("instruction"),l("rewardReopenTime"),l("rewardEndTime"),l("rewardPerSecond")]),Pn=R([E("instruction"),l("isSet"),l("rewardPerSecond"),l("rewardOpenTime"),l("rewardEndTime")]),ac=R([l("state"),w("id"),w("owner"),l("deposited"),ee(l(),1,"rewardDebts")]),Zo=R([l("state"),w("id"),w("owner"),l("deposited"),ee(z(),1,"rewardDebts"),ee(l(),17)]),sc=R([l("state"),w("id"),w("owner"),l("deposited"),ee(l(),2,"rewardDebts")]),Xo=R([l("state"),w("id"),w("owner"),l("deposited"),ee(z(),2,"rewardDebts"),ee(l(),17)]),er=R([l(),l("state"),w("id"),w("owner"),l("deposited"),ee(z(),5,"rewardDebts"),ee(l(),16)]),bt=R([E("instruction"),l("amount")]);var tr=M("Raydium_farm_config"),nr="EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q",Wi=new Je.PublicKey(nr),or="9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z",Ui=new Je.PublicKey(or),rr="FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG",Gi=new Je.PublicKey(rr),ir={[nr]:3,[or]:5,[rr]:6},ar={3:Wi,5:Ui,6:Gi},sr=new Je.PublicKey("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),ur=new Je.PublicKey("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),cr={3:Ho,5:zo,6:ft},mr={3:Zo,5:Xo,6:er},In=n=>[3,5,6].indexOf(n)!==-1,$i={3:10,5:11,6:1},lr=n=>{let e=$i[n];return e||tr.logWithError("invalid deposit farm version"),e},ji={3:11,5:12,6:2},dr=n=>{let e=ji[n];return e||tr.logWithError("invalid withdraw farm version"),e},pr=n=>{var a;let{version:e,rewardInfos:t,rewardTokenAccountsPublicKeys:o}=n,r=`rewardInfo:${JSON.stringify(t)}, rewardAccount:${JSON.stringify(o)}`,i={3:()=>{if(t.length!==1||o.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${r}`},5:()=>{if(t.length!==o.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${r}`},6:()=>{if(!o.length||t.length!==o.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${r}`}};return(a=i[e])==null?void 0:a.call(i)},Ut={"Standard SPL":0,"Option tokens":1};var Ve=require("@solana/web3.js"),fr=Q(require("bn.js"));var Yi=M("Raydium_farm_instruction");async function br(n){let{version:e,id:t,ledger:o,programId:r,owner:i}=n,a={3:9,5:10}[e];a||Yi.logWithError(`invalid farm pool version: ${e}`);let u=Buffer.alloc(gn.span);gn.encode({instruction:a},u);let c=[s({pubkey:t}),s({pubkey:o}),s({pubkey:i,isWritable:!1}),s({pubkey:Ve.SystemProgram.programId,isWritable:!1}),s({pubkey:Ve.SYSVAR_RENT_PUBKEY,isWritable:!1})];return new Ve.TransactionInstruction({programId:r,keys:c,data:u})}function yr(n){var o;let e=Buffer.alloc(wn.span);wn.encode({instruction:0,nonce:new fr.default(n.nonce),rewardTimeInfo:n.rewardInfoConfig},e);let t=[...De,s({pubkey:n.farmKeyPair.publicKey}),s({pubkey:n.farmAuthority,isWritable:!1}),s({pubkey:n.lpVault}),s({pubkey:n.lpMint,isWritable:!1}),s({pubkey:n.lockVault}),s({pubkey:n.lockMint,isWritable:!1}),s({pubkey:(o=n.lockUserAccount)!=null?o:U}),s({pubkey:n.owner,isWritable:!1,isSigner:!0})];for(let r of n.rewardInfo)t.push(s({pubkey:r.rewardMint,isWritable:!1}),s({pubkey:r.rewardVault}),s({pubkey:r.userRewardToken}));return new Ve.TransactionInstruction({programId:n.programId,keys:t,data:e})}var X=Q(require("bn.js"));var yt=M("Raydium.farm.util");async function Gt({programId:n,poolId:e,mint:t,type:o}){let{publicKey:r}=await Ie([e.toBuffer(),t.toBuffer(),Buffer.from(o==="lpVault"?"lp_vault_associated_seed":o==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],n);return r}function Ji(n){let t=C({publicKey:n}).toBase58();return ir[t]}async function An({programId:n,poolId:e,owner:t}){let{publicKey:o}=await Ie([e.toBuffer(),t.toBuffer(),Buffer.from(Ji(n)===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],n);return o}var gr=async({programId:n,poolId:e})=>await Ie([e.toBuffer()],n);function hr(n){return ar[n]}function wr(n){return{isSet:new X.default(1),rewardPerSecond:T(n.rewardPerSecond),rewardOpenTime:T(n.rewardOpenTime),rewardEndTime:T(n.rewardEndTime),rewardType:T(n.rewardType)}}function Tn(n){return T(n.rewardEndTime).sub(T(n.rewardOpenTime)).mul(T(n.rewardPerSecond))}function Qi(n){let e=mr[n];return e||yt.logWithError("invalid version",n),e}function Hi(n){let e=cr[n];return e||yt.logWithError("invalid version",n),e}function zi(n,e,t,o){if(n.version===3||n.version===5){if(n.lastSlot.gte(new X.default(t)))return n;let r=new X.default(t).sub(n.lastSlot);n.lastSlot=new X.default(t);for(let i of n.rewardInfos){if(e.amount.eq(new X.default(0)))continue;let a=i.perSlotReward.mul(r);i.perShareReward=i.perShareReward.add(a.mul(new X.default(10).pow(new X.default(n.version===3?9:15))).div(e.amount)),i.totalReward=i.totalReward.add(a)}}else if(n.version===6)for(let r of n.rewardInfos){if(r.rewardState.eq(new X.default(0)))continue;let i=X.default.min(new X.default(o),r.rewardEndTime);if(r.rewardOpenTime.gte(i))continue;let u=i.sub(r.rewardLastUpdateTime).mul(r.rewardPerSecond),c=r.totalReward.sub(r.totalRewardEmissioned);c.lt(u)?(u=c,r.rewardLastUpdateTime=r.rewardLastUpdateTime.add(c.div(r.rewardPerSecond))):r.rewardLastUpdateTime=i,!e.amount.eq(new X.default(0))&&(r.accRewardPerShare=r.accRewardPerShare.add(u.mul(n.rewardMultiplier).div(e.amount)),r.totalRewardEmissioned=r.totalRewardEmissioned.add(u))}return n}async function Zi({connection:n,farmPools:e,owner:t,config:o}){var b;let r=!1,i=!1,a=new X.default(10),u=[];for(let f of e){let y=pe(f);y.version===6?i=!0:r=!0,u.push({pubkey:y.id,version:y.version,key:"state",poolId:y.id},{pubkey:y.lpVault,version:y.version,key:"lpVault",poolId:y.id}),t&&u.push({pubkey:await An({programId:y.programId,poolId:y.id,owner:t}),version:y.version,key:"ledger",poolId:y.id})}let c={},m=await qo(n,u,o);for(let{pubkey:f,version:y,key:h,poolId:L,accountInfo:g}of m){let k=L.toBase58();if(c[k]=S({},c[k]),h==="state"){let _=Hi(y);(!g||!g.data||g.data.length!==_.span)&&yt.logWithError(`invalid farm state account info, pools.id, ${f}`),c[k].state=_.decode(g.data)}else if(h==="lpVault")(!g||!g.data||g.data.length!==Ae.span)&&yt.logWithError(`invalid farm lp vault account info, pools.lpVault, ${f}`),c[k].lpVault=Ae.decode(g.data);else if(h==="ledger"){let _=Qi(y);g&&g.data&&(g.data.length!==_.span&&yt.logWithError(`invalid farm ledger account info, ledger, ${f}`),c[k].ledger=_.decode(g.data))}}let d=i||r?await n.getSlot():0,p=i&&(b=await n.getBlockTime(d))!=null?b:0;for(let f of Object.keys(c))c[f].state=zi(c[f].state,c[f].lpVault,d,p);for(let[f,{state:y,ledger:h}]of Object.entries(c))if(h){let L=y.version===6?y.rewardMultiplier:y.rewardInfos.length===1?a.pow(new X.default(9)):a.pow(new X.default(15)),g=y.rewardInfos.map((k,_)=>{let P=h.rewardDebts[_];return h.deposited.mul(y.version===6?k.accRewardPerShare:k.perShareReward).div(L).sub(P)});c[f].wrapped=O(S({},c[f].wrapped),{pendingRewards:g})}return c}async function kr(n){let{farmPools:e}=n,t=await Zi(n);return e.map((r,i)=>O(S(S(S({},e[i]),pe(r)),t[r.id]),{jsonInfo:e[i]}))}function Pr(n,e=Date.now()){if(n.version===6){let t=n.state.rewardInfos;if(t.every(({rewardOpenTime:o})=>lt(e,o.toNumber(),{unit:"s"})))return"upcoming pool";if(t.every(({rewardEndTime:o})=>Ge(e,o.toNumber(),{unit:"s"})))return"closed pool"}else{let t=n.state.rewardInfos.map(({perSlotReward:o})=>o);if(t.length===2){if(String(t[0])==="0"&&String(t[1])!=="0")return"normal fusion pool";if(String(t[0])!=="0"&&String(t[1])!=="0")return"dual fusion pool";if(String(t[0])==="0"&&String(t[1])==="0")return"closed pool"}else if(t.length===1&&String(t[0])==="0")return"closed pool"}}function Ir(n){return n.state.rewardInfos.length===1&&String(n.lpMint)===Nt.toBase58()}function Ar(n,e){return n.version===6?n.state.rewardInfos.map(({rewardPerSecond:t,rewardOpenTime:o,rewardEndTime:r},i)=>{var b;let a=lt(e.currentBlockChainDate,o.toNumber(),{unit:"s"}),u=Ge(e.currentBlockChainDate,r.toNumber(),{unit:"s"});if(a||u)return;let c=e.rewardTokens[i];if(!c)return;let m=e.rewardTokenPrices[i];if(!m)return;let d=it(new A(t,ye).div(ke.pow(new X.default(c.decimals||1))).mul(new X.default(60*60*24*365)),m);return e.tvl?e.tvl.isZero()?ve(0):d.div((b=e.tvl)!=null?b:ye):void 0}):n.state.rewardInfos.map(({perSlotReward:o},r)=>{var m;let i=e.rewardTokens[r];if(!i)return;let a=e.rewardTokenPrices[r];if(!a)return;let u=it(new A(o,ye).div(ke.pow(new X.default(i.decimals||1))).mul(new X.default(e.blockSlotCountForSecond*60*60*24*365)),a);return e.tvl?e.tvl.isZero()?ve(0):u.div((m=e.tvl)!=null?m:ye):void 0})}var gt=class extends ie{constructor(){super(...arguments);this._farmPools=[];this._hydratedFarmPools=[];this._hydratedFarmMap=new Map;this._sdkParsedFarmPools=[];this._lpTokenInfoMap=new Map}async load(t){var r;await this.scope.liquidity.load(t),await this.scope.fetchFarms(t==null?void 0:t.forceUpdate);let o=((r=this.scope.apiData.farmPools)==null?void 0:r.data)||{};this._farmPools=Object.keys(o||{}).reduce((i,a)=>{var u,c;return i.concat(((c=(u=o[a]).map)==null?void 0:c.call(u,m=>{let d=this.scope.token.allTokenMap.get(m.baseMint),p=this.scope.token.allTokenMap.get(m.quoteMint);return d&&p&&this._lpTokenInfoMap.set(m.lpMint,new $({mint:m.lpMint,decimals:d.decimals,symbol:`${d.symbol} - ${p.name}`,name:`${d.symbol} - ${p.name} LP`})),O(S({},m),{name:m.symbol,category:a})}))||[])},[]),await this.fetchSdkFarmInfo()}async fetchSdkFarmInfo(){var t;this._sdkParsedFarmPools=await kr({connection:this.scope.connection,farmPools:this._farmPools,owner:(t=this.scope.owner)==null?void 0:t.publicKey,config:{commitment:"confirmed"}})}async loadHydratedFarmInfo(t){let{forceUpdate:o,skipPrice:r}=t||{};if(this._hydratedFarmPools.length&&!o)return this._hydratedFarmPools;await this.scope.farm.load();try{await this.scope.account.fetchWalletTokenAccounts()}catch{}!r&&await this.scope.token.fetchTokenPrices(),await this.scope.liquidity.loadPairs();let i=await this.scope.chainTimeOffset(),a=ln(Date.now()+i,{minutes:0}),u=await this.scope.api.getBlockSlotCountForSecond(this.scope.connection.rpcEndpoint),c=Object.fromEntries(this.scope.liquidity.allPairs.map(m=>[m.ammId,{apr30d:m.apr30d,apr7d:m.apr7d,apr24h:m.apr24h}]));return this._hydratedFarmPools=this._sdkParsedFarmPools.map(m=>{let d=this.hydrateFarmInfo({farmInfo:m,blockSlotCountForSecond:u,farmAprs:c,currentBlockChainDate:a,chainTimeOffset:i});return this._hydratedFarmMap.set(m.id.toBase58(),d),d}),this._hydratedFarmPools}get allFarms(){return this._farmPools}get allParsedFarms(){return this._sdkParsedFarmPools}get allHydratedFarms(){return this._hydratedFarmPools}get allHydratedFarmMap(){return this._hydratedFarmMap}getFarm(t){let o=C({publicKey:t}),r=this.allFarms.find(i=>i.id===o.toBase58());return r||this.logAndCreateError("invalid farm id"),r}getParsedFarm(t){let o=C({publicKey:t}),r=this.allParsedFarms.find(i=>o.equals(i.id));return r||this.logAndCreateError("invalid farm id"),r}getLpTokenInfo(t){let o=C({publicKey:t}),r=this._lpTokenInfoMap.get(o.toBase58());return r||this.logAndCreateError("LP Token not found",o.toBase58()),r}lpDecimalAmount({mint:t,amount:o}){let r=ce(o),i=this.getLpTokenInfo(t);return Se(new A(r.numerator,r.denominator).mul(new $t.default(10).pow(new $t.default(i.decimals))))}hydrateFarmInfo(t){var St,Lt,Ze,Xe,et,_t,Wn,Un,Gn,$n,jn,Yn;let{farmInfo:o,blockSlotCountForSecond:r,farmAprs:i,currentBlockChainDate:a,chainTimeOffset:u=0}=t,c=Pr(o,a),m=Ir(o),d=c==="dual fusion pool",p=c==="normal fusion pool",b=c==="closed pool"&&!o.upcoming,f=o.version!==6?o.upcoming&&b:o.upcoming,y=o.version!==6&&o.upcoming&&!b,h=((St=this.scope.liquidity.allPools.find(B=>B.lpMint===o.lpMint.toBase58()))==null?void 0:St.version)===5,L=m?this.scope.mintToToken(o.lpMint):this.getLpTokenInfo(o.lpMint),g=this.scope.mintToToken(m?o.lpMint:o.baseMint),k=this.scope.mintToToken(m?o.lpMint:o.quoteMint);g!=null&&g.symbol;let _=m?`${(Lt=g==null?void 0:g.symbol)!=null?Lt:"unknown"}`:`${(Ze=g==null?void 0:g.symbol)!=null?Ze:"unknown"}-${(Xe=k==null?void 0:k.symbol)!=null?Xe:"unknown"}`,P=o.jsonInfo.rewardInfos.map(({rewardMint:B})=>this.scope.mintToToken(B)),N=(et=o.wrapped)==null?void 0:et.pendingRewards.map((B,W)=>P[W]?new F(P[W],Se(Do(B,0))):void 0),v=m?this.scope.token.tokenPrices.get(o.lpMint.toBase58()):this.scope.liquidity.lpPriceMap.get(o.lpMint.toBase58()),D=L&&new F(L,o.lpVault.amount),Y=v&&L?it(new F(L,o.lpVault.amount),v):void 0,K=Ar(o,{tvl:Y,currentBlockChainDate:a,rewardTokens:P,rewardTokenPrices:(_t=o.rewardInfos.map(({rewardMint:B})=>this.scope.token.tokenPrices.get(B.toBase58())))!=null?_t:[],blockSlotCountForSecond:r}),G=(Wn=this.scope.liquidity.allPools.find(B=>B.lpMint===o.lpMint.toBase58()))==null?void 0:Wn.id,te=G?Ft((Un=i[G])==null?void 0:Un.apr7d,{alreadyDecimaled:!0}):void 0,J=G?Ft((Gn=i[G])==null?void 0:Gn.apr30d,{alreadyDecimaled:!0}):void 0,oe=G?Ft(($n=i[G])==null?void 0:$n.apr24h,{alreadyDecimaled:!0}):void 0,ae=K.reduce((B,W)=>B?W?B.add(W):B:W,te),xe=K.reduce((B,W)=>B?W?B.add(W):B:W,J),de=K.reduce((B,W)=>B?W?B.add(W):B:W,oe),he=o.version===6?o.state.rewardInfos.map((B,W)=>{var zn,Zn,Xn,eo;let{rewardOpenTime:tt,rewardEndTime:Rt,rewardPerSecond:zt}=B,Ne=tt.toNumber()?new Date(tt.toNumber()*1e3+u):void 0,we=Rt.toNumber()?new Date(Rt.toNumber()*1e3+u):void 0,Zt=Date.now()+u;if(!Ne&&!we)return;let Ue=this.scope.mintToToken((Xn=(Zn=B.rewardMint)!=null?Zn:(zn=o.rewardInfos[W])==null?void 0:zn.rewardMint)==null?void 0:Xn.toBase58()),Jn=Boolean(Ne&&lt(Zt,Ne)),Qn=Boolean(we&&Ge(Zt,we)),Hn=!Ne&&!we||!Qn&&!Jn,ai=Hn&&Ge(Zt,ln(we,{seconds:-((eo=o.jsonInfo.rewardPeriodExtend)!=null?eo:72*60*60)})),si=Ue&&this.scope.mintToTokenAmount({mint:Ue.mint,amount:vo(B.totalReward,B.totalRewardEmissioned).toFixed(Ue.decimals)}),ui=N==null?void 0:N[W],ci=K[W],mi=Boolean(we),Mt=o.rewardInfos[W];return O(S(S({},Mt),B),{owner:Mt==null?void 0:Mt.rewardSender,apr:ci,token:Ue,userPendingReward:ui,userHavedReward:mi,perSecond:Ue&&this.scope.mintToTokenAmount({mint:Ue.mint,amount:zt}).toSignificant(),openTime:Ne,endTime:we,isOptionToken:B.rewardType==="Option tokens",isRewardBeforeStart:Jn,isRewardEnded:Qn,isRewarding:Hn,isRwardingBeforeEnd72h:ai,claimableRewards:si,version:6})}).filter(B=>!!B):o.state.rewardInfos.map((B,W)=>{let tt=N==null?void 0:N[W],Rt=K[W],zt=P[W],{perSlotReward:Ne}=B,we=Et(tt)||Et(Ne);return O(S({},B),{apr:Rt,token:zt,userPendingReward:tt,userHavedReward:we,version:o.version})}),be=L&&((jn=o.ledger)==null?void 0:jn.deposited)?new F(L,(Yn=o.ledger)==null?void 0:Yn.deposited):void 0;return O(S({},o),{lp:L,lpPrice:v,base:g,quote:k,name:_,isStakePool:m,isDualFusionPool:d,isNormalFusionPool:p,isClosedPool:b,isUpcomingPool:f,isStablePool:h,isNewPool:y,totalApr7d:ae,raydiumFeeApr7d:te,totalApr24h:de,raydiumFeeApr24h:oe,totalApr30d:xe,raydiumFeeApr30d:J,ammId:G,tvl:Y,userHasStaked:Et(be),rewards:he,userStakedLpAmount:be,stakedLpAmount:D})}async _getUserRewardInfo({payer:t,rewardInfo:o}){if(o.rewardMint.equals(U)){let r=await Me({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:t,amount:Tn(o)});return{rewardPubKey:r.signers[0].publicKey,newInstruction:r}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:o.rewardMint})}}async create({poolId:t,rewardInfos:o,payer:r}){this.checkDisabled(),this.scope.checkOwner();let i=C({publicKey:t}),a=this.scope.liquidity.allPools.find(P=>P.id===i.toBase58());a||this.logAndCreateError("invalid pool id");let c={lpMint:new q.PublicKey(a.lpMint),lockInfo:{lockMint:sr,lockVault:ur},version:6,rewardInfos:o,programId:hr(6)},m=this.createTxBuilder(),d=r!=null?r:this.scope.ownerPubKey,p=q.Keypair.generate(),b=await this.scope.connection.getMinimumBalanceForRentExemption(ft.span);m.addInstruction({instructions:[q.SystemProgram.createAccount({fromPubkey:d,newAccountPubkey:p.publicKey,lamports:b,space:ft.span,programId:c.programId})],signers:[p]});let{publicKey:f,nonce:y}=await gr({programId:c.programId,poolId:p.publicKey}),h=await Gt({programId:c.programId,poolId:p.publicKey,mint:c.lpMint,type:"lpVault"}),L=[],g=[];for(let P of c.rewardInfos){P.rewardOpenTime>=P.rewardEndTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",P.rewardOpenTime.toString()),Ut[P.rewardType]||this.logAndCreateError("rewardType error",P.rewardType),P.rewardPerSecond<=0&&this.logAndCreateError("rewardPerSecond error",P.rewardPerSecond.toString()),L.push(wr(P));let{rewardPubKey:N,newInstruction:v}=await this._getUserRewardInfo({rewardInfo:P,payer:d});v&&m.addInstruction(v),N||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let D=P.rewardMint.equals(U)?new q.PublicKey(H.mint):P.rewardMint;g.push({rewardMint:D,rewardVault:await Gt({programId:c.programId,poolId:p.publicKey,mint:D,type:"rewardVault"}),userRewardToken:N})}let k=await this.scope.account.getCreatedTokenAccount({mint:c.lockInfo.lockMint});k||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let _=yr({farmKeyPair:p,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:h,lpMint:c.lpMint,lockVault:c.lockInfo.lockVault,lockMint:c.lockInfo.lockMint,lockUserAccount:k,programId:c.programId,rewardInfo:g,rewardInfoConfig:L,nonce:y});return await m.addInstruction({instructions:[_]}).build()}async restartReward({farmId:t,payer:o,newRewardInfo:r}){let i=this.getFarm(t);i.version!==6&&this.logAndCreateError("invalid farm version",i.version);let a={id:new q.PublicKey(i.id),rewardInfos:i.rewardInfos,lpVault:new q.PublicKey(i.lpVault),programId:new q.PublicKey(i.programId)};r.rewardOpenTime>=r.rewardEndTime&&this.logAndCreateError("start time error","newRewardInfo",r);let u=o||this.scope.ownerPubKey,c=r.rewardMint.equals(U)?new q.PublicKey(H.mint):r.rewardMint,m=a.rewardInfos.find(L=>new q.PublicKey(L.rewardMint).equals(c));m||this.logAndCreateError("configuration does not exist","rewardMint",c);let d=m.rewardVault?new q.PublicKey(m.rewardVault):U,p=this.createTxBuilder(),{rewardPubKey:b,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:r,payer:u});f&&p.addInstruction(f),b||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let y=Buffer.alloc(kn.span);kn.encode({instruction:3,rewardReopenTime:T(r.rewardOpenTime),rewardEndTime:T(r.rewardEndTime),rewardPerSecond:T(r.rewardPerSecond)},y);let h=[s({pubkey:Oe.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:a.id}),s({pubkey:a.lpVault,isWritable:!1}),s({pubkey:d}),s({pubkey:b}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await p.addInstruction({instructions:[new q.TransactionInstruction({programId:a.programId,keys:h,data:y})]}).build()}async addNewRewardToken(t){let{farmId:o,newRewardInfo:r,payer:i}=t,a=this.getFarm(o);a.version!==6&&this.logAndCreateError("invalid farm version",a.version);let u=i!=null?i:this.scope.ownerPubKey,c=this.createTxBuilder(),m=await Gt({programId:new q.PublicKey(a.programId),poolId:new q.PublicKey(a.id),mint:r.rewardMint,type:"rewardVault"}),{rewardPubKey:d,newInstruction:p}=await this._getUserRewardInfo({rewardInfo:r,payer:u});p&&c.addInstruction(p),d||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts);let b=r.rewardMint.equals(U)?new q.PublicKey(H.mint):r.rewardMint,f=Buffer.alloc(Pn.span);Pn.encode({instruction:4,isSet:new $t.default(1),rewardPerSecond:T(r.rewardPerSecond),rewardOpenTime:T(r.rewardOpenTime),rewardEndTime:T(r.rewardEndTime)},f);let y=[...De,s({pubkey:new q.PublicKey(a.id)}),s({pubkey:new q.PublicKey(a.authority),isWritable:!1}),s({pubkey:b,isWritable:!1}),s({pubkey:m}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await c.addInstruction({instructions:[new q.TransactionInstruction({programId:new q.PublicKey(a.programId),keys:y,data:f})]}).build()}async _prepareFarmAccounts(t){let o=this.createTxBuilder(),{farmInfo:r}=t,{pubKey:i,newInstructions:a}=await this.scope.account.checkOrCreateAta({mint:r.lpMint});o.addInstruction(a);let u=await Promise.all(r.rewardInfos.map(async({rewardMint:d})=>{let{pubKey:p,newInstructions:b}=await this.scope.account.checkOrCreateAta({mint:d,autoUnwrapWSOLToSOL:!0});return o.addInstruction(b),p})),c=await An({programId:new q.PublicKey(r.programId),poolId:new q.PublicKey(r.id),owner:this.scope.ownerPubKey});if(!r.ledger&&r.version<6){let d=await br({id:r.id,programId:r.programId,version:r.version,ledger:c,owner:this.scope.ownerPubKey});o.addInstruction({instructions:[d]})}let m=[s({pubkey:r.id}),s({pubkey:r.authority,isWritable:!1}),s({pubkey:c}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:i}),s({pubkey:new q.PublicKey(r.jsonInfo.lpVault)}),s({pubkey:u[0]}),s({pubkey:r.rewardInfos[0].rewardVault}),s({pubkey:q.SYSVAR_CLOCK_PUBKEY,isWritable:!1}),s({pubkey:Oe.TOKEN_PROGRAM_ID,isWritable:!1})];return{txBuilder:o,lpTokenAccount:i,rewardTokenAccountsPublicKeys:u,ledgerAddress:c,lowVersionKeys:m}}async deposit(t){this.scope.checkOwner();let{farmId:o,amount:r}=t,i=this.getParsedFarm(o),a=i.lpMint,{version:u,rewardInfos:c}=i;In(u)||this.logAndCreateError("invalid farm version:",u);let{txBuilder:m,ledgerAddress:d,lpTokenAccount:p,lowVersionKeys:b,rewardTokenAccountsPublicKeys:f}=await this._prepareFarmAccounts({mint:a,farmInfo:i}),y=pr({version:u,rewardInfos:c,rewardTokenAccountsPublicKeys:f});y&&this.logAndCreateError(y);let h=Buffer.alloc(bt.span);bt.encode({instruction:lr(u),amount:T(r)},h);let L=u===6?[s({pubkey:Oe.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:q.SystemProgram.programId,isWritable:!1}),s({pubkey:i.id}),s({pubkey:i.authority,isWritable:!1}),s({pubkey:i.lpVault.mint}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:p})]:b;if(u!==3)for(let k=1;k<c.length;k++)L.push(s({pubkey:f[k]})),L.push(s({pubkey:c[k].rewardVault}));let g=new q.TransactionInstruction({programId:i.programId,keys:L,data:h});return await m.addInstruction({instructions:[g]}).build()}async withdraw(t){this.scope.checkOwner();let{farmId:o,amount:r}=t,i=this.getParsedFarm(o),a=i.lpMint,{version:u,rewardInfos:c}=i;In(u)||this.logAndCreateError("invalid farm version:",u);let{txBuilder:m,ledgerAddress:d,lpTokenAccount:p,lowVersionKeys:b,rewardTokenAccountsPublicKeys:f}=await this._prepareFarmAccounts({mint:a,farmInfo:i}),y=Buffer.alloc(bt.span);bt.encode({instruction:dr(u),amount:T(r)},y);let h=u===6?[s({pubkey:Oe.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:i.id}),s({pubkey:i.authority,isWritable:!1}),s({pubkey:i.lpVault.mint}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:p})]:b;if(u!==3)for(let g=1;g<c.length;g++)h.push(s({pubkey:f[g]})),h.push(s({pubkey:c[g].rewardVault}));let L=new q.TransactionInstruction({programId:i.programId,keys:h,data:y});return await m.addInstruction({instructions:[L]}).build()}async withdrawFarmReward({farmId:t,withdrawMint:o}){var b;this.scope.checkOwner();let r=this.getParsedFarm(t),{version:i}=r;i!==6&&this.logAndCreateError("invalid farm version",r.version);let a=r.rewardInfos.find(f=>f.rewardMint.equals(o.equals(U)?new q.PublicKey(H.mint):o));a||this.logAndCreateError("withdraw mint error","rewardInfos",r);let u=(b=a==null?void 0:a.rewardVault)!=null?b:U,c=this.createTxBuilder(),m;if(this._getUserRewardInfo({payer:this.scope.ownerPubKey,rewardInfo:a}),o.equals(U)){let f=await Me({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:Tn(a)});m=f.signers[0].publicKey,c.addInstruction(f)}else{let f=await this.scope.account.getCreatedTokenAccount({mint:o});f===null?(m=await this.scope.account.getAssociatedTokenAccount(o),c.addInstruction({instructions:[(0,Oe.createAssociatedTokenAccountInstruction)(this.scope.ownerPubKey,m,this.scope.ownerPubKey,o)]})):m=f}let d=Buffer.alloc(hn.span);hn.encode({instruction:5},d);let p=[s({pubkey:Oe.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:r.id}),s({pubkey:r.authority,isWritable:!1}),s({pubkey:r.lpVault.mint,isWritable:!1}),s({pubkey:u}),s({pubkey:m}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await c.addInstruction({instructions:[new q.TransactionInstruction({programId:r.programId,keys:p,data:d})]}).build()}};var Hr=require("@solana/web3.js"),ge=Q(require("bn.js"));var xn=require("@solana/web3.js"),Sn=Q(require("bn.js"));var Tr=new Sn.default(25),xr=new Sn.default(1e4),Sr="675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",Xi=new xn.PublicKey(Sr),Lr="5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h",ea=new xn.PublicKey(Lr),am={[Sr]:4,[Lr]:5},_r={4:Xi,5:ea},Rr={4:3,5:3};var Jt=require("@solana/spl-token"),le=require("@solana/web3.js");var Ln=R([E("instruction"),l("amountIn"),l("minAmountOut")]),_n=R([E("instruction"),l("maxAmountIn"),l("amountOut")]),Rn=R([E("instruction"),E("nonce")]),Mn=R([E("instruction"),E("nonce"),l("startTime")]),ta=R([l("status"),l("nonce"),l("maxOrder"),l("depth"),l("baseDecimal"),l("quoteDecimal"),l("state"),l("resetFlag"),l("minSize"),l("volMaxCutRatio"),l("amountWaveRatio"),l("baseLotSize"),l("quoteLotSize"),l("minPriceMultiplier"),l("maxPriceMultiplier"),l("systemDecimalValue"),l("minSeparateNumerator"),l("minSeparateDenominator"),l("tradeFeeNumerator"),l("tradeFeeDenominator"),l("pnlNumerator"),l("pnlDenominator"),l("swapFeeNumerator"),l("swapFeeDenominator"),l("baseNeedTakePnl"),l("quoteNeedTakePnl"),l("quoteTotalPnl"),l("baseTotalPnl"),z("quoteTotalDeposited"),z("baseTotalDeposited"),z("swapBaseInAmount"),z("swapQuoteOutAmount"),l("swapBase2QuoteFee"),z("swapQuoteInAmount"),z("swapBaseOutAmount"),l("swapQuote2BaseFee"),w("baseVault"),w("quoteVault"),w("baseMint"),w("quoteMint"),w("lpMint"),w("openOrders"),w("marketId"),w("marketProgramId"),w("targetOrders"),w("withdrawQueue"),w("lpVault"),w("owner"),l("lpReserve"),ee(l(),3,"padding")]),mm=R([l("accountType"),l("status"),l("nonce"),l("maxOrder"),l("depth"),l("baseDecimal"),l("quoteDecimal"),l("state"),l("resetFlag"),l("minSize"),l("volMaxCutRatio"),l("amountWaveRatio"),l("baseLotSize"),l("quoteLotSize"),l("minPriceMultiplier"),l("maxPriceMultiplier"),l("systemDecimalsValue"),l("abortTradeFactor"),l("priceTickMultiplier"),l("priceTick"),l("minSeparateNumerator"),l("minSeparateDenominator"),l("tradeFeeNumerator"),l("tradeFeeDenominator"),l("pnlNumerator"),l("pnlDenominator"),l("swapFeeNumerator"),l("swapFeeDenominator"),l("baseNeedTakePnl"),l("quoteNeedTakePnl"),l("quoteTotalPnl"),l("baseTotalPnl"),l("poolOpenTime"),l("punishPcAmount"),l("punishCoinAmount"),l("orderbookToInitTime"),z("swapBaseInAmount"),z("swapQuoteOutAmount"),z("swapQuoteInAmount"),z("swapBaseOutAmount"),l("swapQuote2BaseFee"),l("swapBase2QuoteFee"),w("baseVault"),w("quoteVault"),w("baseMint"),w("quoteMint"),w("lpMint"),w("modelDataAccount"),w("openOrders"),w("marketId"),w("marketProgramId"),w("targetOrders"),w("owner"),ee(l(),64,"padding")]),Bn=R([E("instruction"),l("baseAmountIn"),l("quoteAmountIn"),l("fixedSide")]),On=R([E("instruction"),l("amountIn")]);var Mr=require("@solana/web3.js");var Te=new Mr.PublicKey("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),We=5e4,na=R([l("x"),l("y"),l("price")]),oa=R([l("accountType"),l("status"),l("multiplier"),l("validDataCount"),ee(na,We,"DataElement")]);function ra(n,e){return[0,We-2]}function ia(n){return[0,We-2]}function aa(n){return[0,We-2]}function sa(n,e,t){let[o,r]=ra(e,t),i=o,a=r,u=0,c=e*n.multiplier/t;for(;i<=a;){if(u=Math.floor((a+i)/2),u===0||u>=We-2)return[u,u,!1];let m=n.DataElement[u].x*n.multiplier/n.DataElement[u].y,d=n.DataElement[u-1].x*n.multiplier/n.DataElement[u-1].y,p=n.DataElement[u+1].x*n.multiplier/n.DataElement[u+1].y;if(c===m)return[u,u,!0];if(c===d)return[u-1,u-1,!0];if(c===p)return[u+1,u+1,!0];if(c<d)a=u-1;else{if(c>d&&c<m)return[u-1,u,!0];if(c>m&&c<p)return[u,u+1,!0];i=u+1}}return[u,u,!1]}function Fn(n,e,t){let[o,r,i]=sa(n,e,t);if(!i)return 0;if(o===r){let a=n.DataElement[o].x;return e*n.multiplier/a}else{let a=n.DataElement[o].x,u=n.DataElement[o].y,c=n.DataElement[r].x,m=n.DataElement[r].y,d=t*(c*u-a*m),p=a*d,b=(c-a)*(e*u-a*t)*m,f=p+b;return e*n.multiplier*d/f}}function Ce(n,e,t){return e*n.multiplier/t}function Br(n,e,t){return e*t/n.multiplier}function ua(n,e){let[t,o]=ia(e),r=t,i=o,a=0,u=e;for(;r<i;){if(a=Math.floor((i+r)/2),a<=0||a>We-2)return[a,a,!1];let c=n.DataElement[a].x,m=n.DataElement[a-1].x,d=n.DataElement[a+1].x;if(u===c)return[a,a,!0];if(u===m)return[a-1,a-1,!0];if(u===d)return[a+1,a+1,!0];if(u<m)i=a-1;else{if(u>m&&u<c)return[a-1,a,!0];if(u>c&&u<d)return[a,a+1,!0];r=a+1}}return[a,a,!1]}function ca(n,e){let[t,o]=aa(e),r=t,i=o,a=0,u=e;for(;r<=i;){if(a=Math.floor((i+r)/2),a<=0||a>=We-2)return[a,a,!1];let c=n.DataElement[a].y,m=n.DataElement[a-1].y,d=n.DataElement[a+1].y;if(u===c)return[a,a,!0];if(u===m)return[a-1,a-1,!0];if(u===d)return[a+1,a+1,!0];if(u<d)r=a+1;else{if(u<m&&u>c)return[a-1,a,!0];if(u<c&&u>d)return[a,a+1,!0];i=a-1}}return[a,a,!1]}function Or(n,e,t,o){let r=o?e+t:e-t,[i,a,u]=ua(n,r);if(!u)return[0,0,!1,u];if(i===a)return[n.DataElement[a].price,n.DataElement[a].y,!1,u];{let c=n.DataElement[i].x,m=n.DataElement[a].x,d=n.DataElement[i].price,p=n.DataElement[a].price,b=n.DataElement[i].y,f=n.DataElement[a].y;if(e>=c&&e<=m)return o?[p,f,!0,u]:[d,b,!0,u];{let y,h;return o?(y=d+(p-d)*(e-c)/(m-c),h=b-(r-c)*n.multiplier/p):(y=d+(p-d)*(e-c)/(m-c),h=f+(m-r)*n.multiplier/d),[y,h,!1,u]}}}function ma(n,e,t,o){let r=o?e-t:e+t,[i,a,u]=ca(n,r);if(!u)return[0,0,!1,u];if(i===a)return[n.DataElement[a].price,n.DataElement[a].x,!1,u];{let c=n.DataElement[i].x,m=n.DataElement[a].x,d=n.DataElement[i].price,p=n.DataElement[a].price,b=n.DataElement[i].y,f=n.DataElement[a].y;if(e>=f&&e<=b)return o?[p,m,!0,u]:[d,c,!0,u];{let y,h;return o?(y=d+(p-d)*(b-e)/(b-f),h=c+p*(b-r)/n.multiplier):(y=d+(p-d)*(b-e)/(b-f),h=m-d*(r-f)/n.multiplier),[y,h,!1,u]}}}function la(n,e){let t=Or(n,e,0,!1);return t[3]?t[0]:0}function Fr(n,e,t,o){let r=Fn(n,e,t),i=Ce(n,e,r),a=Ce(n,t,r),u=Ce(n,o,r),c=!0,[m,d,p,b]=Or(n,i,u,c);if(!b)return 0;if(p)return o*n.multiplier/m;{let f=a-d;return Br(n,f,r)}}function qr(n,e,t,o){let r=Fn(n,e,t),i=Ce(n,e,r),a=Ce(n,t,r),u=Ce(n,o,r),c=!1,[m,d,p,b]=ma(n,a,u,c);if(!b)return 0;if(p)return o*m/n.multiplier;{let f=i-d;return Br(n,f,r)}}function da(n){let e=oa.decode(n);return{accountType:e.accountType.toNumber(),status:e.status.toNumber(),multiplier:e.multiplier.toNumber(),validDataCount:e.validDataCount.toNumber(),DataElement:e.DataElement.map(t=>({x:t.x.toNumber(),y:t.y.toNumber(),price:t.price.toNumber()}))}}function Nr(n,e,t,o){let r=la(n,Ce(n,e,Fn(n,e,t)))/n.multiplier;return o?r:1/r}var jt=class{constructor({connection:e}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=e}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let e=await this.connection.getAccountInfo(Te);e&&(this._layoutData=da(e==null?void 0:e.data))}}};var Yt=M("Raydium_liquidity_instruction");function vr(n){let{poolKeys:e,userKeys:t,amountIn:o,amountOut:r,fixedSide:i}=n,{version:a}=e;if(a===4||a===5){let u={poolKeys:e,userKeys:t};if(i==="in")return pa(O(S({},u),{amountIn:o,minAmountOut:r}),a);if(i==="out")return fa(O(S({},u),{maxAmountIn:o,amountOut:r}),a);Yt.logWithError("invalid params","params",n)}throw Yt.logWithError("invalid version","poolKeys.version",a),new Error("invalid version")}function Dr(n){let e=R([E("instruction"),E("simulateType")]),t=Buffer.alloc(e.span);e.encode({instruction:12,simulateType:0},t);let o=[s({pubkey:n.id,isWritable:!1}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders,isWritable:!1}),s({pubkey:n.baseVault,isWritable:!1}),s({pubkey:n.quoteVault,isWritable:!1}),s({pubkey:n.lpMint,isWritable:!1}),s({pubkey:n.marketId,isWritable:!1})];return new le.TransactionInstruction({programId:n.programId,keys:o,data:t})}function pa({poolKeys:n,userKeys:e,amountIn:t,minAmountOut:o},r){let i=Buffer.alloc(Ln.span);Ln.encode({instruction:9,amountIn:T(t),minAmountOut:T(o)},i);let a=[s({pubkey:Jt.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:n.id}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders})];return r===4&&a.push(s({pubkey:n.targetOrders})),a.push(s({pubkey:n.baseVault}),s({pubkey:n.quoteVault})),r===5&&a.push(s({pubkey:Te})),a.push(s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.marketBaseVault}),s({pubkey:n.marketQuoteVault}),s({pubkey:n.marketAuthority,isWritable:!1}),s({pubkey:e.tokenAccountIn}),s({pubkey:e.tokenAccountOut}),s({pubkey:e.owner,isWritable:!1})),new le.TransactionInstruction({programId:n.programId,keys:a,data:i})}function fa({poolKeys:n,userKeys:e,maxAmountIn:t,amountOut:o},r){let i=Buffer.alloc(_n.span);_n.encode({instruction:11,maxAmountIn:T(t),amountOut:T(o)},i);let a=[s({pubkey:le.SystemProgram.programId,isWritable:!1}),s({pubkey:n.id}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders}),s({pubkey:n.targetOrders}),s({pubkey:n.baseVault}),s({pubkey:n.quoteVault})];return r===5&&a.push(s({pubkey:Te})),a.push(s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.marketBaseVault}),s({pubkey:n.marketQuoteVault}),s({pubkey:n.marketAuthority,isWritable:!1}),s({pubkey:e.tokenAccountIn}),s({pubkey:e.tokenAccountOut}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})),new le.TransactionInstruction({programId:n.programId,keys:a,data:i})}function Er(n){let i=n,{owner:e}=i,t=ne(i,["owner"]),o=Buffer.alloc(Rn.span);Rn.encode({instruction:10,nonce:t.nonce},o);let r=[...De,s({pubkey:t.targetOrders}),s({pubkey:t.withdrawQueue}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.lpMint}),s({pubkey:t.baseMint,isWritable:!1}),s({pubkey:t.quoteMint,isWritable:!1}),s({pubkey:t.baseVault}),s({pubkey:t.quoteVault}),s({pubkey:t.lpVault}),s({pubkey:t.marketId,isWritable:!1}),s({pubkey:e,isSigner:!0})];return new le.TransactionInstruction({programId:t.programId,keys:r,data:o})}function Kr(n){let{poolKeys:e,userKeys:t,startTime:o}=n,r=Buffer.alloc(Mn.span);Mn.encode({instruction:0,nonce:e.nonce,startTime:T(o)},r);let i=[...De,s({pubkey:e.id}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.openOrders}),s({pubkey:e.lpMint}),s({pubkey:e.baseMint,isWritable:!1}),s({pubkey:e.quoteMint,isWritable:!1}),s({pubkey:e.baseVault,isWritable:!1}),s({pubkey:e.quoteVault,isWritable:!1}),s({pubkey:e.withdrawQueue}),s({pubkey:e.targetOrders}),s({pubkey:t.lpTokenAccount}),s({pubkey:e.lpVault,isWritable:!1}),s({pubkey:e.marketProgramId,isWritable:!1}),s({pubkey:e.marketId,isWritable:!1}),s({pubkey:t.payer,isSigner:!0})];return new le.TransactionInstruction({programId:e.programId,keys:i,data:r})}function Vr(n){let{poolKeys:e,userKeys:t,baseAmountIn:o,quoteAmountIn:r,fixedSide:i}=n,{version:a}=e;if(a===4||a===5){let u=Buffer.alloc(Bn.span);Bn.encode({instruction:3,baseAmountIn:T(o),quoteAmountIn:T(r),fixedSide:T(i==="base"?0:1)},u);let c=[s({pubkey:Jt.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:e.id}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.openOrders,isWritable:!1}),s({pubkey:e.targetOrders}),s({pubkey:e.lpMint}),s({pubkey:e.baseVault}),s({pubkey:e.quoteVault})];return a===5&&c.push(s({pubkey:Te})),c.push(s({pubkey:e.marketId,isWritable:!1}),s({pubkey:t.baseTokenAccount}),s({pubkey:t.quoteTokenAccount}),s({pubkey:t.lpTokenAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})),new le.TransactionInstruction({programId:e.programId,keys:c,data:u})}return Yt.logWithError("invalid version","poolKeys.version",a),new le.TransactionInstruction({programId:e.programId,keys:[]})}function Cr(n){let{poolKeys:e,userKeys:t,amountIn:o}=n,{version:r}=e;if(r===4||r===5){let i=Buffer.alloc(On.span);On.encode({instruction:4,amountIn:T(o)},i);let a=[s({pubkey:Jt.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:e.id}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.openOrders}),s({pubkey:e.targetOrders}),s({pubkey:e.lpMint}),s({pubkey:e.baseVault}),s({pubkey:e.quoteVault})];return r===5?a.push(s({pubkey:Te})):a.push(s({pubkey:e.withdrawQueue}),s({pubkey:e.lpVault})),a.push(s({pubkey:e.marketProgramId,isWritable:!1}),s({pubkey:e.marketId}),s({pubkey:e.marketBaseVault}),s({pubkey:e.marketQuoteVault}),s({pubkey:e.marketAuthority,isWritable:!1}),s({pubkey:t.lpTokenAccount}),s({pubkey:t.baseTokenAccount}),s({pubkey:t.quoteTokenAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0}),s({pubkey:e.marketEventQueue}),s({pubkey:e.marketBids}),s({pubkey:e.marketAsks})),new le.TransactionInstruction({programId:e.programId,keys:a,data:i})}return Yt.logWithError("invalid version","poolKeys.version",r),new le.TransactionInstruction({programId:e.programId,keys:[]})}var ga=require("@project-serum/serum"),Qe=Q(require("bn.js"));var qn=require("@solana/web3.js");var Nn=M("Raydium_liquidity_serum"),Wr="9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin",ba=new qn.PublicKey(Wr),xm={[Wr]:3},ya={3:ba};function Ur(n){let e=Rr[n];return e||Nn.logWithError("invalid version","version",n),e}function Gr(n){let e=ya[n];return e||Nn.logWithError("invalid version","version",n),e}async function $r({programId:n,marketId:e}){let t=[e.toBuffer()],o=0,r;for(;o<100;){try{let i=t.concat(Buffer.from([o]),Buffer.alloc(7));r=await qn.PublicKey.createProgramAddress(i,n)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}throw Nn.logWithError("unable to find a viable program address nonce","params",{programId:n,marketId:e}),new Error("unable to find a viable program address nonce")}var vn=M("Raydium_liquidity_util");function Dn(n,e){let t=n instanceof F?n.token:$.WSOL,{baseMint:o,quoteMint:r}=e;if(t.mint.equals(o))return"base";if(t.mint.equals(r))return"quote";let i=`liquidity getTokenSide - token not match with pool, params: ${JSON.stringify({token:t.mint,baseMint:o,quoteMint:r})}`;throw console.error(i),new Error(i)}function He(n,e){let{baseMint:t,quoteMint:o}=e;return n.mint.equals(t)||n.mint.equals(o)}function En(n){let{status:e,startTime:t}=n,o=e.toNumber();return{[0]:{swap:!1,addLiquidity:!1,removeLiquidity:!1},[1]:{swap:!0,addLiquidity:!0,removeLiquidity:!0},[2]:{swap:!1,addLiquidity:!1,removeLiquidity:!1},[3]:{swap:!1,addLiquidity:!1,removeLiquidity:!0},[4]:{swap:!1,addLiquidity:!0,removeLiquidity:!0},[5]:{swap:!1,addLiquidity:!0,removeLiquidity:!0},[6]:{swap:!0,addLiquidity:!0,removeLiquidity:!0},[7]:{swap:Date.now()/1e3>=t.toNumber(),addLiquidity:!0,removeLiquidity:!0}}[o]||{swap:!1,addLiquidity:!1,removeLiquidity:!1}}function ha(n){let e=_r[n];return e||vn.logWithError("invalid version","version",n),e}async function Fe({name:n,programId:e,marketId:t}){let{publicKey:o}=await Ie([e.toBuffer(),t.toBuffer(),Buffer.from(n,"utf-8")],e);return o}async function wa({programId:n}){return Ie([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],n)}async function Kn({version:n,marketId:e,baseMint:t,quoteMint:o}){let r=ha(n),[i,a,u]=[C({publicKey:e}),C({publicKey:t,transformSol:!0}),C({publicKey:o,transformSol:!0})],c=await Fe({name:"amm_associated_seed",programId:r,marketId:i}),m=await Fe({name:"lp_mint_associated_seed",programId:r,marketId:i}),{publicKey:d,nonce:p}=await wa({programId:r}),b=await Fe({name:"coin_vault_associated_seed",programId:r,marketId:i}),f=await Fe({name:"pc_vault_associated_seed",programId:r,marketId:i}),y=await Fe({name:"temp_lp_token_associated_seed",programId:r,marketId:i}),h=await Fe({name:"open_order_associated_seed",programId:r,marketId:i}),L=await Fe({name:"target_associated_seed",programId:r,marketId:i}),g=await Fe({name:"withdraw_associated_seed",programId:r,marketId:i}),k=Ur(n),_=Gr(k),{publicKey:P}=await $r({programId:_,marketId:i});return{id:c,baseMint:a,quoteMint:u,lpMint:m,version:n,programId:r,authority:d,nonce:p,baseVault:b,quoteVault:f,lpVault:y,openOrders:h,targetOrders:L,withdrawQueue:g,marketVersion:k,marketProgramId:_,marketId:i,marketAuthority:P}}async function Yr({connection:n,pools:e}){let t=e.map(r=>Dr(r));return(await Mo(n,t,"GetPoolData")).map(r=>{let i=Bo(r,"GetPoolData"),a=new Qe.default(Pe(i,"status")),u=Number(Pe(i,"coin_decimals")),c=Number(Pe(i,"pc_decimals")),m=Number(Pe(i,"lp_decimals")),d=new Qe.default(Pe(i,"pool_coin_amount")),p=new Qe.default(Pe(i,"pool_pc_amount")),b=new Qe.default(Pe(i,"pool_lp_supply")),f="0";try{f=Pe(i,"pool_open_time")}catch{f="0"}return{status:a,baseDecimals:u,quoteDecimals:c,lpDecimals:m,baseReserve:d,quoteReserve:p,lpSupply:b,startTime:new Qe.default(f)}})}function Jr(n,e,t){return ka(n.token,e.token,t)}function ka(n,e,t){let{baseMint:o,quoteMint:r}=t,i=jr(n,t),a=jr(e,t);return i===a&&vn.logWithError("tokens not match with pool","params",{tokenA:n.mint,tokenB:e.mint,baseMint:o,quoteMint:r}),[i,a]}function jr(n,e){let{baseMint:t,quoteMint:o}=e;return n.mint.equals(t)?"base":n.mint.equals(o)?"quote":(vn.logWithError("token not match with pool","params",{token:n.mint,baseMint:t,quoteMint:o}),"base")}var Qr=n=>n==="a"||n==="b";var ht=class extends ie{constructor(t){super(t);this._poolInfos=[];this._poolInfoMap=new Map;this._pairsInfo=[];this._pairsInfoMap=new Map;this._lpTokenMap=new Map;this._lpPriceMap=new Map;this._officialIds=new Set;this._unOfficialIds=new Set;this._sdkParseInfoCache=new Map;this._stableLayout=new jt({connection:this.scope.connection})}async load(t){if(await this.scope.fetchLiquidity(t==null?void 0:t.forceUpdate),!this.scope.apiData.liquidityPools)return;let{data:o}=this.scope.apiData.liquidityPools,[r,i]=[o.official||[],o.unOfficial||[]];this._poolInfos=[...r,...i],this._officialIds=new Set(r.map(a=>{var c,m;let u=`${(c=this.scope.token.allTokenMap.get(a.baseMint))==null?void 0:c.symbol} - ${(m=this.scope.token.allTokenMap.get(a.quoteMint))==null?void 0:m.symbol}`;return this._poolInfoMap.set(a.id,a),this._lpTokenMap.set(a.lpMint,new $({mint:a.lpMint,decimals:a.lpDecimals,symbol:u,name:`${u} LP`})),a.id})),this._unOfficialIds=new Set(i.map(a=>{var c,m;let u=`${(c=this.scope.token.allTokenMap.get(a.baseMint))==null?void 0:c.symbol} - ${(m=this.scope.token.allTokenMap.get(a.quoteMint))==null?void 0:m.symbol}`;return this._poolInfoMap.set(a.id,a),this._lpTokenMap.set(a.lpMint,new $({mint:a.lpMint,decimals:a.lpDecimals,symbol:u,name:`${u} LP`})),a.id}))}async loadPairs(t){var o;return await this.scope.fetchPairs(t==null?void 0:t.forceUpdate),this._pairsInfo=((o=this.scope.apiData.liquidityPairsInfo)==null?void 0:o.data)||[],this._pairsInfoMap=new Map(this._pairsInfo.map(r=>{let i=this._lpTokenMap.get(r.lpMint),a=i&&r.lpPrice?rt({token:i,numberPrice:r.lpPrice,decimalDone:!0}):null;return a&&this._lpPriceMap.set(r.lpMint,a),[r.ammId,r]})),this._pairsInfo}get allPools(){return this._poolInfos}get allPoolIdSet(){return{official:this._officialIds,unOfficial:this._unOfficialIds}}get allPoolMap(){return this._poolInfoMap}get allPairs(){return this._pairsInfo}get allPairsMap(){return this._pairsInfoMap}get lpTokenMap(){return this._lpTokenMap}get lpPriceMap(){return this._lpPriceMap}async fetchMultipleInfo(t){return await this._stableLayout.initStableModelLayout(),await Yr(O(S({},t),{connection:this.scope.connection}))}async sdkParseJsonLiquidityInfo(t){if(!t.length)return[];let o=t.map(r=>r.id).join("-");if(this._sdkParseInfoCache.has(o))return this._sdkParseInfoCache.get(o);try{let i=(await this.fetchMultipleInfo({pools:t.map(pe)})).map((a,u)=>S(S({jsonInfo:t[u]},pe(t[u])),a));return this._sdkParseInfoCache.set(o,i),i}catch(r){return console.error(r),[]}}computeAmountOut({poolKeys:t,poolInfo:o,amountIn:r,outputToken:i,slippage:a}){this.checkDisabled();let u=M("Raydium_computeAmountOut"),c=r.token,m=i;(!He(c,t)||!He(m,t))&&u.logWithError("token not match with pool","poolKeys",t);let{baseReserve:d,quoteReserve:p}=o;this.logDebug("baseReserve:",d.toString(),"quoteReserve:",p.toString());let b=r.token;this.logDebug("inputToken:",b),this.logDebug("amountIn:",r.toFixed()),this.logDebug("outputToken:",i),this.logDebug("slippage:",`${a.toSignificant()}%`);let f=[d,p],y=Dn(r,t);y==="quote"&&f.reverse(),this.logDebug("input side:",y);let[h,L]=f,g;if(t.version===4)g=new Z({baseToken:b,denominator:h,quoteToken:i,numerator:L});else{let J=Nr(this._stableLayout.stableModelData,d.toNumber(),p.toNumber(),!1);g=new Z({baseToken:b,denominator:y==="quote"?new ge.default(J*1e6):new ge.default(1e6),quoteToken:i,numerator:y==="quote"?new ge.default(1e6):new ge.default(J*1e6)})}this.logDebug("currentPrice:",`1 ${b.symbol} \u2248 ${g.toFixed()} ${i.symbol}`),this.logDebug("currentPrice invert:",`1 ${i.symbol} \u2248 ${g.invert().toFixed()} ${b.symbol}`);let k=r.raw,_=ue,P=ue;if(!k.isZero())if(t.version===4){P=k.mul(Tr).div(xr);let J=k.sub(P),oe=h.add(J);_=L.mul(J).div(oe)}else{P=k.mul(new ge.default(2)).div(new ge.default(1e4));let J=k.sub(P),oe=y==="quote"?Fr:qr;_=new ge.default(oe(this._stableLayout.stableModelData,p.toNumber(),d.toNumber(),J.toNumber()))}let v=new re(ye).add(a).invert().mul(_).quotient,D=new F(i,_),Y=new F(i,v);this.logDebug("amountOut:",D.toFixed(),"minAmountOut:",Y.toFixed());let K=new Z({baseToken:b,denominator:k.sub(P),quoteToken:i,numerator:_});!k.isZero()&&!_.isZero()&&(K=new Z({baseToken:b,denominator:k.sub(P),quoteToken:i,numerator:_}),this.logDebug("executionPrice:",`1 ${b.symbol} \u2248 ${K.toFixed()} ${i.symbol}`),this.logDebug("executionPrice invert:",`1 ${i.symbol} \u2248 ${K.invert().toFixed()} ${b.symbol}`));let G=new re(parseInt(String(Math.abs(parseFloat(K.toFixed())-parseFloat(g.toFixed()))*1e9)),parseInt(String(parseFloat(g.toFixed())*1e9))),te=new F(b,P);return{amountOut:D,minAmountOut:Y,currentPrice:g,executionPrice:K,priceImpact:G,fee:te}}async computePairAmount({poolId:t,amount:o,anotherToken:r,slippage:i}){let a=C({publicKey:t}),u=this._poolInfoMap.get(a.toBase58());u||this.logAndCreateError("pool not found",a.toBase58());let c=(await this.sdkParseJsonLiquidityInfo([u]))[0];c||this.logAndCreateError("pool parseInfo not found",a.toBase58());let{baseReserve:m,quoteReserve:d}=c;this.logDebug("baseReserve:",m.toString(),"quoteReserve:",d.toString());let p=o.token;this.logDebug("tokenIn:",p,"amount:",o.toFixed(),"anotherToken:",r,"slippage:",`${i.toSignificant()}%`);let b=Dn(o,pe(u));this.logDebug("input side:",b);let f=ue;o.isZero()||(f=b==="base"?on(o.raw.mul(d),m):on(o.raw.mul(m),d));let h=new re(ye).add(i).mul(f).quotient,L=new F(r,f),g=new F(r,h);return this.logDebug("anotherAmount:",L.toFixed(),"maxAnotherAmount:",g.toFixed()),{anotherAmount:L,maxAnotherAmount:g}}async swapWithAMM(t){let{poolKeys:o,payer:r,amountIn:i,amountOut:a,fixedSide:u,config:c}=t;this.logDebug("amountIn:",i),this.logDebug("amountOut:",a),(i.isZero()||a.isZero())&&this.logAndCreateError("amounts must greater than zero","amounts",{amountIn:i.toFixed(),amountOut:a.toFixed()});let{account:m}=this.scope,d=this.createTxBuilder(),{bypassAssociatedCheck:p=!1}=c||{},[b,f]=[i.token,a.token],y=await m.getCreatedTokenAccount({mint:b.mint,associatedOnly:!1}),h=await m.getCreatedTokenAccount({mint:f.mint}),[L,g]=[i.raw,a.raw],v=await m.handleTokenAccount({side:"in",amount:L,mint:b.mint,tokenAccount:y,bypassAssociatedCheck:p}),{tokenAccount:k}=v,_=ne(v,["tokenAccount"]);d.addInstruction(_);let D=await m.handleTokenAccount({side:"out",amount:0,mint:f.mint,tokenAccount:h,payer:r,bypassAssociatedCheck:p}),{tokenAccount:P}=D,N=ne(D,["tokenAccount"]);return d.addInstruction(N),d.addInstruction({instructions:[vr({poolKeys:o,userKeys:{tokenAccountIn:k,tokenAccountOut:P,owner:this.scope.ownerPubKey},amountIn:L,amountOut:g,fixedSide:u})]}),d.buildMultiTx({extInfo:{amountOut:a}})}async createPool(t){this.checkDisabled(),this.scope.checkOwner(),t.version!==4&&this.logAndCreateError("invalid version","poolKeys.version",t.version);let o=this.createTxBuilder(),r=await Kn(t);return await o.addInstruction({instructions:[Er(O(S({},r),{owner:this.scope.ownerPubKey}))]}).build()}async initPool(t){t.version!==4&&this.logAndCreateError("invalid version","poolKeys.version",t.version);let{baseAmount:o,quoteAmount:r,startTime:i=0,config:a}=t,u=await Kn(t),{baseMint:c,quoteMint:m,lpMint:d,baseVault:p,quoteVault:b}=u,f=this.createTxBuilder(),{account:y}=this.scope,h=!!(a!=null&&a.bypassAssociatedCheck),L=await y.getCreatedTokenAccount({mint:c,associatedOnly:!1}),g=await y.getCreatedTokenAccount({mint:m,associatedOnly:!1});!L&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",y.tokenAccounts);let k=await y.getCreatedTokenAccount({mint:d,associatedOnly:!1}),K=await y.handleTokenAccount({side:"in",amount:o.raw,mint:c,tokenAccount:L,bypassAssociatedCheck:h}),{tokenAccount:_}=K,P=ne(K,["tokenAccount"]);f.addInstruction(P);let G=await y.handleTokenAccount({side:"in",amount:r.raw,mint:m,tokenAccount:g,bypassAssociatedCheck:h}),{tokenAccount:N}=G,v=ne(G,["tokenAccount"]);f.addInstruction(v);let te=await y.handleTokenAccount({side:"out",amount:0,mint:d,tokenAccount:k,bypassAssociatedCheck:h}),{tokenAccount:D}=te,Y=ne(te,["tokenAccount"]);return f.addInstruction(Y),f.addInstruction({instructions:[Ye({source:_,destination:p,owner:this.scope.ownerPubKey,amount:o.raw}),Ye({source:N,destination:b,owner:this.scope.ownerPubKey,amount:r.raw}),Kr({poolKeys:u,userKeys:{lpTokenAccount:D,payer:this.scope.ownerPubKey},startTime:i})]}),await f.build()}async addLiquidity(t){let{poolId:o,amountInA:r,amountInB:i,fixedSide:a,config:u}=t,c=C({publicKey:o}),m=this.allPools.find(_t=>_t.id===c.toBase58());m||this.logAndCreateError("pool not found",o);let p=(await this.sdkParseJsonLiquidityInfo([m]))[0];p||this.logAndCreateError("pool parse error",p),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:b}=this.scope,f=(u==null?void 0:u.bypassAssociatedCheck)||!1,[y,h]=[r.token,i.token],L=await b.getCreatedTokenAccount({mint:y.mint,associatedOnly:!1}),g=await b.getCreatedTokenAccount({mint:h.mint,associatedOnly:!1});!L&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",b.tokenAccounts);let k=await b.getCreatedTokenAccount({mint:p.lpMint}),_=[y,h],P=[L,g],N=[r.raw,i.raw],[v]=Jr(r,i,p),D="base";(!["quote","base"].includes(v)||!Qr(a))&&this.logAndCreateError("invalid fixedSide","fixedSide",a),v==="quote"?(_.reverse(),P.reverse(),N.reverse(),D=a==="a"?"quote":"base"):v==="base"&&(D=a==="a"?"base":"quote");let[Y,K]=_,[G,te]=P,[J,oe]=N,ae=this.createTxBuilder(),Ze=await b.handleTokenAccount({side:"in",amount:J,mint:Y.mint,tokenAccount:G,bypassAssociatedCheck:f}),{tokenAccount:xe}=Ze,de=ne(Ze,["tokenAccount"]);ae.addInstruction(de);let Xe=await b.handleTokenAccount({side:"in",amount:oe,mint:K.mint,tokenAccount:te,bypassAssociatedCheck:f}),{tokenAccount:he}=Xe,be=ne(Xe,["tokenAccount"]);ae.addInstruction(be);let et=await b.handleTokenAccount({side:"out",amount:0,mint:p.lpMint,tokenAccount:k,bypassAssociatedCheck:f}),{tokenAccount:St}=et,Lt=ne(et,["tokenAccount"]);return ae.addInstruction(Lt),ae.addInstruction({instructions:[Vr({poolKeys:p,userKeys:{baseTokenAccount:xe,quoteTokenAccount:he,lpTokenAccount:St,owner:this.scope.ownerPubKey},baseAmountIn:J,quoteAmountIn:oe,fixedSide:D})]}),await ae.build()}async removeLiquidity(t){let{poolId:o,amountIn:r,config:i}=t,a=C({publicKey:o}),u=this.allPools.find(K=>K.id===a.toBase58());u||this.logAndCreateError("pool not found",o);let m=(await this.sdkParseJsonLiquidityInfo([u]))[0];m||this.logAndCreateError("pool pass error",m);let{baseMint:d,quoteMint:p,lpMint:b}=m;this.logDebug("amountIn:",r),r.isZero()&&this.logAndCreateError("amount must greater than zero","amountIn",r.toFixed()),r.token.mint.equals(b)||this.logAndCreateError("amountIn's token not match lpMint","amountIn",r);let{account:f}=this.scope,y=await f.getCreatedTokenAccount({mint:b,associatedOnly:!1});y||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",f.tokenAccounts);let h=await f.getCreatedTokenAccount({mint:d}),L=await f.getCreatedTokenAccount({mint:p}),g=this.createTxBuilder(),k=(i==null?void 0:i.bypassAssociatedCheck)||!1,D=await f.handleTokenAccount({side:"out",amount:0,mint:d,tokenAccount:h,bypassAssociatedCheck:k}),{tokenAccount:_}=D,P=ne(D,["tokenAccount"]);g.addInstruction(P);let Y=await f.handleTokenAccount({side:"out",amount:0,mint:p,tokenAccount:L,bypassAssociatedCheck:k}),{tokenAccount:N}=Y,v=ne(Y,["tokenAccount"]);return g.addInstruction(v),g.addInstruction({instructions:[Hr.ComputeBudgetProgram.requestUnits({units:4e5,additionalFee:0}),Cr({poolKeys:m,userKeys:{lpTokenAccount:y,baseTokenAccount:_,quoteTokenAccount:N,owner:this.scope.ownerPubKey},amountIn:r.raw})]}),await g.build()}lpMintToTokenAmount({poolId:t,amount:o,decimalDone:r}){let i=C({publicKey:t});i||this.logAndCreateError("pool not found");let a=this._poolInfoMap.get(i.toBase58()),u=ce(o),c=new $({mint:a.lpMint,decimals:a.lpDecimals}),m=r?new A(u.numerator,u.denominator):new A(u.numerator,u.denominator).mul(new ge.default(10).pow(new ge.default(c.decimals)));return new F(c,Se(m))}getFixedSide({poolId:t,inputMint:o}){let[r,i]=[C({publicKey:t}),C({publicKey:o})],a=this._poolInfoMap.get(r.toBase58());a||this.logAndCreateError("pool not found",r.toBase58());let u=a.baseMint===i.toBase58();return(i.equals(Le)||i.equals(U))&&(u=!u),u?"a":"b"}};var Vn=require("@solana/web3.js"),Pt=require("lodash");var zr=require("@solana/web3.js");var Pa="routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS",wt=new zr.PublicKey(Pa),Zr=["amm","serum","route"],Xr=[ko,Nt,Le,Io,wo,Ao,To,Po,xo].map(n=>n.toBase58());var kt=require("@solana/spl-token"),ze=require("@solana/web3.js");var Qt=R([E("instruction"),l("amountIn"),l("amountOut")]),Ht=R([E("instruction")]);var Ia=M("Raydium_route_instruction");function ei(n){let{fixedSide:e}=n;if(e==="in")return[Aa(n),Ta(n)];throw Ia.logWithError("invalid params","params",n),new Error(`invalid params, params: ${n}`)}function Aa({fromPoolKeys:n,toPoolKeys:e,userKeys:t,amountIn:o,amountOut:r}){let i=Buffer.alloc(Qt.span),a;return n.version===4?(Qt.encode({instruction:0,amountIn:T(o),amountOut:T(r)},i),a=[s({pubkey:ze.SystemProgram.programId,isWritable:!1}),s({pubkey:kt.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:n.programId,isWritable:!1}),s({pubkey:n.id}),s({pubkey:e.id,isWritable:!1}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders}),s({pubkey:n.baseVault}),s({pubkey:n.quoteVault}),s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.marketBaseVault}),s({pubkey:n.marketQuoteVault}),s({pubkey:n.marketAuthority,isWritable:!1}),s({pubkey:t.inTokenAccount}),s({pubkey:t.middleTokenAccount}),s({pubkey:t.middleStatusAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})]):(Qt.encode({instruction:2,amountIn:T(o),amountOut:T(r)},i),a=[s({pubkey:ze.SystemProgram.programId,isWritable:!1}),s({pubkey:kt.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:n.programId,isWritable:!1}),s({pubkey:n.id}),s({pubkey:e.id,isWritable:!1}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders}),s({pubkey:n.baseVault}),s({pubkey:n.quoteVault}),s({pubkey:Te,isWritable:!1}),s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.id}),s({pubkey:n.id}),s({pubkey:n.id}),s({pubkey:t.inTokenAccount}),s({pubkey:t.middleTokenAccount}),s({pubkey:t.middleStatusAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})]),new ze.TransactionInstruction({programId:wt,keys:a,data:i})}function Ta({fromPoolKeys:n,toPoolKeys:e,userKeys:t}){let o=Buffer.alloc(Ht.span),r;return e.version===4?(Ht.encode({instruction:1},o),r=[s({pubkey:kt.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:e.programId,isWritable:!1}),s({pubkey:n.id,isWritable:!1}),s({pubkey:e.id}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.openOrders}),s({pubkey:e.baseVault}),s({pubkey:e.quoteVault}),s({pubkey:e.marketProgramId,isWritable:!1}),s({pubkey:e.marketId}),s({pubkey:e.marketBids}),s({pubkey:e.marketAsks}),s({pubkey:e.marketEventQueue}),s({pubkey:e.marketBaseVault}),s({pubkey:e.marketQuoteVault}),s({pubkey:e.marketAuthority,isWritable:!1}),s({pubkey:t.middleTokenAccount}),s({pubkey:t.outTokenAccount}),s({pubkey:t.middleStatusAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})]):(Ht.encode({instruction:3},o),r=[s({pubkey:kt.TOKEN_PROGRAM_ID,isWritable:!1}),s({pubkey:e.programId,isWritable:!1}),s({pubkey:n.id,isWritable:!1}),s({pubkey:e.id}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.openOrders}),s({pubkey:e.baseVault}),s({pubkey:e.quoteVault}),s({pubkey:Te,isWritable:!1}),s({pubkey:e.marketProgramId,isWritable:!1}),s({pubkey:e.marketId}),s({pubkey:e.marketBids}),s({pubkey:e.marketAsks}),s({pubkey:e.marketEventQueue}),s({pubkey:e.id}),s({pubkey:e.id}),s({pubkey:e.id}),s({pubkey:t.middleTokenAccount}),s({pubkey:t.outTokenAccount}),s({pubkey:t.middleStatusAccount}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})]),new ze.TransactionInstruction({programId:wt,keys:r,data:o})}async function ti({programId:n,fromPoolId:e,middleMint:t,owner:o}){let{publicKey:r}=await Ie([e.toBuffer(),t.toBuffer(),o.toBuffer()],n);return r}var It=class extends ie{constructor(e){super(e)}computeRouteAmountOut({fromPoolKeys:e,toPoolKeys:t,fromPoolInfo:o,toPoolInfo:r,amountIn:i,outputToken:a,slippage:u}){let{swap:c}=En(o),{swap:m}=En(r);(!c||!m)&&this.logAndCreateError("pools swap not enabled","pools",{fromPoolKeys:e,toPoolKeys:t,fromPoolInfo:o,toPoolInfo:r});let d=i.token,p=a;(!He(d,e)||!He(p,t))&&this.logAndCreateError("pools cannot be routed","pools",{fromPoolKeys:e,toPoolKeys:t});let b=[e.baseMint.toBase58(),e.quoteMint.toBase58()],f=[t.baseMint.toBase58(),t.quoteMint.toBase58()],y=[...b,...f],h=[o.baseDecimals,o.quoteDecimals,r.baseDecimals,r.quoteDecimals],[L,g]=[d.mint.toBase58(),p.mint.toBase58()],k=(0,Pt.xor)(b,f);(k.length!==2||!k.includes(L)||!k.includes(g))&&this.logAndCreateError("xor tokens not match","pools",{fromPoolKeys:e,toPoolKeys:t});let _=(0,Pt.intersection)(b,f);_.length!==1&&this.logAndCreateError("cannot found middle token of two pools","pools",{fromPoolKeys:e,toPoolKeys:t});let P=_[0],N=y.indexOf(P);N===-1&&this.logAndCreateError("cannot found middle token","pools",{fromPoolKeys:e,toPoolKeys:t});let v=h[N],D=new Vn.PublicKey(P),Y=new $({mint:D,decimals:v});this.logInfo("from pool:",e),this.logInfo("to pool:",t),this.logInfo("intersection mints:",_),this.logInfo("xor mints:",k),this.logInfo("middleMint:",P);let{minAmountOut:K,priceImpact:G,fee:te}=this.scope.liquidity.computeAmountOut({poolKeys:e,poolInfo:o,amountIn:i,outputToken:Y,slippage:u}),{amountOut:J,minAmountOut:oe,priceImpact:ae,fee:xe}=this.scope.liquidity.computeAmountOut({poolKeys:t,poolInfo:r,amountIn:K,outputToken:a,slippage:u}),de=null,[he,be]=[i.raw,J.raw];return!he.isZero()&&!be.isZero()&&(de=new Z({baseToken:d,denominator:he,quoteToken:a,numerator:be}),this.logDebug("executionPrice:",`1 ${d.symbol} \u2248 ${de.toFixed()} ${a.symbol}`),this.logDebug("executionPrice invert:",`1 ${a.symbol} \u2248 ${de.invert().toFixed()} ${d.symbol}`)),{amountOut:J,minAmountOut:oe,executionPrice:de,priceImpact:G.add(ae),fee:[te,xe]}}async swapWithRoute(e){let{fromPoolKeys:t,toPoolKeys:o,amountIn:r,amountOut:i,fixedSide:a,config:u}=e;this.logDebug("amountIn:",r,"amountOut:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amounts",{amountIn:r.toFixed(),amountOut:i.toFixed()});let{account:c}=this.scope,{bypassAssociatedCheck:m=!1}=u||{},[d,p]=[r.token,i.token],b=await this.scope.account.getCreatedTokenAccount({mint:d.mint,associatedOnly:!1}),f=await this.scope.account.getCreatedTokenAccount({mint:p.mint}),y=[t.baseMint.toBase58(),t.quoteMint.toBase58()],h=[o.baseMint.toBase58(),o.quoteMint.toBase58()],g=(0,Pt.intersection)(y,h)[0],k=new Vn.PublicKey(g),_=await this.scope.account.getCreatedTokenAccount({mint:k}),[P,N]=[r.raw,i.raw],v=this.createTxBuilder(),D=this.createTxBuilder(),de=await c.handleTokenAccount({side:"in",amount:P,mint:d.mint,tokenAccount:b,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:Y}=de,K=ne(de,["tokenAccount"]);v.addInstruction(K);let he=await c.handleTokenAccount({side:"out",amount:0,mint:p.mint,tokenAccount:f,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:G}=he,te=ne(he,["tokenAccount"]);v.addInstruction(te);let be=await c.handleTokenAccount({side:"in",amount:0,mint:k,tokenAccount:_,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:J}=be,oe=ne(be,["tokenAccount"]);v.addInstruction(oe),D.addInstruction({instructions:ei({fromPoolKeys:t,toPoolKeys:o,userKeys:{inTokenAccount:Y,outTokenAccount:G,middleTokenAccount:J,middleStatusAccount:await ti({programId:wt,fromPoolId:t.id,middleMint:k,owner:this.scope.ownerPubKey}),owner:this.scope.ownerPubKey},amountIn:P,amountOut:N,fixedSide:a})});let ae=v.build();return await D.buildMultiTx({extraPreBuildData:[ae],extInfo:{amountOut:N}})}};var oi=require("@solana/web3.js"),Cn=Q(require("bn.js"));var xa=R([Ee("mintAuthorityOption"),w("mintAuthority"),l("supply"),E("decimals"),E("isInitialized"),Ee("freezeAuthorityOption"),w("freezeAuthority")]);function ni(n,e){return n.sort((t,o)=>{let{official:r,unOfficial:i}=e,a=new Set(r),u=new Set(i),c=p=>a.has(p.mint)?1:u.has(p.mint)?2:3,m=c(t)-c(o),d=p=>!/^[a-zA-Z]/.test(p);if(m===0){let p=d(t.symbol),b=d(o.symbol);return p&&!b?1:!p&&b?-1:t.symbol.localeCompare(o.symbol)}else return m})}var At=class extends ie{constructor(t){super(t);this._tokens=[];this._tokenMap=new Map;this._tokenPrice=new Map;this._mintList={official:[],unOfficial:[],unNamed:[]}}async load(t){this.checkDisabled(),await this.scope.fetchTokens(t==null?void 0:t.forceUpdate),this._mintList={official:[],unOfficial:[],unNamed:[]},this._tokens=[],this._tokenMap=new Map;let{data:o}=this.scope.apiData.tokens||{data:{official:[],unOfficial:[],unNamed:[],blacklist:[]}},r=new Set(o.blacklist);[o.official,o.unOfficial,o.unNamed].forEach((i,a)=>{i.forEach(u=>{let c=["official","unOfficial","unNamed"][a];!r.has(u.mint)&&u.mint!==U.toBase58()&&(this._tokens.push(O(S({},u),{symbol:u.symbol||"",name:u.name||""})),this._mintList[c].push(u.mint))})}),this._mintList.official.push(mt.mint.toBase58()),this._tokens=ni(this._tokens,this._mintList),this._tokens.push(O(S({},mt),{mint:U.toBase58()})),this._tokens.forEach(i=>{this._tokenMap.set(i.mint,O(S({},i),{id:i.mint}))}),this._tokenMap.set(H.mint,O(S({},H),{icon:mt.icon,id:"wsol"})),this._tokenMap.set(U.toBase58(),O(S({},mt),{mint:U.toBase58()}))}get allTokens(){return this._tokens}get allTokenMap(){return this._tokenMap}get tokenMints(){return this._mintList}get tokenPrices(){return this._tokenPrice}async fetchTokenPrices(t){let o=this.allTokens.filter(m=>{var d;return!!((d=m.extensions)!=null&&d.coingeckoId)&&m.mint!==oi.PublicKey.default.toBase58()}),r=o.map(m=>m.extensions.coingeckoId),i=await this.scope.api.getCoingeckoPrice(r),a=o.reduce((m,d)=>i[d.extensions.coingeckoId].usd?O(S({},m),{[d.mint]:rt({token:this._tokenMap.get(d.mint),numberPrice:i[d.extensions.coingeckoId].usd,decimalDone:!0})}):m,{}),u=t||await this.scope.api.getRaydiumTokenPrice(),c=Object.keys(u).reduce((m,d)=>this._tokenMap.get(d)?O(S({},m),{[d]:rt({token:this._tokenMap.get(d),numberPrice:u[d],decimalDone:!0})}):m,{});return this._tokenPrice=new Map([...Object.entries(a),...Object.entries(c)]),this._tokenPrice}mintToToken(t){let o=C({publicKey:t,transformSol:!0}),r=this.allTokenMap.get(o.toBase58());r||this.logAndCreateError("token not found, mint:",o.toBase58());let{decimals:i,name:a,symbol:u}=r;return new $({mint:t,decimals:i,name:a,symbol:u})}mintToTokenAmount({mint:t,amount:o,decimalDone:r}){let i=this.mintToToken(t);return r?new F(i,T(o)):new F(i,this.decimalAmount({mint:t,amount:o,decimalDone:r}))}decimalAmount({mint:t,amount:o}){let r=ce(o),i=this.mintToToken(t);return Se(new A(r.numerator,r.denominator).mul(new Cn.default(10**i.decimals)))}uiAmount({mint:t,amount:o}){let r=ce(o),i=this.mintToToken(t);return i?new A(r.numerator,r.denominator).div(new Cn.default(10**i.decimals)).toSignificant(i.decimals):""}};function ri(n){let e=[];for(let t=0;t<n.length;t++)for(let o=0;o<n.length;o++)t!=o&&e.push([n[t],n[o]]);return e}var Tt=class extends ie{async load(){this.checkDisabled(),await this.scope.fetchLiquidity()}async _getBestSwapPool({availablePools:e,officialPoolIdSet:t}){if(e.length===0)return;if(e.length===1)return e[0];let o=e.filter(a=>t.has(a.id));return o.length===1?o[0]:(await this.scope.liquidity.sdkParseJsonLiquidityInfo(o.length?o:e)).reduce((a,u)=>{let c=a.version===5,m=u.version===5;return c&&!m?a:!c&&m?u:No(mn(a.lpSupply,10**a.lpDecimals),mn(u.lpSupply,10**u.lpDecimals))?a:u}).jsonInfo}async getAvailablePools(e){this.checkDisabled();let{inputMint:t,outputMint:o}=e,[r,i]=[C({publicKey:t,transformSol:!0}).toBase58(),C({publicKey:o,transformSol:!0}).toBase58()],a=this.scope.liquidity.allPools.filter(p=>p.baseMint===r&&p.quoteMint===i||p.baseMint===i&&p.quoteMint===r),u=new Set([...Xr,r,i]),c=new Set(JSON.parse(JSON.stringify([...u])));c.delete(r),c.delete(i);let m=this.scope.liquidity.allPools.filter(p=>{let b=u.has(p.baseMint)&&u.has(p.quoteMint),f=c.has(p.baseMint)&&c.has(p.quoteMint);return b&&!f}),d=await this._getBestSwapPool({availablePools:a,officialPoolIdSet:this.scope.liquidity.allPoolIdSet.official});return{availablePools:a,best:d,routedPools:m}}async getBestAmountOut({pools:e,amountIn:t,inputToken:o,outputToken:r,slippage:i,features:a}){if(this.checkDisabled(),!e){let{routedPools:_}=await this.getAvailablePools({inputMint:o.mint,outputMint:r.mint});e=_}let u=await this.scope.liquidity.sdkParseJsonLiquidityInfo(e||[]),c=(e||[]).map((_,P)=>({poolKeys:pe(_),poolInfo:u[P]})),m=a||Zr;this.logDebug("features:",m),c.length||this.logAndCreateError("please provide at least one source of trade or (inputMint & outputMint)",c);let d=[],p="amm",b=new F(o,t),f=new F(r,0),y=f,h=null,L=null,g=new re(ue),k=[];if(m.includes("amm"))for(let{poolKeys:_,poolInfo:P}of c)try{let{amountOut:N,minAmountOut:v,currentPrice:D,executionPrice:Y,priceImpact:K,fee:G}=this.scope.liquidity.computeAmountOut({poolKeys:_,poolInfo:P,amountIn:b,outputToken:r,slippage:i});N.gt(f)&&(console.log("amm",P),d=[{source:"amm",keys:_}],p="amm",f=N,y=v,h=D,L=Y,g=K,k=[G])}catch{}if(m.includes("route")){let _=ri(c);for(let P of _){if(P.length!==2)continue;let[N,v]=P,{poolKeys:D,poolInfo:Y}=N,{poolKeys:K,poolInfo:G}=v;try{let{amountOut:te,minAmountOut:J,executionPrice:oe,priceImpact:ae,fee:xe}=this.scope.route.computeRouteAmountOut({fromPoolKeys:D,toPoolKeys:K,fromPoolInfo:Y,toPoolInfo:G,amountIn:b,outputToken:r,slippage:i});te.gt(f)&&(d=[{source:"amm",keys:D},{source:"amm",keys:K}],p="route",f=te,y=J,L=oe,g=ae,k=xe)}catch{}}}return{routes:d,routeType:p,amountOut:f,minAmountOut:y,fixedSide:"in",currentPrice:h,executionPrice:L,priceImpact:g,fee:k}}async directSwap(e){this.checkDisabled();let{amountOut:t,amountIn:o,slippage:r,config:i}=e,a=o.token,u=t.token,{routes:c,routeType:m,minAmountOut:d}=await this.getBestAmountOut({inputToken:a,outputToken:u,amountIn:o.raw,slippage:r});return await this.swap({routes:c,routeType:m,amountIn:o,amountOut:d,fixedSide:"in",config:i})}async swap(e){this.checkDisabled(),this.scope.checkOwner();let{routes:t,routeType:o,amountIn:r,amountOut:i,fixedSide:a,config:u}=e;if(o==="amm"&&t.length===1)return await this.scope.liquidity.swapWithAMM({poolKeys:t[0].keys,amountIn:r,amountOut:i,fixedSide:a,config:u});if(o==="route"&&t.length===2)return await this.scope.route.swapWithRoute({fromPoolKeys:t[0].keys,toPoolKeys:t[1].keys,amountIn:r,amountOut:i,fixedSide:a,config:u});throw this.logAndCreateError("invalid routes with routeType","routes",{routeType:o,routes:t}),new Error("invalid routes with routeType")}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let e=this.scope.account.tokenAccounts.filter(t=>t.mint.equals(Le));return e.sort((t,o)=>t.isAssociated?1:o.isAssociated||t.amount.lt(o.amount)?-1:1),e}async unWrapWSol(e){let t=await this.getWSolAccounts(),o=this.createTxBuilder(),r=await Me({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:0});o.addInstruction(r);let i=T(e);for(let a=0;a<t.length;a++)i.gte(t[a].amount)?(o.addInstruction({instructions:[Ke({tokenAccount:t[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),i.sub(t[a].amount)):(o.addInstruction({instructions:[Ke({tokenAccount:t[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),Ye({destination:r.signers[0].publicKey,source:t[a].publicKey,amount:i,owner:this.scope.ownerPubKey}));return o.build()}async wrapWSol(e){let t=await this.getWSolAccounts(),o=this.createTxBuilder(),r=await Me({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:e,skipCloseAccount:!0});return o.addInstruction(r),t.length&&o.addInstruction({instructions:[Ye({destination:t[0].publicKey,source:r.signers[0].publicKey,amount:e,owner:this.scope.ownerPubKey})],endInstructions:[Ke({tokenAccount:r.signers[0].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),o.build()}};var qe={},xt=class{constructor(e){this.rawBalances=new Map;let{connection:t,cluster:o,owner:r,api:i,defaultApiTokens:a,defaultApiLiquidityPools:u,defaultApiFarmPools:c,defaultApiPairsInfo:m,apiCacheTime:d}=e;this._connection=t,this.cluster=o,this._owner=r?new fe(r):void 0,this._signAllTransactions=e.signAllTransactions,this.api=i,this._apiCacheTime=d||5*60*1e3,this.logger=M("Raydium"),this.farm=new gt({scope:this,moduleName:"Raydium_Farm"}),this.account=new pt({scope:this,moduleName:"Raydium_Account",tokenAccounts:e.tokenAccounts,tokenAccountRawInfos:e.tokenAccountRawInfos}),this.liquidity=new ht({scope:this,moduleName:"Raydium_Liquidity"}),this.token=new At({scope:this,moduleName:"Raydium_token"}),this.trade=new Tt({scope:this,moduleName:"Raydium_trade"}),this.route=new It({scope:this,moduleName:"Raydium_route"});let p=new Date().getTime(),[b,f,y,h]=[a?{fetched:p,data:a}:qe.tokens,u?{fetched:p,data:u}:qe.liquidityPools,c?{fetched:p,data:c}:qe.farmPools,m?{fetched:p,data:m}:qe.liquidityPairsInfo];this.apiData=S(S(S(S({},b?{tokens:b}:{}),f?{liquidityPools:f}:{}),y?{farmPools:y}:{}),h?{liquidityPairsInfo:h}:{})}static async load(e){let t=(0,ii.merge)({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},e),{cluster:o,apiRequestTimeout:r}=t,i=new Vt({cluster:o,timeout:r}),a=new xt(O(S({},t),{api:i}));return await a.token.load(),await a.liquidity.load(),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(Ct);return this._owner.publicKey}setOwner(e){return this._owner=e?new fe(e):void 0,this}get connection(){if(!this._connection)throw new Error(Co);return this._connection}setConnection(e){return this._connection=e,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(e){return this._signAllTransactions=e,this}checkOwner(){if(!this.owner)throw this.logger.error(Ct),new Error(Ct)}isCacheInvalidate(e){return new Date().getTime()-e>this._apiCacheTime}async fetchTokens(e){if(this.apiData.tokens&&!this.isCacheInvalidate(this.apiData.tokens.fetched)&&!e)return this.apiData.tokens.data;let t={fetched:Date.now(),data:await this.api.getTokens()};return this.apiData.tokens=t,qe.tokens=t,t.data}async fetchLiquidity(e){if(this.apiData.liquidityPools&&!this.isCacheInvalidate(this.apiData.liquidityPools.fetched)&&!e)return this.apiData.liquidityPools.data;let t={fetched:Date.now(),data:await this.api.getLiquidityPools()};return this.apiData.liquidityPools=t,qe.liquidityPools=t,t.data}async fetchPairs(e){var o;if(this.apiData.liquidityPairsInfo&&!this.isCacheInvalidate(this.apiData.liquidityPairsInfo.fetched)&&!e)return((o=this.apiData.liquidityPairsInfo)==null?void 0:o.data)||[];let t={fetched:Date.now(),data:await this.api.getPairsInfo()};return this.apiData.liquidityPairsInfo=t,qe.liquidityPairsInfo=t,t.data}async fetchFarms(e){if(this.apiData.farmPools&&!this.isCacheInvalidate(this.apiData.farmPools.fetched)&&!e)return this.apiData.farmPools.data;let t={fetched:Date.now(),data:await this.api.getFarmPools()};return this.apiData.farmPools=t,qe.farmPools=t,t.data}async chainTimeOffset(){let e=await this.connection.getBlockTime(await this.connection.getSlot());return e?(e*1e3,Number((e*1e3-Date.now()).toFixed(0))):0}mintToToken(e){return this.token.mintToToken(e)}mintToTokenAmount(e){return this.token.mintToTokenAmount(e)}decimalAmount(e){return this.token.decimalAmount(e)}uiAmount(e){return this.token.uiAmount(e)}};0&&(module.exports={Raydium});
//# sourceMappingURL=raydium.js.map