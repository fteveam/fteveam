{"version":3,"sources":["../../src/raydium/type.ts"],"sourcesContent":["import { Connection, PublicKey, SendOptions, Signer, Transaction } from \"@solana/web3.js\";\n\nimport { ApiTokenCategory, ApiTokenInfo } from \"../api\";\n\nexport interface RaydiumTokenInfo extends ApiTokenInfo {\n  category: ApiTokenCategory;\n}\n\nexport type SignAllTransactions = ((transaction: Transaction[]) => Promise<Transaction[]>) | undefined;\n\nexport interface MakeTransaction {\n  signers: Signer[];\n  transaction: Transaction;\n  execute: () => Promise<string>;\n  extInfo: Record<string, any>;\n}\n\nexport interface MakeMultiTransaction {\n  signers: Signer[][];\n  transactions: Transaction[];\n  execute: () => Promise<string[]>;\n  extInfo: Record<string, any>;\n}\n\nexport interface LoadParams {\n  forceUpdate?: boolean;\n}\n\ntype Primitive = boolean | number | string | null | undefined | PublicKey;\n\n/**\n *\n * @example\n * ```typescript\n * interface A {\n *   keyA: string;\n *   keyB: string;\n *   map: {\n *     hello: string;\n *     i: number;\n *   };\n *   list: (string | number)[];\n *   keyC: number;\n * }\n *\n * type WrappedA = ReplaceType<A, string, boolean> // {\n *   keyA: boolean;\n *   keyB: boolean;\n *   map: {\n *     hello: boolean;\n *     i: number;\n *   };\n *   list: (number | boolean)[];\n *   keyC: number;\n * }\n * ```\n */\nexport type ReplaceType<Old, From, To> = {\n  [T in keyof Old]: Old[T] extends From // to avoid case: Old[T] is an Object,\n    ? Exclude<Old[T], From> | To // when match,  directly replace\n    : Old[T] extends Primitive // judge whether need recursively replace\n    ? From extends Old[T] // it's an Object\n      ? Exclude<Old[T], From> | To // directly replace\n      : Old[T] // stay same\n    : ReplaceType<Old[T], From, To>; // recursively replace\n};\n\nexport type MayArray<T> = T | Array<T>;\n\nexport type MayDeepArray<T> = T | Array<MayDeepArray<T>>;\n\nexport type MayFunction<T, PS extends any[] = []> = T | ((...Params: PS) => T);\n\nexport type ArrayItem<T extends ReadonlyArray<any>> = T extends Array<infer P> ? P : never;\n\nexport type ExactPartial<T, U> = {\n  [P in Extract<keyof T, U>]?: T[P];\n} & {\n  [P in Exclude<keyof T, U>]: T[P];\n};\n\nexport type ExactRequired<T, U> = {\n  [P in Extract<keyof T, U>]-?: T[P];\n} & {\n  [P in Exclude<keyof T, U>]: T[P];\n};\n\n/**\n * extract only string and number\n */\nexport type SKeyof<O> = Extract<keyof O, string>;\n\nexport type GetValue<T, K> = K extends keyof T ? T[K] : undefined;\n/**\n * @example\n * type A = { a: number; b: string; c?: string }\n * type B = { a: string; c: string; d?: boolean }\n *\n * type D = SOR<A, B> // { a: number | string; b: string | undefined; c: string | undefined; d: boolean | undefined } // ! if use SOR, you lost union type guard feature, try NOT to use this trick\n */\nexport type SOR<T, U> = { [K in keyof T | keyof U]: GetValue<T, K> | GetValue<U, K> };\n\nexport type Fallback<T, FallbackT> = T extends undefined ? FallbackT : T;\n\n/**\n * @example\n * type A = { a: number; b: string; c?: string }\n * type B = { a: string; c: string; d?: boolean }\n *\n * type D = Cover<A, B> // { a: string; b: string; c: string; d?: boolean}\n */\nexport type Cover<O, T> = { [K in SKeyof<O> | SKeyof<T>]: Fallback<GetValue<T, K>, GetValue<O, K>> };\n\nexport type UnionCover<O, T> = T extends T ? Cover<O, T> : never;\n\ntype MergeArr<Arr> = (Arr extends (infer T)[] ? T : never)[];\n\n/**\n * typescript type helper function\n * @example\n * type A = { hello: string; version: 3 }[]\n * type B = { hello: string; version: 5 }[]\n * type OK = MergeArr<A | B> // ({ hello: string; version: 3 } | { hello: string; version: 5 })[]\n * type Wrong = A | B // { hello: string; version: 3 }[] | { hello: string; version: 5 }[] // <= this type can't have auto type intelligense of array.map\n */\nexport const unionArr = <T>(arr: T): MergeArr<T> => arr as unknown as MergeArr<T>;\n"],"mappings":"AA6HO,GAAM,GAAW,AAAI,GAAwB","names":[]}