{"version":3,"sources":["../../../src/raydium/token/util.ts","../../../src/common/pubKey.ts","../../../src/marshmallow/index.ts","../../../src/marshmallow/buffer-layout.ts","../../../src/raydium/token/layout.ts"],"sourcesContent":["import { Connection } from \"@solana/web3.js\";\n\nimport { ApiTokenInfo } from \"../../api/type\";\nimport { PublicKeyish, validateAndParsePublicKey } from \"../../common/pubKey\";\nimport { GetStructureSchema } from \"../../marshmallow\";\n\nimport { SPL_MINT_LAYOUT } from \"./layout\";\nimport { TokenJson } from \"./type\";\n\nexport function sortTokens(tokens: TokenJson[], mintList: { official: string[]; unOfficial: string[] }): TokenJson[] {\n  return tokens.sort((tokenA, tokenB) => {\n    const { official, unOfficial } = mintList;\n    const officialMintSet = new Set(official);\n    const unOfficialMintSet = new Set(unOfficial);\n\n    const getPriority = (token: ApiTokenInfo): number =>\n      officialMintSet.has(token.mint) ? 1 : unOfficialMintSet.has(token.mint) ? 2 : 3;\n    const priorityOrderDiff = getPriority(tokenA) - getPriority(tokenB);\n    const startWithLetter = (s: string): boolean => !/^[a-zA-Z]/.test(s);\n    if (priorityOrderDiff === 0) {\n      const startWithLetterA = startWithLetter(tokenA.symbol);\n      const startWithLetterB = startWithLetter(tokenB.symbol);\n      if (startWithLetterA && !startWithLetterB) return 1;\n      if (!startWithLetterA && startWithLetterB) return -1;\n      return tokenA.symbol.localeCompare(tokenB.symbol);\n    } else {\n      return priorityOrderDiff;\n    }\n  });\n}\n\nexport async function getSPLTokenInfo(\n  connection: Connection,\n  mintish: PublicKeyish,\n): Promise<GetStructureSchema<typeof SPL_MINT_LAYOUT> | undefined> {\n  try {\n    if (!connection) return;\n    const tokenAccount = await connection.getAccountInfo(validateAndParsePublicKey({ publicKey: mintish }));\n    if (!tokenAccount) return;\n    if (tokenAccount.data.length !== SPL_MINT_LAYOUT.span) return;\n    return SPL_MINT_LAYOUT.decode(tokenAccount.data);\n  } catch {\n    return;\n  }\n}\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { AccountMeta, PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\n\ninterface AccountMetaProps {\n  pubkey: PublicKey;\n  isSigner?: boolean;\n  isWritable?: boolean;\n}\n\nexport function accountMeta({ pubkey, isSigner = false, isWritable = true }: AccountMetaProps): AccountMeta {\n  return {\n    pubkey,\n    isWritable,\n    isSigner,\n  };\n}\n\nexport const commonSystemAccountMeta = [\n  accountMeta({ pubkey: TOKEN_PROGRAM_ID, isWritable: false }),\n  accountMeta({ pubkey: SystemProgram.programId, isWritable: false }),\n  accountMeta({ pubkey: SYSVAR_RENT_PUBKEY, isWritable: false }),\n];\n\nexport type PublicKeyish = PublicKey | string;\n\nexport function validateAndParsePublicKey({\n  publicKey,\n  transformSol,\n}: {\n  publicKey: PublicKeyish;\n  transformSol?: boolean;\n}): PublicKey {\n  if (publicKey instanceof PublicKey) {\n    if (transformSol && publicKey.equals(SOLMint)) return WSOLMint;\n    return publicKey;\n  }\n\n  if (transformSol && publicKey === SOLMint.toBase58()) return WSOLMint;\n\n  if (typeof publicKey === \"string\") {\n    try {\n      const key = new PublicKey(publicKey);\n      return key;\n    } catch {\n      throw new Error(\"invalid public key\");\n    }\n  }\n\n  throw new Error(\"invalid public key\");\n}\n\nexport function tryParsePublicKey(v: string): PublicKey | string {\n  try {\n    return new PublicKey(v);\n  } catch (e) {\n    return v;\n  }\n}\n\nexport const RAYMint = new PublicKey(\"4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R\");\nexport const PAIMint = new PublicKey(\"Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS\");\nexport const SRMMint = new PublicKey(\"SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt\");\nexport const USDCMint = new PublicKey(\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\");\nexport const USDTMint = new PublicKey(\"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB\");\nexport const mSOLMint = new PublicKey(\"mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So\");\nexport const stSOLMint = new PublicKey(\"7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj\");\nexport const USDHMint = new PublicKey(\"USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX\");\nexport const NRVMint = new PublicKey(\"NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa\");\nexport const ANAMint = new PublicKey(\"ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo\");\nexport const ETHMint = new PublicKey(\"7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs\");\nexport const WSOLMint = new PublicKey(\"So11111111111111111111111111111111111111112\");\nexport const SOLMint = PublicKey.default;\n","import { PublicKey } from \"@solana/web3.js\";\nimport BN, { isBN } from \"bn.js\";\n\nimport {\n  bits, blob, Blob, Layout, offset as _offset, seq as _seq, Structure as _Structure, u32 as _u32, u8 as _u8, UInt,\n  union as _union, Union as _Union,\n} from \"./buffer-layout\";\n\nexport * from \"./buffer-layout\";\nexport { blob };\n\nexport class BNLayout<P extends string = \"\"> extends Layout<BN, P> {\n  blob: Layout<Buffer>;\n  signed: boolean;\n\n  constructor(span: number, signed: boolean, property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends, but it desn't matter\n    super(span, property);\n    this.blob = blob(span);\n    this.signed = signed;\n  }\n\n  /** @override */\n  decode(b: Buffer, offset = 0): BN {\n    const num = new BN(this.blob.decode(b, offset), 10, \"le\");\n    if (this.signed) {\n      return num.fromTwos(this.span * 8).clone();\n    }\n    return num;\n  }\n\n  /** @override */\n  encode(src: BN, b: Buffer, offset = 0): number {\n    if (typeof src === \"number\") src = new BN(src); // src will pass a number accidently in union\n    if (this.signed) {\n      src = src.toTwos(this.span * 8);\n    }\n    return this.blob.encode(src.toArrayLike(Buffer, \"le\", this.span), b, offset);\n  }\n}\n\nexport class WideBits<P extends string = \"\"> extends Layout<Record<string, boolean>, P> {\n  _lower: any;\n  _upper: any;\n  // TODO: unknown\n  constructor(property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\n    super(8, property);\n    this._lower = bits(_u32(), false);\n    this._upper = bits(_u32(), false);\n  }\n\n  addBoolean(property: string): void {\n    if (this._lower.fields.length < 32) {\n      this._lower.addBoolean(property);\n    } else {\n      this._upper.addBoolean(property);\n    }\n  }\n\n  decode(b: Buffer, offset = 0): Record<string, boolean> {\n    const lowerDecoded = this._lower.decode(b, offset);\n    const upperDecoded = this._upper.decode(b, offset + this._lower.span);\n    return { ...lowerDecoded, ...upperDecoded };\n  }\n\n  encode(src: any /* TEMP */, b: Buffer, offset = 0):any {\n    return this._lower.encode(src, b, offset) + this._upper.encode(src, b, offset + this._lower.span);\n  }\n}\n\nexport function u8<P extends string = \"\">(property?: P): UInt<number, P> {\n  return new UInt(1, property);\n}\n\nexport function u32<P extends string = \"\">(property?: P): UInt<number, P> {\n  return new UInt(4, property);\n}\n\nexport function u64<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(8, false, property);\n}\n\nexport function u128<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(16, false, property);\n}\n\nexport function i64<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(8, true, property);\n}\n\nexport function i128<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(16, true, property);\n}\n\nexport class WrappedLayout<T, U, P extends string = \"\"> extends Layout<U, P> {\n  layout: Layout<T>;\n  decoder: (data: T) => U;\n  encoder: (src: U) => T;\n\n  constructor(layout: Layout<T>, decoder: (data: T) => U, encoder: (src: U) => T, property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\n    super(layout.span, property);\n    this.layout = layout;\n    this.decoder = decoder;\n    this.encoder = encoder;\n  }\n\n  decode(b: Buffer, offset?: number): U {\n    return this.decoder(this.layout.decode(b, offset));\n  }\n\n  encode(src: U, b: Buffer, offset?: number): number {\n    return this.layout.encode(this.encoder(src), b, offset);\n  }\n\n  getSpan(b: Buffer, offset?: number): number {\n    return this.layout.getSpan(b, offset);\n  }\n}\n\nexport function publicKey<P extends string = \"\">(property?: P): Layout<PublicKey, P> {\n  return new WrappedLayout(\n    blob(32),\n    (b: Buffer) => new PublicKey(b),\n    (key: PublicKey) => key.toBuffer(),\n    property,\n  );\n}\n\nexport class OptionLayout<T, P> extends Layout<T | null, P> {\n  layout: Layout<T>;\n  discriminator: Layout<number>;\n\n  constructor(layout: Layout<T>, property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\n    super(-1, property);\n    this.layout = layout;\n    this.discriminator = _u8();\n  }\n\n  encode(src: T | null, b: Buffer, offset = 0): number {\n    if (src === null || src === undefined) {\n      return this.discriminator.encode(0, b, offset);\n    }\n    this.discriminator.encode(1, b, offset);\n    return this.layout.encode(src, b, offset + 1) + 1;\n  }\n\n  decode(b: Buffer, offset = 0): T | null {\n    const discriminator = this.discriminator.decode(b, offset);\n    if (discriminator === 0) {\n      return null;\n    } else if (discriminator === 1) {\n      return this.layout.decode(b, offset + 1);\n    }\n    throw new Error(\"Invalid option \" + this.property);\n  }\n\n  getSpan(b: Buffer, offset = 0): number {\n    const discriminator = this.discriminator.decode(b, offset);\n    if (discriminator === 0) {\n      return 1;\n    } else if (discriminator === 1) {\n      return this.layout.getSpan(b, offset + 1) + 1;\n    }\n    throw new Error(\"Invalid option \" + this.property);\n  }\n}\n\nexport function option<T, P extends string = \"\">(layout: Layout<T>, property?: P): Layout<T | null, P> {\n  return new OptionLayout<T, P>(layout, property);\n}\n\nexport function bool<P extends string = \"\">(property?: P): Layout<boolean, P> {\n  return new WrappedLayout(_u8(), decodeBool, encodeBool, property);\n}\n\nexport function decodeBool(value: number): boolean {\n  if (value === 0) {\n    return false;\n  } else if (value === 1) {\n    return true;\n  }\n  throw new Error(\"Invalid bool: \" + value);\n}\n\nexport function encodeBool(value: boolean): number {\n  return value ? 1 : 0;\n}\n\nexport function vec<T, P extends string = \"\">(elementLayout: Layout<T>, property?: P): Layout<T[], P> {\n  const length = _u32(\"length\");\n  const layout: Layout<{ values: T[] }> = struct([\n    length,\n    seq(elementLayout, _offset(length, -length.span), \"values\"),\n  ]) as any; // Something I don't know\n  return new WrappedLayout(\n    layout,\n    ({ values }) => values,\n    (values) => ({ values }),\n    property,\n  );\n}\n\nexport function tagged<T, P extends string = \"\">(tag: BN, layout: Layout<T>, property?: P): Layout<T, P> {\n  const wrappedLayout: Layout<{ tag: BN; data: T }> = struct([u64(\"tag\"), layout.replicate(\"data\")]) as any; // Something I don't know\n\n  function decodeTag({ tag: receivedTag, data }: { tag: BN; data: T }): T {\n    if (!receivedTag.eq(tag)) {\n      throw new Error(\"Invalid tag, expected: \" + tag.toString(\"hex\") + \", got: \" + receivedTag.toString(\"hex\"));\n    }\n    return data;\n  }\n\n  return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);\n}\n\nexport function vecU8<P extends string = \"\">(property?: P): Layout<Buffer, P> {\n  const length = _u32(\"length\");\n  const layout: Layout<{ data: Buffer }> = struct([length, blob(_offset(length, -length.span), \"data\")]) as any; // Something I don't know\n  return new WrappedLayout(\n    layout,\n    ({ data }) => data,\n    (data) => ({ data }),\n    property,\n  );\n}\n\nexport function str<P extends string = \"\">(property?: P): Layout<string, P> {\n  return new WrappedLayout(\n    vecU8(),\n    (data) => data.toString(\"utf-8\"),\n    (s) => Buffer.from(s, \"utf-8\"),\n    property,\n  );\n}\n\nexport interface EnumLayout<T, P extends string = \"\"> extends Layout<T, P> {\n  registry: Record<string, Layout<any>>;\n}\n\nexport function rustEnum<T, P extends string = \"\">(variants: Layout<any>[], property?: P): EnumLayout<T, P> {\n  const unionLayout = _union(_u8(), property);\n  variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));\n  return unionLayout as any; // ?why use UnionLayout? This must be a fault\n}\n\nexport function array<T, P extends string = \"\">(\n  elementLayout: Layout<T>,\n  length: number,\n  property?: P,\n): Layout<T[], P> {\n  const layout = struct([seq(elementLayout, length, \"values\")]) as any as Layout<{ values: T[] }>; // Something I don't know\n  return new WrappedLayout(\n    layout,\n    ({ values }) => values,\n    (values) => ({ values }),\n    property,\n  );\n}\n\nexport class Structure<T, P, D> extends _Structure<T, P, D> {\n  /** @override */\n  decode(b: Buffer, offset?: number): D {\n    return super.decode(b, offset);\n  }\n}\n\nexport function struct<T, P extends string = \"\">(\n  fields: T,\n  property?: P,\n  decodePrefixes?: boolean,\n): T extends Layout<infer Value, infer Property>[]\n  ? Structure<\n      Value,\n      P,\n      {\n        [K in Exclude<Extract<Property, string>, \"\">]: Extract<T[number], Layout<any, K>> extends Layout<infer V, any>\n          ? V\n          : any;\n      }\n    >\n  : any {\n  //@ts-expect-error this type is not quite satisfied the define, but, never no need to worry about.\n  return new Structure(fields, property, decodePrefixes);\n}\n\nexport type GetLayoutSchemaFromStructure<T extends Structure<any, any, any>> = T extends Structure<any, any, infer S>\n  ? S\n  : any;\nexport type GetStructureFromLayoutSchema<S> = Structure<any, any, S>;\n\nexport class Union<Schema> extends _Union<Schema> {\n  encodeInstruction(instruction: any): Buffer {\n    const instructionMaxSpan = Math.max(...Object.values(this.registry).map((r) => r.span));\n    const b = Buffer.alloc(instructionMaxSpan);\n    return b.slice(0, this.encode(instruction, b));\n  }\n\n  decodeInstruction(instruction: any):Partial<Schema> {\n    return this.decode(instruction);\n  }\n}\nexport function union<UnionSchema extends { [key: string]: any } = any>(\n  discr: any,\n  defaultLayout?: any,\n  property?: string,\n): Union<UnionSchema> {\n  return new Union(discr, defaultLayout, property);\n}\n\nclass Zeros extends Blob {\n  decode(b: Buffer, offset: number):Buffer {\n    const slice = super.decode(b, offset);\n    if (!slice.every((v) => v === 0)) {\n      throw new Error(\"nonzero padding bytes\");\n    }\n    return slice;\n  }\n}\n\nexport function zeros(length: number):Zeros {\n  return new Zeros(length);\n}\n\nexport function seq<T, P extends string = \"\", AnotherP extends string = \"\">(\n  elementLayout: Layout<T, P>,\n  count: number | BN | Layout<BN | number, P>,\n  property?: AnotherP,\n): Layout<T[], AnotherP> {\n  let parsedCount: number;\n  const superCount =\n    typeof count === \"number\"\n      ? count\n      : isBN(count)\n      ? count.toNumber()\n      : new Proxy(count as unknown as Layout<number> /* pretend to be Layout<number> */, {\n          get(target, property):any {\n            if (!parsedCount) {\n              // get count in targetLayout. note that count may be BN\n              const countProperty = Reflect.get(target, \"count\");\n\n              // let targetLayout's  property:count be a number\n              parsedCount = isBN(countProperty) ? countProperty.toNumber() : countProperty;\n\n              // record the count\n              Reflect.set(target, \"count\", parsedCount);\n            }\n            return Reflect.get(target, property);\n          },\n          set(target, property, value):any {\n            if (property === \"count\") {\n              parsedCount = value;\n            }\n            return Reflect.set(target, property, value);\n          },\n        });\n\n  // @ts-expect-error force type\n  return _seq(elementLayout, superCount, property);\n}\n","import {\n  bits as _bits, BitStructure as _BitStructure, blob as _blob, Blob as _Blob, cstr as _cstr, f32 as _f32,\n  f32be as _f32be, f64 as _f64, f64be as _f64be, greedy as _greedy, Layout as _Layout, ns64 as _ns64, ns64be as _ns64be,\n  nu64 as _nu64, nu64be as _nu64be, offset as _offset, s16 as _s16, s16be as _s16be, s24 as _s24, s24be as _s24be,\n  s32 as _s32, s32be as _s32be, s40 as _s40, s40be as _s40be, s48 as _s48, s48be as _s48be, s8 as _s8, seq as _seq,\n  struct as _struct, Structure as _Structure, u16 as _u16, u16be as _u16be, u24 as _u24, u24be as _u24be, u32 as _u32,\n  u32be as _u32be, u40 as _u40, u40be as _u40be, u48 as _u48, u48be as _u48be, u8 as _u8, UInt as _UInt,\n  union as _union, Union as _Union, unionLayoutDiscriminator as _unionLayoutDiscriminator, utf8 as _utf8,\n} from \"@solana/buffer-layout\";\n\n//#region ------------------- Layout -------------------\nexport interface Layout<T = any, P = \"\"> {\n  span: number;\n  property?: P;\n  decode(b: Buffer, offset?: number): T;\n  encode(src: T, b: Buffer, offset?: number): number;\n  getSpan(b: Buffer, offset?: number): number;\n  replicate<AP extends string>(name: AP): Layout<T, AP>;\n}\nexport interface LayoutConstructor {\n  new <T, P>(): Layout<T, P>; // for class extends syntex\n  new <T, P>(span?: T, property?: P): Layout<T, P>;\n  readonly prototype: Layout;\n}\nexport const Layout = _Layout as unknown as LayoutConstructor;\n//#endregion\n\n//#region ------------------- Structure -------------------\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface Structure<T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>\n  extends Layout<DecodeSchema, P> {\n  span: number;\n  decode(b: Buffer, offset?: number): DecodeSchema;\n  layoutFor<AP extends string>(property: AP): Layout<DecodeSchema[AP]>;\n  offsetOf<AP extends string>(property: AP): number;\n}\ninterface StructureConstructor {\n  new <T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>(): Structure<T, P, DecodeSchema>;\n  new <T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>(\n    fields: T,\n    property?: P,\n    decodePrefixes?: boolean,\n  ): Structure<T, P, DecodeSchema>;\n}\nexport const Structure = _Structure as unknown as StructureConstructor;\n//#endregion\n\n//#region ------------------- Union -------------------\nexport interface Union<UnionSchema extends { [key: string]: any } = any> extends Layout {\n  registry: object;\n  decode(b: Buffer, offset?: number): Partial<UnionSchema>;\n  addVariant(\n    variant: number,\n    layout: Structure<any, any, Partial<UnionSchema>> | Layout<any, keyof UnionSchema>,\n    property?: string,\n  ): any /* TEMP: code in Layout.js 1809 */;\n}\ninterface UnionConstructor {\n  new <UnionSchema extends { [key: string]: any } = any>(): Union<UnionSchema>;\n  new <UnionSchema extends { [key: string]: any } = any>(\n    discr: Layout<any, any>,\n    defaultLayout: Layout<any, any>,\n    property?: string,\n  ): Union<UnionSchema>;\n}\nexport const Union = _Union as unknown as UnionConstructor;\n//#endregion\n\n//#region ------------------- BitStructure -------------------\nexport type BitStructure<T = unknown /* TEMP */, P = \"\"> = Layout<T, P>;\ninterface BitStructureConstructor {\n  new (...params: any[]): BitStructure;\n}\nexport const BitStructure = _BitStructure as BitStructureConstructor;\n//#endregion\n\n//#region ------------------- UInt -------------------\nexport type UInt<T = any, P = \"\"> = Layout<T, P>;\ninterface UIntConstructor {\n  new <T, P>(span?: T, property?: P): UInt<T, P>;\n}\nexport const UInt = _UInt as UIntConstructor;\n//#endregion\n\n//#region ------------------- Blob -------------------\nexport type Blob<P extends string = \"\"> = Layout<Buffer, P>;\ninterface BlobConstructor {\n  new (...params: ConstructorParameters<LayoutConstructor>): Blob;\n}\nexport const Blob = _Blob as unknown as BlobConstructor;\n//#endregion\n\nexport const greedy = _greedy as <P extends string = \"\">(elementSpan?: number, property?: P) => Layout<number, P>;\nexport const u8 = _u8 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u16 = _u16 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u24 = _u24 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u32 = _u32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u40 = _u40 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u48 = _u48 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const nu64 = _nu64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u16be = _u16be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u24be = _u24be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u32be = _u32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u40be = _u40be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u48be = _u48be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const nu64be = _nu64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s8 = _s8 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s16 = _s16 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s24 = _s24 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s32 = _s32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s40 = _s40 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s48 = _s48 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const ns64 = _ns64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s16be = _s16be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s24be = _s24be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s32be = _s32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s40be = _s40be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s48be = _s48be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const ns64be = _ns64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f32 = _f32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f32be = _f32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f64 = _f64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f64be = _f64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const struct = _struct as <T, P extends string = \"\">(\n  fields: T,\n  property?: P,\n  decodePrefixes?: boolean,\n) => T extends Layout<infer Value, infer Property>[]\n  ? Structure<\n      Value,\n      P,\n      {\n        [K in Exclude<Extract<Property, string>, \"\">]: Extract<T[number], Layout<any, K>> extends Layout<infer V, any>\n          ? V\n          : any;\n      }\n    >\n  : any;\n\nexport const seq = _seq as unknown as <T, P>(\n  elementLayout: Layout<T, string>,\n  count: number | Layout<number, string>,\n  property?: P,\n) => Layout<T[]>;\nexport const union = _union as <UnionSchema extends { [key: string]: any } = any>(\n  discr: Layout<any, any>,\n  defaultLayout?: any,\n  property?: string,\n) => Union<UnionSchema>;\nexport const unionLayoutDiscriminator = _unionLayoutDiscriminator as <P extends string = \"\">(\n  layout: Layout<any, P>,\n  property?: P,\n) => any;\nexport const blob = _blob as unknown as <P extends string = \"\">(length: number | Layout<number, P>, property?: P) => Blob<P>;\nexport const cstr = _cstr as <P extends string = \"\">(property?: P) => Layout<string, P>;\nexport const utf8 = _utf8 as <P extends string = \"\">(maxSpan: number, property?: P) => Layout<string, P>;\nexport const bits = _bits as unknown as <T, P extends string = \"\">(\n  word: Layout<T>,\n  msb?: boolean,\n  property?: P,\n) => BitStructure<T, P>; // TODO: not quite sure\nexport const offset = _offset as unknown as <T, P extends string = \"\">(\n  layout: Layout<T, P>,\n  offset?: number,\n  property?: P,\n) => Layout<T, P>;\n\nexport type GetStructureSchema<T extends Structure> = T extends Structure<any, any, infer S> ? S : unknown;\n","import { publicKey, struct, u32, u64, u8 } from \"../../marshmallow\";\n\nexport const SPL_MINT_LAYOUT = struct([\n  u32(\"mintAuthorityOption\"),\n  publicKey(\"mintAuthority\"),\n  u64(\"supply\"),\n  u8(\"decimals\"),\n  u8(\"isInitialized\"),\n  u32(\"freezeAuthorityOption\"),\n  publicKey(\"freezeAuthority\"),\n]);\n\nexport type SplMintLayout = typeof SPL_MINT_LAYOUT;\n"],"mappings":"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","names":[]}