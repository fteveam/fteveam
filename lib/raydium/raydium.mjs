var Gr=Object.defineProperty,$r=Object.defineProperties;var jr=Object.getOwnPropertyDescriptors;var gt=Object.getOwnPropertySymbols;var Kn=Object.prototype.hasOwnProperty,Vn=Object.prototype.propertyIsEnumerable;var En=(n,t,e)=>t in n?Gr(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,S=(n,t)=>{for(var e in t||(t={}))Kn.call(t,e)&&En(n,e,t[e]);if(gt)for(var e of gt(t))Vn.call(t,e)&&En(n,e,t[e]);return n},O=(n,t)=>$r(n,jr(t));var ee=(n,t)=>{var e={};for(var o in n)Kn.call(n,o)&&t.indexOf(o)<0&&(e[o]=n[o]);if(n!=null&&gt)for(var o of gt(n))t.indexOf(o)<0&&Vn.call(n,o)&&(e[o]=n[o]);return e};import{merge as ja}from"lodash";import xi from"axios";import{get as Cn,set as Yr}from"lodash";import Jr from"pino";import Qr from"pino-pretty";var Wn={},Hr={},zr=Qr({colorize:!0,levelFirst:!0,translateTime:"SYS:yyyymmdd HH:MM:ss.l"}),Zr=Jr({base:null,level:"silent"},zr);function M(n){let t=Cn(Wn,n);if(!t){let e=Cn(Hr,n);t=Zr.child({name:n},{level:e}),Yr(Wn,n,t)}return t.logWithError=(...e)=>{let o=e.map(r=>typeof r=="object"?JSON.stringify(r):r).join(", ");throw new Error(o)},t}import{PublicKey as fi}from"@solana/web3.js";import bi from"bn.js";import ai from"big.js";import It from"bn.js";import K from"bn.js";var ht=M("Raydium_bignumber");var ae=new K(0),pe=new K(1),os=new K(2),rs=new K(3),is=new K(5),ye=new K(10),$n=new K(100),as=new K(1e3),ss=new K(1e4),Un=9007199254740991;function x(n){if(n instanceof K)return n;if(typeof n=="string"){if(n.match(/^-?[0-9]+$/))return new K(n);ht.logWithError(`invalid BigNumberish string: ${n}`)}return typeof n=="number"?(n%1&&ht.logWithError(`BigNumberish number underflow: ${n}`),(n>=Un||n<=-Un)&&ht.logWithError(`BigNumberish number overflow: ${n}`),new K(String(n))):typeof n=="bigint"?new K(n.toString()):(ht.logWithError(`invalid BigNumberish value: ${n}`),new K(0))}function Ct(n){return ye.pow(x(n))}function se(n){var u;if(n===void 0)return{denominator:"1",numerator:"0"};if(n instanceof K)return{numerator:n.toString(),denominator:"1"};if(n instanceof T)return{denominator:n.denominator.toString(),numerator:n.numerator.toString()};let t=String(n),[,e="",o="",r=""]=(u=t.replace(",","").match(/(-?)(\d*)\.?(\d*)/))!=null?u:[],i="1"+"0".repeat(r.length),a=e+(o==="0"?"":o)+r||"0";return{denominator:i,numerator:a,sign:e,int:o,dec:r}}function Wt(n,t){let e=n.divmod(t);return e.mod.isZero()?e.div:e.div.negative!==0?e.div.isubn(1):e.div.iaddn(1)}function Xr(n){var o;let[,t="",e=""]=(o=n.toFixed(2).match(/(-?)(\d*)\.?(\d*)/))!=null?o:[];return`${t}${e}`}function Te(n,t=0){return n instanceof K?n:new K(Xr(Be(n).mul(ye.pow(new K(String(t))))))}function Be(n){if(n instanceof oe)return new T(n.numerator,n.denominator);if(n instanceof Q)return n.adjusted;if(n instanceof F)try{return Be(n.toExact())}catch{return new T(ae)}if(n instanceof T)return n;let t=String(n),e=se(t);return new T(e.numerator,e.denominator)}function wt(n,t){let{numerator:e,denominator:o}=se(n);return new oe(new K(e),new K(o).mul(t!=null&&t.alreadyDecimaled?new K(100):new K(1)))}function $e(n){let{token:t,numberPrice:e,decimalDone:o}=n,r=new G({mint:"",decimals:6,symbol:"usd",name:"usd",skipMint:!0}),{numerator:i,denominator:a}=se(e),u=o?new K(i).mul(ye.pow(new K(t.decimals))):i,c=new K(a).mul(ye.pow(new K(r.decimals)));return new Q({baseToken:r,denominator:c.toString(),quoteToken:new G(O(S({},t),{skipMint:!0,mint:""})),numerator:u.toString()})}function jn(n,t){if(n==null||t==null)return;let e=Be(n),o=Be(t);return e.mul(o)}function Gn(n){let t=new G({mint:"",decimals:6,symbol:"usd",name:"usd",skipMint:!0}),e=Te(jn(n,10**t.decimals));return new F(t,e)}function je(n,t){return Gn(!t||!n?0:jn(n,t))}import ei from"toformat";var ti=ei,Ye=ti;import Pt from"big.js";import oi from"decimal.js-light";var kt=M("module/fraction"),Ut=Ye(Pt),Je=Ye(oi),ri={[0]:Je.ROUND_DOWN,[1]:Je.ROUND_HALF_UP,[2]:Je.ROUND_UP},ii={[0]:Pt.roundDown,[1]:Pt.roundHalfUp,[2]:Pt.roundUp},T=class{constructor(t,e=pe){this.numerator=x(t),this.denominator=x(e)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new T(this.denominator,this.numerator)}add(t){let e=t instanceof T?t:new T(x(t));return this.denominator.eq(e.denominator)?new T(this.numerator.add(e.numerator),this.denominator):new T(this.numerator.mul(e.denominator).add(e.numerator.mul(this.denominator)),this.denominator.mul(e.denominator))}sub(t){let e=t instanceof T?t:new T(x(t));return this.denominator.eq(e.denominator)?new T(this.numerator.sub(e.numerator),this.denominator):new T(this.numerator.mul(e.denominator).sub(e.numerator.mul(this.denominator)),this.denominator.mul(e.denominator))}mul(t){let e=t instanceof T?t:new T(x(t));return new T(this.numerator.mul(e.numerator),this.denominator.mul(e.denominator))}div(t){let e=t instanceof T?t:new T(x(t));return new T(this.numerator.mul(e.denominator),this.denominator.mul(e.numerator))}toSignificant(t,e={groupSeparator:""},o=1){Number.isInteger(t)||kt.logWithError(`${t} is not an integer.`),t<=0&&kt.logWithError(`${t} is not positive.`),Je.set({precision:t+1,rounding:ri[o]});let r=new Je(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(t);return r.toFormat(r.decimalPlaces(),e)}toFixed(t,e={groupSeparator:""},o=1){return Number.isInteger(t)||kt.logWithError(`${t} is not an integer.`),t<0&&kt.logWithError(`${t} is negative.`),Ut.DP=t,Ut.RM=ii[o]||1,new Ut(this.numerator.toString()).div(this.denominator.toString()).toFormat(t,e)}isZero(){return this.numerator.isZero()}};var si=M("Raydium_amount"),Yn=Ye(ai);function ui(n,t){let e="0",o="0";if(n.includes(".")){let r=n.split(".");r.length===2?([e,o]=r,o=o.padEnd(t,"0")):si.logWithError(`invalid number string, num: ${n}`)}else e=n;return[e,o.slice(0,t)||o]}var F=class extends T{constructor(e,o,r=!0,i){let a=new It(0),u=ye.pow(new It(e.decimals));if(r)a=x(o);else{let c=new It(0),m=new It(0);if(typeof o=="string"||typeof o=="number"||typeof o=="bigint"){let[d,p]=ui(o.toString(),e.decimals);c=x(d),m=x(p)}c=c.mul(u),a=c.add(m)}super(a,u);this.logger=M(i||"Amount"),this.token=e}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(e){return this.token.equals(e.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(e.raw)}lt(e){return this.token.equals(e.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(e.raw)}add(e){return this.token.equals(e.token)||this.logger.logWithError("add token not equals"),new F(this.token,this.raw.add(e.raw))}subtract(e){return this.token.equals(e.token)||this.logger.logWithError("sub token not equals"),new F(this.token,this.raw.sub(e.raw))}toSignificant(e=this.token.decimals,o,r=0){return super.toSignificant(e,o,r)}toFixed(e=this.token.decimals,o,r=0){return e>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(e,o,r)}toExact(e={groupSeparator:""}){return Yn.DP=this.token.decimals,new Yn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e)}};import{PublicKey as ci}from"@solana/web3.js";var Jn={symbol:"SOL",name:"Solana",decimals:9},Y={symbol:"WSOL",name:"Wrapped SOL",mint:"So11111111111111111111111111111111111111112",decimals:9,extensions:{coingeckoId:"solana"}},Qe={isQuantumSOL:!0,isLp:!1,official:!0,mint:new ci(Y.mint),decimals:9,symbol:"SOL",id:"sol",name:"solana",icon:"https://img.raydium.io/icon/So11111111111111111111111111111111111111112.png",extensions:{coingeckoId:"solana"}};import{PublicKey as Gt}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as mi}from"@solana/spl-token";import{PublicKey as te,SystemProgram as li,SYSVAR_RENT_PUBKEY as di}from"@solana/web3.js";function s({pubkey:n,isSigner:t=!1,isWritable:e=!0}){return{pubkey:n,isWritable:e,isSigner:t}}var Oe=[s({pubkey:mi,isWritable:!1}),s({pubkey:li.programId,isWritable:!1}),s({pubkey:di,isWritable:!1})];function V({publicKey:n,transformSol:t}){if(n instanceof te)return t&&n.equals(W)?xe:n;if(t&&n===W.toBase58())return xe;if(typeof n=="string")try{return new te(n)}catch{throw new Error("invalid public key")}throw new Error("invalid public key")}function Qn(n){try{return new te(n)}catch{return n}}var At=new te("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Hn=new te("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),qs=new te("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),zn=new te("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),Zn=new te("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),Xn=new te("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),eo=new te("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),to=new te("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),Ns=new te("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),Ds=new te("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),no=new te("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),xe=new te("So11111111111111111111111111111111111111112"),W=te.default;var $t=class{constructor({mint:t,decimals:e,symbol:o="UNKNOWN",name:r="UNKNOWN",skipMint:i=!1}){if(t===W.toBase58()||t instanceof Gt&&W.equals(t)){this.decimals=Y.decimals,this.symbol=Y.symbol,this.name=Y.name,this.mint=new Gt(Y.mint);return}this.decimals=e,this.symbol=o,this.name=r,this.mint=i?Gt.default:V({publicKey:t})}equals(t){return this===t?!0:this.mint.equals(t.mint)}},G=$t;G.WSOL=new $t(Y);var Yt=class{constructor({decimals:t,symbol:e="UNKNOWN",name:o="UNKNOWN"}){this.decimals=t,this.symbol=e,this.name=o}equals(t){return this===t}},jt=Yt;jt.SOL=new Yt(Jn);var oo=new T($n),oe=class extends T{toSignificant(t=5,e,o){return this.mul(oo).toSignificant(t,e,o)}toFixed(t=2,e,o){return this.mul(oo).toFixed(t,e,o)}};var pi=M("Raydium_price"),Q=class extends T{constructor(e){let{baseToken:o,quoteToken:r,numerator:i,denominator:a}=e;super(i,a);this.baseToken=o,this.quoteToken=r,this.scalar=new T(Ct(o.decimals),Ct(r.decimals))}get raw(){return new T(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Q({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(e){this.quoteToken!==e.baseToken&&pi.logWithError("mul token not equals");let o=super.mul(e);return new Q({baseToken:this.baseToken,quoteToken:e.quoteToken,denominator:o.denominator,numerator:o.numerator})}toSignificant(e=this.quoteToken.decimals,o,r){return this.adjusted.toSignificant(e,o,r)}toFixed(e=this.quoteToken.decimals,o,r){return this.adjusted.toFixed(e,o,r)}};var yi=[G,F,fi,T,bi,Q,oe];function gi(n){return typeof n=="object"&&n!==null&&!yi.some(t=>typeof t=="object"&&n instanceof t)}function me(n){return typeof n=="string"?Qn(n):Array.isArray(n)?n.map(t=>me(t)):gi(n)?Object.fromEntries(Object.entries(n).map(([t,e])=>[t,me(e)])):n}import{PACKET_DATA_SIZE as hi,PublicKey as ao,sendAndConfirmTransaction as ro,Transaction as Tt}from"@solana/web3.js";var Se=M("Raydium_txTool"),xt=class{constructor(t){this.instructions=[];this.endInstructions=[];this.signers=[];this.connection=t.connection,this.feePayer=t.feePayer,this.signAllTransactions=t.signAllTransactions,this.owner=t.owner}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers}}get allInstructions(){return[...this.instructions,...this.endInstructions]}addInstruction({instructions:t=[],endInstructions:e=[],signers:o=[]}){return this.instructions.push(...t),this.endInstructions.push(...e),this.signers.push(...o),this}build(t){let e=new Tt;return this.allInstructions.length&&e.add(...this.allInstructions),e.feePayer=this.feePayer,{transaction:e,signers:this.signers,execute:async()=>{var r;let o=await io(this.connection);if(e.recentBlockhash=o,(r=this.owner)!=null&&r.isKeyPair)return ro(this.connection,e,this.signers);if(this.signAllTransactions){this.signers.length&&e.partialSign(...this.signers);let i=await this.signAllTransactions([e]);return await this.connection.sendRawTransaction(i[0].serialize(),{skipPreflight:!0})}throw new Error("please connect wallet first")},extInfo:t||{}}}buildMultiTx(t){let{extraPreBuildData:e=[],extInfo:o}=t,{transaction:r}=this.build(o),i=e.filter(c=>c.transaction.instructions.length>0),a=[...i.map(c=>c.transaction),r],u=[...i.map(c=>c.signers),this.signers];return{transactions:a,signers:u,execute:async()=>{var m;let c=await io(this.connection);if((m=this.owner)!=null&&m.isKeyPair)return await Promise.all(a.map(async(d,p)=>(d.recentBlockhash=c,await ro(this.connection,d,u[p]))));if(this.signAllTransactions){let d=a.map((f,y)=>(f.recentBlockhash=c,u[y].length&&f.partialSign(...u[y]),f)),p=await this.signAllTransactions(d),b=[];for(let f=0;f<p.length;f+=1){let y=await this.connection.sendRawTransaction(p[f].serialize(),{skipPreflight:!0});b.push(y)}return b}throw new Error("please connect wallet first")},extInfo:o||{}}}};async function io(n){var t,e;try{return((e=await((t=n.getLatestBlockhash)==null?void 0:t.call(n)))==null?void 0:e.blockhash)||(await n.getRecentBlockhash()).blockhash}catch{return(await n.getRecentBlockhash()).blockhash}}function wi(n,t){n.length<1&&Se.logWithError(`no instructions provided: ${n.toString()}`),t.length<1&&Se.logWithError(`no signers provided:, ${t.toString()}`);let e=new Tt;e.recentBlockhash="11111111111111111111111111111111",e.feePayer=t[0],e.add(...n);let o=e.compileMessage().serialize();return t.length+t.length*64+o.length}async function so(n,t,e){let o=new ao("RaydiumSimuLateTransaction11111111111111111"),r=[],i=new Tt;i.feePayer=o;for(let c of t)wi([...i.instructions,c],[o])>hi&&(r.push(i),i=new Tt,i.feePayer=o),i.add(c);i.instructions.length>0&&r.push(i);let a=[];try{a=await Promise.all(r.map(c=>n.simulateTransaction(c)))}catch(c){c instanceof Error&&Se.logWithError(`failed to simulate for instructions, RPC_ERROR, ${c.message}`)}let u=[];for(let c of a){let{value:m}=c;if(Se.debug(`simulate result: ${JSON.stringify(c)}`),m.logs){let d=m.logs.filter(p=>p&&p.includes(e));Se.debug(`filteredLog: ${JSON.stringify(u)}`),d.length||Se.logWithError(` "simulate log not match keyword, keyword: ${e}`),u.push(...d)}}return u}function uo(n,t){let e=n.match(/{["\w:,]+}/g);return!e||e.length!==1?Se.logWithError(`simulate log fail to match json, keyword: ${t}`):e[0]}function ge(n,t){let o=new RegExp(`"${t}":(\\d+)`,"g").exec(n);return!o||o.length!==2?Se.logWithError(`simulate log fail to match key", key: ${t}`):o[1]}async function he(n,t){let[e,o]=await ao.findProgramAddress(n,t);return{publicKey:e,nonce:o}}var le=class{constructor(t){this._owner=t}get publicKey(){return le.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return le.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return le.isKeyPair(this._owner)}get isPublicKey(){return le.isPublicKey(this._owner)}static isKeyPair(t){return t.secretKey!==void 0}static isPublicKey(t){return!le.isKeyPair(t)}};function co(n,t=1,e=[]){let o=[...n];if(t<=0)return e;for(;o.length;)e.push(o.splice(0,t));return e}import{PublicKey as ki}from"@solana/web3.js";var Jt=M("Raydium_accountInfo_util");async function Pi(n,t,e){let{batchRequest:o,commitment:r}=S({batchRequest:!1},e),i=co(t,100),a=new Array(i.length).fill([]);if(o){let u=i.map(m=>{let d=n._buildArgs([m.map(p=>p.toBase58())],r,"base64");return{methodName:"getMultipleAccounts",args:d}});a=(await n._rpcBatchRequest(u)).map(m=>(m.error&&Jt.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(d=>{if(d){let{data:p,executable:b,lamports:f,owner:y,rentEpoch:h}=d;return p.length!==2&&p[1]!=="base64"&&Jt.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(p[0],"base64"),executable:b,lamports:f,owner:new ki(y),rentEpoch:h}}return null})))}else try{a=await Promise.all(i.map(u=>n.getMultipleAccountsInfo(u,r)))}catch(u){u instanceof Error&&Jt.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return a.flat()}async function mo(n,t,e){let o=await Pi(n,t.map(r=>r.pubkey),e);return t.map((r,i)=>O(S({},r),{accountInfo:o[i]}))}function ue(n){if(n instanceof oe)return new T(n.numerator,n.denominator);if(n instanceof Q)return n.adjusted;if(n instanceof F)try{return ue(n.toExact())}catch{return new T(ae)}if(n instanceof T)return n;let t=String(n),e=se(t);return new T(e.numerator,e.denominator)}function Ii(n,t){if(n==null||t==null)return!1;let e=ue(n),o=ue(t);return e.sub(o).numerator.gt(ae)}function lo(n,t){if(n==null||t==null)return!1;let e=ue(n),o=ue(t);return e.sub(o).numerator.gte(ae)}function Ai(n,t){if(n==null||t==null)return!1;let e=ue(n),o=ue(t);return e.sub(o).numerator.eq(ae)}function Qt(n,t){if(n==null||t==null)return;let e=ue(n),o=ue(t);try{return e.div(o)}catch{return e}}function po(n,t){if(n==null||t==null)return;let e=ue(n),o=ue(t);return e.sub(o)}function St(n){return n==null?!1:!Ai(n,0)}function fo(n,t){return Ii(t,n)?t:n}var bo=n=>typeof n=="number",yo=n=>n?new Date(n):new Date,Ti=n=>yo(n).getTime();function He(n,t,e){let o=bo(t)?t*((e==null?void 0:e.unit)==="s"?1e3:1):t;return new Date(n).getTime()<=o}function Ee(n,t,e){let o=bo(t)?t*((e==null?void 0:e.unit)==="s"?1e3:1):t;return new Date(n).getTime()>o}function Ht(n,t){let o=Ti(n)+(t.days?t.days*24*60*60*1e3:0)+(t.hours?t.hours*60*60*1e3:0)+(t.minutes?t.minutes*60*1e3:0)+(t.seconds?t.seconds*1e3:0)+(t.milliseconds?t.milliseconds:0);return yo(o)}var Lt=M("Raydium_Api");var _t=class{constructor({cluster:t,timeout:e}){this.cluster=t,this.api=xi.create({baseURL:"https://api.raydium.io/v2",timeout:e}),this.api.interceptors.request.use(o=>{let{method:r,baseURL:i,url:a}=o;return Lt.debug(`${r==null?void 0:r.toUpperCase()} ${i}${a}`),o},o=>(Lt.error("Request failed"),Promise.reject(o))),this.api.interceptors.response.use(o=>{let{config:r,data:i,status:a}=o,{method:u,baseURL:c,url:m}=r;return Lt.debug(`${u==null?void 0:u.toUpperCase()} ${c}${m}  ${a}`),i},o=>{let{config:r,response:i={}}=o,{status:a}=i,{method:u,baseURL:c,url:m}=r;return Lt.error(`${u.toUpperCase()} ${c}${m} ${a||o.message}`),Promise.reject(o)})}async getTokens(){return this.api.get("/sdk/token/raydium.mainnet.json")}async getLiquidityPools(){return this.api.get(`/sdk/liquidity/${this.cluster}.json`)}async getPairsInfo(){return this.api.get("https://api.raydium.io/v2/main/pairs")}async getFarmPools(){return this.api.get(`/sdk/farm-v2/${this.cluster}.json`)}async getCoingeckoPrice(t){return this.api.get(`https://api.coingecko.com/api/v3/simple/price?ids=${t.join(",")}&vs_currencies=usd`)}async getRaydiumTokenPrice(){return this.api.get("https://api.raydium.io/v2/main/price")}async getBlockSlotCountForSecond(t){if(!t)return 2;let o=(await this.api.post(t,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(r=>r.numSlots);return o.reduce((r,i)=>r+i,0)/o.length/60}};var Rt="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",go="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{getAssociatedTokenAddress as Ao,createAssociatedTokenAccountInstruction as To,TOKEN_PROGRAM_ID as Gi}from"@solana/spl-token";import{PublicKey as $i}from"@solana/web3.js";var zt=(...n)=>n.map(t=>{try{return typeof t=="object"?JSON.stringify(t):t}catch{return t}}).join(", "),re=class{constructor({scope:t,moduleName:e}){this.disabled=!1;this.scope=t,this.logger=M(e)}createTxBuilder(t){return this.scope.checkOwner(),new xt({connection:this.scope.connection,feePayer:t||this.scope.ownerPubKey,owner:this.scope.owner,signAllTransactions:this.scope.signAllTransactions})}logDebug(...t){this.logger.debug(zt(t))}logInfo(...t){this.logger.info(zt(t))}logAndCreateError(...t){let e=zt(t);throw new Error(e)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{createInitializeAccountInstruction as Oi,createCloseAccountInstruction as Fi,createTransferInstruction as qi,TOKEN_PROGRAM_ID as Ni}from"@solana/spl-token";import{Keypair as Di,PublicKey as vi,SystemProgram as Ei}from"@solana/web3.js";import Ki from"bn.js";import{PublicKey as Bi}from"@solana/web3.js";import ko,{isBN as Po}from"bn.js";import{bits as sc,BitStructure as uc,blob as Si,Blob as cc,cstr as mc,f32 as lc,f32be as dc,f64 as pc,f64be as fc,greedy as bc,Layout as Li,ns64 as yc,ns64be as gc,nu64 as hc,nu64be as wc,offset as kc,s16 as Pc,s16be as Ic,s24 as Ac,s24be as Tc,s32 as xc,s32be as Sc,s40 as Lc,s40be as _c,s48 as Rc,s48be as Mc,s8 as Bc,seq as _i,struct as Oc,Structure as Ri,u16 as Fc,u16be as qc,u24 as Nc,u24be as Dc,u32 as vc,u32be as Ec,u40 as Kc,u40be as Vc,u48 as Cc,u48be as Wc,u8 as Uc,UInt as Mi,union as Gc,Union as $c,unionLayoutDiscriminator as jc,utf8 as Yc}from"@solana/buffer-layout";var Zt=Li,ho=Ri;var Xt=Mi;var wo=_i;var ze=Si;var Mt=class extends Zt{constructor(e,o,r){super(e,r);this.blob=ze(e),this.signed=o}decode(e,o=0){let r=new ko(this.blob.decode(e,o),10,"le");return this.signed?r.fromTwos(this.span*8).clone():r}encode(e,o,r=0){return typeof e=="number"&&(e=new ko(e)),this.signed&&(e=e.toTwos(this.span*8)),this.blob.encode(e.toArrayLike(Buffer,"le",this.span),o,r)}};function v(n){return new Xt(1,n)}function Fe(n){return new Xt(4,n)}function l(n){return new Mt(8,!1,n)}function J(n){return new Mt(16,!1,n)}var en=class extends Zt{constructor(e,o,r,i){super(e.span,i);this.layout=e,this.decoder=o,this.encoder=r}decode(e,o){return this.decoder(this.layout.decode(e,o))}encode(e,o,r){return this.layout.encode(this.encoder(e),o,r)}getSpan(e,o){return this.layout.getSpan(e,o)}};function w(n){return new en(ze(32),t=>new Bi(t),t=>t.toBuffer(),n)}var tn=class extends ho{decode(t,e){return super.decode(t,e)}};function R(n,t,e){return new tn(n,t,e)}function H(n,t,e){let o,r=typeof t=="number"?t:Po(t)?t.toNumber():new Proxy(t,{get(i,a){if(!o){let u=Reflect.get(i,"count");o=Po(u)?u.toNumber():u,Reflect.set(i,"count",o)}return Reflect.get(i,a)},set(i,a,u){return a==="count"&&(o=u),Reflect.set(i,a,u)}});return wo(n,r,e)}var we=R([w("mint"),w("owner"),l("amount"),Fe("delegateOption"),w("delegate"),v("state"),Fe("isNativeOption"),l("isNative"),l("delegatedAmount"),Fe("closeAuthorityOption"),w("closeAuthority")]);function Vi(n){let{mint:t,tokenAccount:e,owner:o}=n;return Oi(e,t,o)}function qe(n){let{tokenAccount:t,payer:e,multiSigners:o=[],owner:r}=n;return Fi(t,e,r,o)}async function Le(n){let{connection:t,amount:e,commitment:o,payer:r,owner:i,skipCloseAccount:a}=n,u=await t.getMinimumBalanceForRentExemption(we.span,o),c=x(e).add(new Ki(u)),m=Di.generate();return{signers:[m],instructions:[Ei.createAccount({fromPubkey:r,newAccountPubkey:m.publicKey,lamports:c.toNumber(),space:we.span,programId:Ni}),Vi({mint:new vi(Y.mint),tokenAccount:m.publicKey,owner:i})],endInstructions:a?[]:[qe({tokenAccount:m.publicKey,payer:r,owner:i})]}}function Ke({source:n,destination:t,owner:e,amount:o,multiSigners:r=[]}){return qi(n,t,e,x(o).toNumber(),r)}import{PublicKey as Ci}from"@solana/web3.js";import Wi from"bn.js";var Ui=M("Raydium_Util");function Io({solAccountResp:n,tokenAccountResp:t}){let e=[],o=[];for(let{pubkey:r,account:i}of t.value){if(i.data.length!==we.span)throw Ui.error("invalid token account layout length","publicKey",r.toBase58()),new Error("invalid token account layout length");let a=we.decode(i.data),{mint:u,amount:c}=a;e.push({publicKey:r,mint:u,amount:c,isNative:!1}),o.push({pubkey:r,accountInfo:a})}return n&&e.push({mint:Ci.default,amount:new Wi(n.lamports),isNative:!0}),{tokenAccounts:e,tokenAccountRawInfos:o}}var Ze=class extends re{constructor(e){super(e);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._ataCache=new Map;this._accountListener=[];this._clientOwnedToken=!1;let{tokenAccounts:o,tokenAccountRawInfos:r}=e;this._tokenAccounts=o||[],this._tokenAccountRawInfos=r||[],this._clientOwnedToken=!!(o||r)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}updateTokenAccount({tokenAccounts:e,tokenAccountRawInfos:o}){return e&&(this._tokenAccounts=e),o&&(this._tokenAccountRawInfos=o),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(e){return this._accountListener.push(e),this}removeAccountChangeListener(e){return this._accountListener=this._accountListener.filter(o=>o!==e),this}async getAssociatedTokenAccount(e){this.scope.checkOwner();let o=`${this.scope.ownerPubKey.toBase58()}_${e.toBase58()}`;if(this._ataCache.has(o))return this._ataCache.get(o);let r=await Ao(e,this.scope.ownerPubKey,!0);return this._ataCache.set(o,r),r}async fetchWalletTokenAccounts(e){if(this._clientOwnedToken||!(e!=null&&e.forceUpdate)&&this._tokenAccounts.length)return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let r=S(S({},{}),e),i=await this.scope.connection.getAccountInfo(this.scope.ownerPubKey,r.commitment),a=await this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Gi},r.commitment),{tokenAccounts:u,tokenAccountRawInfos:c}=Io({solAccountResp:i,tokenAccountResp:a});return this._tokenAccounts=u,this._tokenAccountRawInfos=c,this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>this.fetchWalletTokenAccounts({forceUpdate:!0}),"confirmed"),{tokenAccounts:u,tokenAccountRawInfos:c}}async getCreatedTokenAccount({mint:e,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:a})=>a==null?void 0:a.equals(e)).sort((a,u)=>a.amount.lt(u.amount)?1:-1),i=await this.getAssociatedTokenAccount(e);for(let a of r){let{publicKey:u}=a;if(u)return o&&i.equals(u),u}}async checkOrCreateAta({mint:e,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:c})=>(c==null?void 0:c.toBase58())===e.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,a={};if(!r){let c=await this.getAssociatedTokenAccount(e),m=await To(i,c,i,e);a.instructions=[m],r=c}return o&&Y.mint===e.toBase58()&&(a.endInstructions=[qe({owner:i,payer:i,tokenAccount:r})]),{pubKey:r,newInstructions:a}}async handleTokenAccount(e){let{side:o,amount:r,mint:i,tokenAccount:a,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:c,skipCloseAccount:m}=e,d=this.createTxBuilder(),p=await Ao(i,this.scope.ownerPubKey,!0);if(new $i(Y.mint).equals(i)){let b=await Le({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:r,skipCloseAccount:m});return d.addInstruction(b),S({tokenAccount:b.signers[0].publicKey},b)}else if(!a||o==="out"&&!p.equals(a)&&!c)return{tokenAccount:p,instructions:[To(this.scope.ownerPubKey,p,this.scope.ownerPubKey,i)]};return{tokenAccount:a}}};import{TOKEN_PROGRAM_ID as ot,createAssociatedTokenAccountInstruction as la}from"@solana/spl-token";import{Keypair as da,PublicKey as Z,SystemProgram as Xo,SYSVAR_CLOCK_PUBKEY as pa,TransactionInstruction as rt}from"@solana/web3.js";import ln from"bn.js";import{PublicKey as tt}from"@solana/web3.js";var nn=R([v("instruction")]),on=R([v("instruction")]),ji=R([l("rewardState"),l("rewardOpenTime"),l("rewardEndTime"),l("rewardLastUpdateTime"),l("totalReward"),l("totalRewardEmissioned"),l("rewardClaimed"),l("rewardPerSecond"),J("accRewardPerShare"),w("rewardVault"),w("rewardMint"),w("rewardSender"),l("rewardType"),H(l(),15,"padding")]),Yi=R([l("state"),l("nonce"),w("lpVault"),w("rewardVault"),w(),w(),l(),l(),l("totalReward"),J("perShareReward"),l("lastSlot"),l("perSlotReward")]),Ji=R([l("state"),l("nonce"),w("lpVault"),w("rewardVaultA"),l("totalRewardA"),J("perShareRewardA"),l("perSlotRewardA"),v("option"),w("rewardVaultB"),ze(7),l("totalRewardB"),J("perShareRewardB"),l("perSlotRewardB"),l("lastSlot"),w()]),Qi=R([l(),l("state"),l("nonce"),l("validRewardTokenNum"),J("rewardMultiplier"),l("rewardPeriodMax"),l("rewardPeriodMin"),l("rewardPeriodExtend"),w("lpMint"),w("lpVault"),H(ji,5,"rewardInfos"),w("creator"),w(),H(l(),32,"padding")]),xo=new Proxy(Yi,{get(n,t,e){return t==="decode"?(...o)=>{let r=n.decode(...o);return O(S({},r),{version:3,rewardInfos:[{rewardVault:r.rewardVault,totalReward:r.totalReward,perSlotReward:r.perSlotReward,perShareReward:r.perShareReward}]})}:Reflect.get(n,t,e)}}),So=new Proxy(Ji,{get(n,t,e){return t==="decode"?(...o)=>{let r=n.decode(...o);return O(S({},r),{version:5,rewardInfos:[{rewardVault:r.rewardVaultA,totalReward:r.totalRewardA,perSlotReward:r.perSlotRewardA,perShareReward:r.perShareRewardA},{rewardVault:r.rewardVaultB,totalReward:r.totalRewardB,perSlotReward:r.perSlotRewardB,perShareReward:r.perShareRewardB}]})}:Reflect.get(n,t,e)}}),Xe=new Proxy(Qi,{get(n,t,e){return t==="decode"?(...o)=>{let r=n.decode(...o);return O(S({},r),{version:6,rewardInfos:r.rewardInfos.map(i=>{var a;return O(S({},i),{rewardType:((a=Object.entries(Bt).find(u=>String(u[1])===i.rewardType.toString()))!=null?a:["Standard SPL"])[0]})})})}:Reflect.get(n,t,e)}}),Hi=R([l("isSet"),l("rewardPerSecond"),l("rewardOpenTime"),l("rewardEndTime"),l("rewardType")]),rn=R([v("instruction"),l("nonce"),H(Hi,5,"rewardTimeInfo")]),an=R([v("instruction"),l("rewardReopenTime"),l("rewardEndTime"),l("rewardPerSecond")]),sn=R([v("instruction"),l("isSet"),l("rewardPerSecond"),l("rewardOpenTime"),l("rewardEndTime")]),Wm=R([l("state"),w("id"),w("owner"),l("deposited"),H(l(),1,"rewardDebts")]),Lo=R([l("state"),w("id"),w("owner"),l("deposited"),H(J(),1,"rewardDebts"),H(l(),17)]),Um=R([l("state"),w("id"),w("owner"),l("deposited"),H(l(),2,"rewardDebts")]),_o=R([l("state"),w("id"),w("owner"),l("deposited"),H(J(),2,"rewardDebts"),H(l(),17)]),Ro=R([l(),l("state"),w("id"),w("owner"),l("deposited"),H(J(),5,"rewardDebts"),H(l(),16)]),et=R([v("instruction"),l("amount")]);var Mo=M("Raydium_farm_config"),Bo="EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q",zi=new tt(Bo),Oo="9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z",Zi=new tt(Oo),Fo="FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG",Xi=new tt(Fo),qo={[Bo]:3,[Oo]:5,[Fo]:6},No={3:zi,5:Zi,6:Xi},Do=new tt("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),vo=new tt("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),Eo={3:xo,5:So,6:Xe},Ko={3:Lo,5:_o,6:Ro},un=n=>[3,5,6].indexOf(n)!==-1,ea={3:10,5:11,6:1},Vo=n=>{let t=ea[n];return t||Mo.logWithError("invalid deposit farm version"),t},ta={3:11,5:12,6:2},Co=n=>{let t=ta[n];return t||Mo.logWithError("invalid withdraw farm version"),t},Wo=n=>{var a;let{version:t,rewardInfos:e,rewardTokenAccountsPublicKeys:o}=n,r=`rewardInfo:${JSON.stringify(e)}, rewardAccount:${JSON.stringify(o)}`,i={3:()=>{if(e.length!==1||o.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${r}`},5:()=>{if(e.length!==o.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${r}`},6:()=>{if(!o.length||e.length!==o.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${r}`}};return(a=i[t])==null?void 0:a.call(i)},Bt={"Standard SPL":0,"Option tokens":1};import{SystemProgram as na,SYSVAR_RENT_PUBKEY as oa,TransactionInstruction as Uo}from"@solana/web3.js";import ra from"bn.js";var ia=M("Raydium_farm_instruction");async function Go(n){let{version:t,id:e,ledger:o,programId:r,owner:i}=n,a={3:9,5:10}[t];a||ia.logWithError(`invalid farm pool version: ${t}`);let u=Buffer.alloc(nn.span);nn.encode({instruction:a},u);let c=[s({pubkey:e}),s({pubkey:o}),s({pubkey:i,isWritable:!1}),s({pubkey:na.programId,isWritable:!1}),s({pubkey:oa,isWritable:!1})];return new Uo({programId:r,keys:c,data:u})}function $o(n){var o;let t=Buffer.alloc(rn.span);rn.encode({instruction:0,nonce:new ra(n.nonce),rewardTimeInfo:n.rewardInfoConfig},t);let e=[...Oe,s({pubkey:n.farmKeyPair.publicKey}),s({pubkey:n.farmAuthority,isWritable:!1}),s({pubkey:n.lpVault}),s({pubkey:n.lpMint,isWritable:!1}),s({pubkey:n.lockVault}),s({pubkey:n.lockMint,isWritable:!1}),s({pubkey:(o=n.lockUserAccount)!=null?o:W}),s({pubkey:n.owner,isWritable:!1,isSigner:!0})];for(let r of n.rewardInfo)e.push(s({pubkey:r.rewardMint,isWritable:!1}),s({pubkey:r.rewardVault}),s({pubkey:r.userRewardToken}));return new Uo({programId:n.programId,keys:e,data:t})}import z from"bn.js";var nt=M("Raydium.farm.util");async function Ot({programId:n,poolId:t,mint:e,type:o}){let{publicKey:r}=await he([t.toBuffer(),e.toBuffer(),Buffer.from(o==="lpVault"?"lp_vault_associated_seed":o==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],n);return r}function aa(n){let e=V({publicKey:n}).toBase58();return qo[e]}async function cn({programId:n,poolId:t,owner:e}){let{publicKey:o}=await he([t.toBuffer(),e.toBuffer(),Buffer.from(aa(n)===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],n);return o}var jo=async({programId:n,poolId:t})=>await he([t.toBuffer()],n);function Yo(n){return No[n]}function Jo(n){return{isSet:new z(1),rewardPerSecond:x(n.rewardPerSecond),rewardOpenTime:x(n.rewardOpenTime),rewardEndTime:x(n.rewardEndTime),rewardType:x(n.rewardType)}}function mn(n){return x(n.rewardEndTime).sub(x(n.rewardOpenTime)).mul(x(n.rewardPerSecond))}function sa(n){let t=Ko[n];return t||nt.logWithError("invalid version",n),t}function ua(n){let t=Eo[n];return t||nt.logWithError("invalid version",n),t}function ca(n,t,e,o){if(n.version===3||n.version===5){if(n.lastSlot.gte(new z(e)))return n;let r=new z(e).sub(n.lastSlot);n.lastSlot=new z(e);for(let i of n.rewardInfos){if(t.amount.eq(new z(0)))continue;let a=i.perSlotReward.mul(r);i.perShareReward=i.perShareReward.add(a.mul(new z(10).pow(new z(n.version===3?9:15))).div(t.amount)),i.totalReward=i.totalReward.add(a)}}else if(n.version===6)for(let r of n.rewardInfos){if(r.rewardState.eq(new z(0)))continue;let i=z.min(new z(o),r.rewardEndTime);if(r.rewardOpenTime.gte(i))continue;let u=i.sub(r.rewardLastUpdateTime).mul(r.rewardPerSecond),c=r.totalReward.sub(r.totalRewardEmissioned);c.lt(u)?(u=c,r.rewardLastUpdateTime=r.rewardLastUpdateTime.add(c.div(r.rewardPerSecond))):r.rewardLastUpdateTime=i,!t.amount.eq(new z(0))&&(r.accRewardPerShare=r.accRewardPerShare.add(u.mul(n.rewardMultiplier).div(t.amount)),r.totalRewardEmissioned=r.totalRewardEmissioned.add(u))}return n}async function ma({connection:n,farmPools:t,owner:e,config:o}){var b;let r=!1,i=!1,a=new z(10),u=[];for(let f of t){let y=me(f);y.version===6?i=!0:r=!0,u.push({pubkey:y.id,version:y.version,key:"state",poolId:y.id},{pubkey:y.lpVault,version:y.version,key:"lpVault",poolId:y.id}),e&&u.push({pubkey:await cn({programId:y.programId,poolId:y.id,owner:e}),version:y.version,key:"ledger",poolId:y.id})}let c={},m=await mo(n,u,o);for(let{pubkey:f,version:y,key:h,poolId:L,accountInfo:g}of m){let k=L.toBase58();if(c[k]=S({},c[k]),h==="state"){let _=ua(y);(!g||!g.data||g.data.length!==_.span)&&nt.logWithError(`invalid farm state account info, pools.id, ${f}`),c[k].state=_.decode(g.data)}else if(h==="lpVault")(!g||!g.data||g.data.length!==we.span)&&nt.logWithError(`invalid farm lp vault account info, pools.lpVault, ${f}`),c[k].lpVault=we.decode(g.data);else if(h==="ledger"){let _=sa(y);g&&g.data&&(g.data.length!==_.span&&nt.logWithError(`invalid farm ledger account info, ledger, ${f}`),c[k].ledger=_.decode(g.data))}}let d=i||r?await n.getSlot():0,p=i&&(b=await n.getBlockTime(d))!=null?b:0;for(let f of Object.keys(c))c[f].state=ca(c[f].state,c[f].lpVault,d,p);for(let[f,{state:y,ledger:h}]of Object.entries(c))if(h){let L=y.version===6?y.rewardMultiplier:y.rewardInfos.length===1?a.pow(new z(9)):a.pow(new z(15)),g=y.rewardInfos.map((k,_)=>{let P=h.rewardDebts[_];return h.deposited.mul(y.version===6?k.accRewardPerShare:k.perShareReward).div(L).sub(P)});c[f].wrapped=O(S({},c[f].wrapped),{pendingRewards:g})}return c}async function Qo(n){let{farmPools:t}=n,e=await ma(n);return t.map((r,i)=>O(S(S(S({},t[i]),me(r)),e[r.id]),{jsonInfo:t[i]}))}function Ho(n,t=Date.now()){if(n.version===6){let e=n.state.rewardInfos;if(e.every(({rewardOpenTime:o})=>He(t,o.toNumber(),{unit:"s"})))return"upcoming pool";if(e.every(({rewardEndTime:o})=>Ee(t,o.toNumber(),{unit:"s"})))return"closed pool"}else{let e=n.state.rewardInfos.map(({perSlotReward:o})=>o);if(e.length===2){if(String(e[0])==="0"&&String(e[1])!=="0")return"normal fusion pool";if(String(e[0])!=="0"&&String(e[1])!=="0")return"dual fusion pool";if(String(e[0])==="0"&&String(e[1])==="0")return"closed pool"}else if(e.length===1&&String(e[0])==="0")return"closed pool"}}function zo(n){return n.state.rewardInfos.length===1&&String(n.lpMint)===At.toBase58()}function Zo(n,t){return n.version===6?n.state.rewardInfos.map(({rewardPerSecond:e,rewardOpenTime:o,rewardEndTime:r},i)=>{var b;let a=He(t.currentBlockChainDate,o.toNumber(),{unit:"s"}),u=Ee(t.currentBlockChainDate,r.toNumber(),{unit:"s"});if(a||u)return;let c=t.rewardTokens[i];if(!c)return;let m=t.rewardTokenPrices[i];if(!m)return;let d=je(new T(e,pe).div(ye.pow(new z(c.decimals||1))).mul(new z(60*60*24*365)),m);return t.tvl?t.tvl.isZero()?Be(0):d.div((b=t.tvl)!=null?b:pe):void 0}):n.state.rewardInfos.map(({perSlotReward:o},r)=>{var m;let i=t.rewardTokens[r];if(!i)return;let a=t.rewardTokenPrices[r];if(!a)return;let u=je(new T(o,pe).div(ye.pow(new z(i.decimals||1))).mul(new z(t.blockSlotCountForSecond*60*60*24*365)),a);return t.tvl?t.tvl.isZero()?Be(0):u.div((m=t.tvl)!=null?m:pe):void 0})}var it=class extends re{constructor(){super(...arguments);this._farmPools=[];this._hydratedFarmPools=[];this._hydratedFarmMap=new Map;this._sdkParsedFarmPools=[];this._lpTokenInfoMap=new Map}async load(e){var r;await this.scope.liquidity.load(e),await this.scope.fetchFarms(e==null?void 0:e.forceUpdate);let o=((r=this.scope.apiData.farmPools)==null?void 0:r.data)||{};this._farmPools=Object.keys(o||{}).reduce((i,a)=>{var u,c;return i.concat(((c=(u=o[a]).map)==null?void 0:c.call(u,m=>{let d=this.scope.token.allTokenMap.get(m.baseMint),p=this.scope.token.allTokenMap.get(m.quoteMint);return d&&p&&this._lpTokenInfoMap.set(m.lpMint,new G({mint:m.lpMint,decimals:d.decimals,symbol:`${d.symbol} - ${p.name}`,name:`${d.symbol} - ${p.name} LP`})),O(S({},m),{name:m.symbol,category:a})}))||[])},[]),await this.fetchSdkFarmInfo()}async fetchSdkFarmInfo(){var e;this._sdkParsedFarmPools=await Qo({connection:this.scope.connection,farmPools:this._farmPools,owner:(e=this.scope.owner)==null?void 0:e.publicKey,config:{commitment:"confirmed"}})}async loadHydratedFarmInfo(e){let{forceUpdate:o,skipPrice:r}=e||{};if(this._hydratedFarmPools.length&&!o)return this._hydratedFarmPools;await this.scope.farm.load(),!r&&await this.scope.token.fetchTokenPrices(),await this.scope.liquidity.loadPairs();let i=await this.scope.chainTimeOffset(),a=Ht(Date.now()+i,{minutes:0}),u=await this.scope.api.getBlockSlotCountForSecond(this.scope.connection.rpcEndpoint),c=Object.fromEntries(this.scope.liquidity.allPairs.map(m=>[m.ammId,{apr30d:m.apr30d,apr7d:m.apr7d,apr24h:m.apr24h}]));return this._hydratedFarmPools=this._sdkParsedFarmPools.map(m=>{let d=this.hydrateFarmInfo({farmInfo:m,blockSlotCountForSecond:u,farmAprs:c,currentBlockChainDate:a,chainTimeOffset:i});return this._hydratedFarmMap.set(m.id.toBase58(),d),d}),this._hydratedFarmPools}get allFarms(){return this._farmPools}get allParsedFarms(){return this._sdkParsedFarmPools}get allHydratedFarms(){return this._hydratedFarmPools}get allHydratedFarmMap(){return this._hydratedFarmMap}getFarm(e){let o=V({publicKey:e}),r=this.allFarms.find(i=>i.id===o.toBase58());return r||this.logAndCreateError("invalid farm id"),r}getParsedFarm(e){let o=V({publicKey:e}),r=this.allParsedFarms.find(i=>o.equals(i.id));return r||this.logAndCreateError("invalid farm id"),r}getLpTokenInfo(e){let o=V({publicKey:e}),r=this._lpTokenInfoMap.get(o.toBase58());return r||this.logAndCreateError("LP Token not found",o.toBase58()),r}lpDecimalAmount({mint:e,amount:o}){let r=se(o),i=this.getLpTokenInfo(e);return Te(new T(r.numerator,r.denominator).mul(new ln(10).pow(new ln(i.decimals))))}hydrateFarmInfo(e){var dt,pt,Ce,We,Ue,ft,xn,Sn,Ln,_n,Rn,Mn;let{farmInfo:o,blockSlotCountForSecond:r,farmAprs:i,currentBlockChainDate:a,chainTimeOffset:u=0}=e,c=Ho(o,a),m=zo(o),d=c==="dual fusion pool",p=c==="normal fusion pool",b=c==="closed pool"&&!o.upcoming,f=o.version!==6?o.upcoming&&b:o.upcoming,y=o.version!==6&&o.upcoming&&!b,h=((dt=this.scope.liquidity.allPools.find(B=>B.lpMint===o.lpMint.toBase58()))==null?void 0:dt.version)===5,L=m?this.scope.mintToToken(o.lpMint):this.getLpTokenInfo(o.lpMint),g=this.scope.mintToToken(m?o.lpMint:o.baseMint),k=this.scope.mintToToken(m?o.lpMint:o.quoteMint);g!=null&&g.symbol;let _=m?`${(pt=g==null?void 0:g.symbol)!=null?pt:"unknown"}`:`${(Ce=g==null?void 0:g.symbol)!=null?Ce:"unknown"}-${(We=k==null?void 0:k.symbol)!=null?We:"unknown"}`,P=o.jsonInfo.rewardInfos.map(({rewardMint:B})=>this.scope.mintToToken(B)),q=(Ue=o.wrapped)==null?void 0:Ue.pendingRewards.map((B,C)=>P[C]?new F(P[C],Te(fo(B,0))):void 0),N=m?this.scope.token.tokenPrices.get(o.lpMint.toBase58()):this.scope.liquidity.lpPriceMap.get(o.lpMint.toBase58()),D=L&&new F(L,o.lpVault.amount),$=N&&L?je(new F(L,o.lpVault.amount),N):void 0,E=Zo(o,{tvl:$,currentBlockChainDate:a,rewardTokens:P,rewardTokenPrices:(ft=o.rewardInfos.map(({rewardMint:B})=>this.scope.token.tokenPrices.get(B.toBase58())))!=null?ft:[],blockSlotCountForSecond:r}),U=(xn=this.scope.liquidity.allPools.find(B=>B.lpMint===o.lpMint.toBase58()))==null?void 0:xn.id,X=U?wt((Sn=i[U])==null?void 0:Sn.apr7d,{alreadyDecimaled:!0}):void 0,j=U?wt((Ln=i[U])==null?void 0:Ln.apr30d,{alreadyDecimaled:!0}):void 0,ne=U?wt((_n=i[U])==null?void 0:_n.apr24h,{alreadyDecimaled:!0}):void 0,ie=E.reduce((B,C)=>B?C?B.add(C):B:C,X),Ae=E.reduce((B,C)=>B?C?B.add(C):B:C,j),ce=E.reduce((B,C)=>B?C?B.add(C):B:C,ne),fe=o.version===6?o.state.rewardInfos.map((B,C)=>{var qn,Nn,Dn,vn;let{rewardOpenTime:Ge,rewardEndTime:bt,rewardPerSecond:Kt}=B,Me=Ge.toNumber()?new Date(Ge.toNumber()*1e3+u):void 0,be=bt.toNumber()?new Date(bt.toNumber()*1e3+u):void 0,Vt=Date.now()+u;if(!Me&&!be)return;let ve=this.scope.mintToToken((Dn=(Nn=B.rewardMint)!=null?Nn:(qn=o.rewardInfos[C])==null?void 0:qn.rewardMint)==null?void 0:Dn.toBase58()),Bn=Boolean(Me&&He(Vt,Me)),On=Boolean(be&&Ee(Vt,be)),Fn=!Me&&!be||!On&&!Bn,Kr=Fn&&Ee(Vt,Ht(be,{seconds:-((vn=o.jsonInfo.rewardPeriodExtend)!=null?vn:72*60*60)})),Vr=ve&&this.scope.mintToTokenAmount({mint:ve.mint,amount:po(B.totalReward,B.totalRewardEmissioned).toFixed(ve.decimals)}),Cr=q==null?void 0:q[C],Wr=E[C],Ur=Boolean(be),yt=o.rewardInfos[C];return O(S(S({},yt),B),{owner:yt==null?void 0:yt.rewardSender,apr:Wr,token:ve,userPendingReward:Cr,userHavedReward:Ur,perSecond:ve&&this.scope.mintToTokenAmount({mint:ve.mint,amount:Kt}).toSignificant(),openTime:Me,endTime:be,isOptionToken:B.rewardType==="Option tokens",isRewardBeforeStart:Bn,isRewardEnded:On,isRewarding:Fn,isRwardingBeforeEnd72h:Kr,claimableRewards:Vr,version:6})}).filter(B=>!!B):o.state.rewardInfos.map((B,C)=>{let Ge=q==null?void 0:q[C],bt=E[C],Kt=P[C],{perSlotReward:Me}=B,be=St(Ge)||St(Me);return O(S({},B),{apr:bt,token:Kt,userPendingReward:Ge,userHavedReward:be,version:o.version})}),de=L&&((Rn=o.ledger)==null?void 0:Rn.deposited)?new F(L,(Mn=o.ledger)==null?void 0:Mn.deposited):void 0;return O(S({},o),{lp:L,lpPrice:N,base:g,quote:k,name:_,isStakePool:m,isDualFusionPool:d,isNormalFusionPool:p,isClosedPool:b,isUpcomingPool:f,isStablePool:h,isNewPool:y,totalApr7d:ie,raydiumFeeApr7d:X,totalApr24h:ce,raydiumFeeApr24h:ne,totalApr30d:Ae,raydiumFeeApr30d:j,ammId:U,tvl:$,userHasStaked:St(de),rewards:fe,userStakedLpAmount:de,stakedLpAmount:D})}async _getUserRewardInfo({payer:e,rewardInfo:o}){if(o.rewardMint.equals(W)){let r=await Le({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:mn(o)});return{rewardPubKey:r.signers[0].publicKey,newInstruction:r}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:o.rewardMint})}}async create({poolId:e,rewardInfos:o,payer:r}){this.checkDisabled(),this.scope.checkOwner();let i=V({publicKey:e}),a=this.scope.liquidity.allPools.find(P=>P.id===i.toBase58());a||this.logAndCreateError("invalid pool id");let c={lpMint:new Z(a.lpMint),lockInfo:{lockMint:Do,lockVault:vo},version:6,rewardInfos:o,programId:Yo(6)},m=this.createTxBuilder(),d=r!=null?r:this.scope.ownerPubKey,p=da.generate(),b=await this.scope.connection.getMinimumBalanceForRentExemption(Xe.span);m.addInstruction({instructions:[Xo.createAccount({fromPubkey:d,newAccountPubkey:p.publicKey,lamports:b,space:Xe.span,programId:c.programId})],signers:[p]});let{publicKey:f,nonce:y}=await jo({programId:c.programId,poolId:p.publicKey}),h=await Ot({programId:c.programId,poolId:p.publicKey,mint:c.lpMint,type:"lpVault"}),L=[],g=[];for(let P of c.rewardInfos){P.rewardOpenTime>=P.rewardEndTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",P.rewardOpenTime.toString()),Bt[P.rewardType]||this.logAndCreateError("rewardType error",P.rewardType),P.rewardPerSecond<=0&&this.logAndCreateError("rewardPerSecond error",P.rewardPerSecond.toString()),L.push(Jo(P));let{rewardPubKey:q,newInstruction:N}=await this._getUserRewardInfo({rewardInfo:P,payer:d});N&&m.addInstruction(N),q||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let D=P.rewardMint.equals(W)?new Z(Y.mint):P.rewardMint;g.push({rewardMint:D,rewardVault:await Ot({programId:c.programId,poolId:p.publicKey,mint:D,type:"rewardVault"}),userRewardToken:q})}let k=await this.scope.account.getCreatedTokenAccount({mint:c.lockInfo.lockMint});k||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let _=$o({farmKeyPair:p,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:h,lpMint:c.lpMint,lockVault:c.lockInfo.lockVault,lockMint:c.lockInfo.lockMint,lockUserAccount:k,programId:c.programId,rewardInfo:g,rewardInfoConfig:L,nonce:y});return await m.addInstruction({instructions:[_]}).build()}async restartReward({farmId:e,payer:o,newRewardInfo:r}){let i=this.getFarm(e);i.version!==6&&this.logAndCreateError("invalid farm version",i.version);let a={id:new Z(i.id),rewardInfos:i.rewardInfos,lpVault:new Z(i.lpVault),programId:new Z(i.programId)};r.rewardOpenTime>=r.rewardEndTime&&this.logAndCreateError("start time error","newRewardInfo",r);let u=o||this.scope.ownerPubKey,c=r.rewardMint.equals(W)?new Z(Y.mint):r.rewardMint,m=a.rewardInfos.find(L=>new Z(L.rewardMint).equals(c));m||this.logAndCreateError("configuration does not exist","rewardMint",c);let d=m.rewardVault?new Z(m.rewardVault):W,p=this.createTxBuilder(),{rewardPubKey:b,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:r,payer:u});f&&p.addInstruction(f),b||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let y=Buffer.alloc(an.span);an.encode({instruction:3,rewardReopenTime:x(r.rewardOpenTime),rewardEndTime:x(r.rewardEndTime),rewardPerSecond:x(r.rewardPerSecond)},y);let h=[s({pubkey:ot,isWritable:!1}),s({pubkey:a.id}),s({pubkey:a.lpVault,isWritable:!1}),s({pubkey:d}),s({pubkey:b}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await p.addInstruction({instructions:[new rt({programId:a.programId,keys:h,data:y})]}).build()}async addNewRewardToken(e){let{farmId:o,newRewardInfo:r,payer:i}=e,a=this.getFarm(o);a.version!==6&&this.logAndCreateError("invalid farm version",a.version);let u=i!=null?i:this.scope.ownerPubKey,c=this.createTxBuilder(),m=await Ot({programId:new Z(a.programId),poolId:new Z(a.id),mint:r.rewardMint,type:"rewardVault"}),{rewardPubKey:d,newInstruction:p}=await this._getUserRewardInfo({rewardInfo:r,payer:u});p&&c.addInstruction(p),d||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts);let b=r.rewardMint.equals(W)?new Z(Y.mint):r.rewardMint,f=Buffer.alloc(sn.span);sn.encode({instruction:4,isSet:new ln(1),rewardPerSecond:x(r.rewardPerSecond),rewardOpenTime:x(r.rewardOpenTime),rewardEndTime:x(r.rewardEndTime)},f);let y=[...Oe,s({pubkey:new Z(a.id)}),s({pubkey:new Z(a.authority),isWritable:!1}),s({pubkey:b,isWritable:!1}),s({pubkey:m}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await c.addInstruction({instructions:[new rt({programId:new Z(a.programId),keys:y,data:f})]}).build()}async _prepareFarmAccounts(e){let o=this.createTxBuilder(),{farmInfo:r}=e,{pubKey:i,newInstructions:a}=await this.scope.account.checkOrCreateAta({mint:r.lpMint});o.addInstruction(a);let u=await Promise.all(r.rewardInfos.map(async({rewardMint:d})=>{let{pubKey:p,newInstructions:b}=await this.scope.account.checkOrCreateAta({mint:d,autoUnwrapWSOLToSOL:!0});return o.addInstruction(b),p})),c=await cn({programId:new Z(r.programId),poolId:new Z(r.id),owner:this.scope.ownerPubKey});if(!r.ledger&&r.version<6){let d=await Go({id:r.id,programId:r.programId,version:r.version,ledger:c,owner:this.scope.ownerPubKey});o.addInstruction({instructions:[d]})}let m=[s({pubkey:r.id}),s({pubkey:r.authority,isWritable:!1}),s({pubkey:c}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:i}),s({pubkey:new Z(r.jsonInfo.lpVault)}),s({pubkey:u[0]}),s({pubkey:r.rewardInfos[0].rewardVault}),s({pubkey:pa,isWritable:!1}),s({pubkey:ot,isWritable:!1})];return{txBuilder:o,lpTokenAccount:i,rewardTokenAccountsPublicKeys:u,ledgerAddress:c,lowVersionKeys:m}}async deposit(e){this.scope.checkOwner();let{farmId:o,amount:r}=e,i=this.getParsedFarm(o),a=i.lpMint,{version:u,rewardInfos:c}=i;un(u)||this.logAndCreateError("invalid farm version:",u);let{txBuilder:m,ledgerAddress:d,lpTokenAccount:p,lowVersionKeys:b,rewardTokenAccountsPublicKeys:f}=await this._prepareFarmAccounts({mint:a,farmInfo:i}),y=Wo({version:u,rewardInfos:c,rewardTokenAccountsPublicKeys:f});y&&this.logAndCreateError(y);let h=Buffer.alloc(et.span);et.encode({instruction:Vo(u),amount:x(r)},h);let L=u===6?[s({pubkey:ot,isWritable:!1}),s({pubkey:Xo.programId,isWritable:!1}),s({pubkey:i.id}),s({pubkey:i.authority,isWritable:!1}),s({pubkey:i.lpVault.mint}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:p})]:b;if(u!==3)for(let k=1;k<c.length;k++)L.push(s({pubkey:f[k]})),L.push(s({pubkey:c[k].rewardVault}));let g=new rt({programId:i.programId,keys:L,data:h});return await m.addInstruction({instructions:[g]}).build()}async withdraw(e){this.scope.checkOwner();let{farmId:o,amount:r}=e,i=this.getParsedFarm(o),a=i.lpMint,{version:u,rewardInfos:c}=i;un(u)||this.logAndCreateError("invalid farm version:",u);let{txBuilder:m,ledgerAddress:d,lpTokenAccount:p,lowVersionKeys:b,rewardTokenAccountsPublicKeys:f}=await this._prepareFarmAccounts({mint:a,farmInfo:i}),y=Buffer.alloc(et.span);et.encode({instruction:Co(u),amount:x(r)},y);let h=u===6?[s({pubkey:ot,isWritable:!1}),s({pubkey:i.id}),s({pubkey:i.authority,isWritable:!1}),s({pubkey:i.lpVault.mint}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:p})]:b;if(u!==3)for(let g=1;g<c.length;g++)h.push(s({pubkey:f[g]})),h.push(s({pubkey:c[g].rewardVault}));let L=new rt({programId:i.programId,keys:h,data:y});return await m.addInstruction({instructions:[L]}).build()}async withdrawFarmReward({farmId:e,withdrawMint:o}){var b;this.scope.checkOwner();let r=this.getParsedFarm(e),{version:i}=r;i!==6&&this.logAndCreateError("invalid farm version",r.version);let a=r.rewardInfos.find(f=>f.rewardMint.equals(o.equals(W)?new Z(Y.mint):o));a||this.logAndCreateError("withdraw mint error","rewardInfos",r);let u=(b=a==null?void 0:a.rewardVault)!=null?b:W,c=this.createTxBuilder(),m;if(this._getUserRewardInfo({payer:this.scope.ownerPubKey,rewardInfo:a}),o.equals(W)){let f=await Le({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:mn(a)});m=f.signers[0].publicKey,c.addInstruction(f)}else{let f=await this.scope.account.getCreatedTokenAccount({mint:o});f===null?(m=await this.scope.account.getAssociatedTokenAccount(o),c.addInstruction({instructions:[la(this.scope.ownerPubKey,m,this.scope.ownerPubKey,o)]})):m=f}let d=Buffer.alloc(on.span);on.encode({instruction:5},d);let p=[s({pubkey:ot,isWritable:!1}),s({pubkey:r.id}),s({pubkey:r.authority,isWritable:!1}),s({pubkey:r.lpVault.mint,isWritable:!1}),s({pubkey:u}),s({pubkey:m}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await c.addInstruction({instructions:[new rt({programId:r.programId,keys:p,data:d})]}).build()}};import{ComputeBudgetProgram as va}from"@solana/web3.js";import Ie from"bn.js";import{PublicKey as er}from"@solana/web3.js";import tr from"bn.js";var nr=new tr(25),or=new tr(1e4),rr="675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",fa=new er(rr),ir="5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h",ba=new er(ir),zl={[rr]:4,[ir]:5},ar={4:fa,5:ba},sr={4:3,5:3};import{TOKEN_PROGRAM_ID as wn}from"@solana/spl-token";import{SystemProgram as Ra,TransactionInstruction as Pe}from"@solana/web3.js";var dn=R([v("instruction"),l("amountIn"),l("minAmountOut")]),pn=R([v("instruction"),l("maxAmountIn"),l("amountOut")]),fn=R([v("instruction"),v("nonce")]),bn=R([v("instruction"),v("nonce"),l("startTime")]),ya=R([l("status"),l("nonce"),l("maxOrder"),l("depth"),l("baseDecimal"),l("quoteDecimal"),l("state"),l("resetFlag"),l("minSize"),l("volMaxCutRatio"),l("amountWaveRatio"),l("baseLotSize"),l("quoteLotSize"),l("minPriceMultiplier"),l("maxPriceMultiplier"),l("systemDecimalValue"),l("minSeparateNumerator"),l("minSeparateDenominator"),l("tradeFeeNumerator"),l("tradeFeeDenominator"),l("pnlNumerator"),l("pnlDenominator"),l("swapFeeNumerator"),l("swapFeeDenominator"),l("baseNeedTakePnl"),l("quoteNeedTakePnl"),l("quoteTotalPnl"),l("baseTotalPnl"),J("quoteTotalDeposited"),J("baseTotalDeposited"),J("swapBaseInAmount"),J("swapQuoteOutAmount"),l("swapBase2QuoteFee"),J("swapQuoteInAmount"),J("swapBaseOutAmount"),l("swapQuote2BaseFee"),w("baseVault"),w("quoteVault"),w("baseMint"),w("quoteMint"),w("lpMint"),w("openOrders"),w("marketId"),w("marketProgramId"),w("targetOrders"),w("withdrawQueue"),w("lpVault"),w("owner"),l("lpReserve"),H(l(),3,"padding")]),td=R([l("accountType"),l("status"),l("nonce"),l("maxOrder"),l("depth"),l("baseDecimal"),l("quoteDecimal"),l("state"),l("resetFlag"),l("minSize"),l("volMaxCutRatio"),l("amountWaveRatio"),l("baseLotSize"),l("quoteLotSize"),l("minPriceMultiplier"),l("maxPriceMultiplier"),l("systemDecimalsValue"),l("abortTradeFactor"),l("priceTickMultiplier"),l("priceTick"),l("minSeparateNumerator"),l("minSeparateDenominator"),l("tradeFeeNumerator"),l("tradeFeeDenominator"),l("pnlNumerator"),l("pnlDenominator"),l("swapFeeNumerator"),l("swapFeeDenominator"),l("baseNeedTakePnl"),l("quoteNeedTakePnl"),l("quoteTotalPnl"),l("baseTotalPnl"),l("poolOpenTime"),l("punishPcAmount"),l("punishCoinAmount"),l("orderbookToInitTime"),J("swapBaseInAmount"),J("swapQuoteOutAmount"),J("swapQuoteInAmount"),J("swapBaseOutAmount"),l("swapQuote2BaseFee"),l("swapBase2QuoteFee"),w("baseVault"),w("quoteVault"),w("baseMint"),w("quoteMint"),w("lpMint"),w("modelDataAccount"),w("openOrders"),w("marketId"),w("marketProgramId"),w("targetOrders"),w("owner"),H(l(),64,"padding")]),yn=R([v("instruction"),l("baseAmountIn"),l("quoteAmountIn"),l("fixedSide")]),gn=R([v("instruction"),l("amountIn")]);import{PublicKey as ga}from"@solana/web3.js";var ke=new ga("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),De=5e4,ha=R([l("x"),l("y"),l("price")]),wa=R([l("accountType"),l("status"),l("multiplier"),l("validDataCount"),H(ha,De,"DataElement")]);function ka(n,t){return[0,De-2]}function Pa(n){return[0,De-2]}function Ia(n){return[0,De-2]}function Aa(n,t,e){let[o,r]=ka(t,e),i=o,a=r,u=0,c=t*n.multiplier/e;for(;i<=a;){if(u=Math.floor((a+i)/2),u===0||u>=De-2)return[u,u,!1];let m=n.DataElement[u].x*n.multiplier/n.DataElement[u].y,d=n.DataElement[u-1].x*n.multiplier/n.DataElement[u-1].y,p=n.DataElement[u+1].x*n.multiplier/n.DataElement[u+1].y;if(c===m)return[u,u,!0];if(c===d)return[u-1,u-1,!0];if(c===p)return[u+1,u+1,!0];if(c<d)a=u-1;else{if(c>d&&c<m)return[u-1,u,!0];if(c>m&&c<p)return[u,u+1,!0];i=u+1}}return[u,u,!1]}function hn(n,t,e){let[o,r,i]=Aa(n,t,e);if(!i)return 0;if(o===r){let a=n.DataElement[o].x;return t*n.multiplier/a}else{let a=n.DataElement[o].x,u=n.DataElement[o].y,c=n.DataElement[r].x,m=n.DataElement[r].y,d=e*(c*u-a*m),p=a*d,b=(c-a)*(t*u-a*e)*m,f=p+b;return t*n.multiplier*d/f}}function Ne(n,t,e){return t*n.multiplier/e}function ur(n,t,e){return t*e/n.multiplier}function Ta(n,t){let[e,o]=Pa(t),r=e,i=o,a=0,u=t;for(;r<i;){if(a=Math.floor((i+r)/2),a<=0||a>De-2)return[a,a,!1];let c=n.DataElement[a].x,m=n.DataElement[a-1].x,d=n.DataElement[a+1].x;if(u===c)return[a,a,!0];if(u===m)return[a-1,a-1,!0];if(u===d)return[a+1,a+1,!0];if(u<m)i=a-1;else{if(u>m&&u<c)return[a-1,a,!0];if(u>c&&u<d)return[a,a+1,!0];r=a+1}}return[a,a,!1]}function xa(n,t){let[e,o]=Ia(t),r=e,i=o,a=0,u=t;for(;r<=i;){if(a=Math.floor((i+r)/2),a<=0||a>=De-2)return[a,a,!1];let c=n.DataElement[a].y,m=n.DataElement[a-1].y,d=n.DataElement[a+1].y;if(u===c)return[a,a,!0];if(u===m)return[a-1,a-1,!0];if(u===d)return[a+1,a+1,!0];if(u<d)r=a+1;else{if(u<m&&u>c)return[a-1,a,!0];if(u<c&&u>d)return[a,a+1,!0];i=a-1}}return[a,a,!1]}function cr(n,t,e,o){let r=o?t+e:t-e,[i,a,u]=Ta(n,r);if(!u)return[0,0,!1,u];if(i===a)return[n.DataElement[a].price,n.DataElement[a].y,!1,u];{let c=n.DataElement[i].x,m=n.DataElement[a].x,d=n.DataElement[i].price,p=n.DataElement[a].price,b=n.DataElement[i].y,f=n.DataElement[a].y;if(t>=c&&t<=m)return o?[p,f,!0,u]:[d,b,!0,u];{let y,h;return o?(y=d+(p-d)*(t-c)/(m-c),h=b-(r-c)*n.multiplier/p):(y=d+(p-d)*(t-c)/(m-c),h=f+(m-r)*n.multiplier/d),[y,h,!1,u]}}}function Sa(n,t,e,o){let r=o?t-e:t+e,[i,a,u]=xa(n,r);if(!u)return[0,0,!1,u];if(i===a)return[n.DataElement[a].price,n.DataElement[a].x,!1,u];{let c=n.DataElement[i].x,m=n.DataElement[a].x,d=n.DataElement[i].price,p=n.DataElement[a].price,b=n.DataElement[i].y,f=n.DataElement[a].y;if(t>=f&&t<=b)return o?[p,m,!0,u]:[d,c,!0,u];{let y,h;return o?(y=d+(p-d)*(b-t)/(b-f),h=c+p*(b-r)/n.multiplier):(y=d+(p-d)*(b-t)/(b-f),h=m-d*(r-f)/n.multiplier),[y,h,!1,u]}}}function La(n,t){let e=cr(n,t,0,!1);return e[3]?e[0]:0}function mr(n,t,e,o){let r=hn(n,t,e),i=Ne(n,t,r),a=Ne(n,e,r),u=Ne(n,o,r),c=!0,[m,d,p,b]=cr(n,i,u,c);if(!b)return 0;if(p)return o*n.multiplier/m;{let f=a-d;return ur(n,f,r)}}function lr(n,t,e,o){let r=hn(n,t,e),i=Ne(n,t,r),a=Ne(n,e,r),u=Ne(n,o,r),c=!1,[m,d,p,b]=Sa(n,a,u,c);if(!b)return 0;if(p)return o*m/n.multiplier;{let f=i-d;return ur(n,f,r)}}function _a(n){let t=wa.decode(n);return{accountType:t.accountType.toNumber(),status:t.status.toNumber(),multiplier:t.multiplier.toNumber(),validDataCount:t.validDataCount.toNumber(),DataElement:t.DataElement.map(e=>({x:e.x.toNumber(),y:e.y.toNumber(),price:e.price.toNumber()}))}}function dr(n,t,e,o){let r=La(n,Ne(n,t,hn(n,t,e)))/n.multiplier;return o?r:1/r}var Ft=class{constructor({connection:t}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let t=await this.connection.getAccountInfo(ke);t&&(this._layoutData=_a(t==null?void 0:t.data))}}};var qt=M("Raydium_liquidity_instruction");function pr(n){let{poolKeys:t,userKeys:e,amountIn:o,amountOut:r,fixedSide:i}=n,{version:a}=t;if(a===4||a===5){let u={poolKeys:t,userKeys:e};if(i==="in")return Ma(O(S({},u),{amountIn:o,minAmountOut:r}),a);if(i==="out")return Ba(O(S({},u),{maxAmountIn:o,amountOut:r}),a);qt.logWithError("invalid params","params",n)}throw qt.logWithError("invalid version","poolKeys.version",a),new Error("invalid version")}function fr(n){let t=R([v("instruction"),v("simulateType")]),e=Buffer.alloc(t.span);t.encode({instruction:12,simulateType:0},e);let o=[s({pubkey:n.id,isWritable:!1}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders,isWritable:!1}),s({pubkey:n.baseVault,isWritable:!1}),s({pubkey:n.quoteVault,isWritable:!1}),s({pubkey:n.lpMint,isWritable:!1}),s({pubkey:n.marketId,isWritable:!1})];return new Pe({programId:n.programId,keys:o,data:e})}function Ma({poolKeys:n,userKeys:t,amountIn:e,minAmountOut:o},r){let i=Buffer.alloc(dn.span);dn.encode({instruction:9,amountIn:x(e),minAmountOut:x(o)},i);let a=[s({pubkey:wn,isWritable:!1}),s({pubkey:n.id}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders})];return r===4&&a.push(s({pubkey:n.targetOrders})),a.push(s({pubkey:n.baseVault}),s({pubkey:n.quoteVault})),r===5&&a.push(s({pubkey:ke})),a.push(s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.marketBaseVault}),s({pubkey:n.marketQuoteVault}),s({pubkey:n.marketAuthority,isWritable:!1}),s({pubkey:t.tokenAccountIn}),s({pubkey:t.tokenAccountOut}),s({pubkey:t.owner,isWritable:!1})),new Pe({programId:n.programId,keys:a,data:i})}function Ba({poolKeys:n,userKeys:t,maxAmountIn:e,amountOut:o},r){let i=Buffer.alloc(pn.span);pn.encode({instruction:11,maxAmountIn:x(e),amountOut:x(o)},i);let a=[s({pubkey:Ra.programId,isWritable:!1}),s({pubkey:n.id}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders}),s({pubkey:n.targetOrders}),s({pubkey:n.baseVault}),s({pubkey:n.quoteVault})];return r===5&&a.push(s({pubkey:ke})),a.push(s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.marketBaseVault}),s({pubkey:n.marketQuoteVault}),s({pubkey:n.marketAuthority,isWritable:!1}),s({pubkey:t.tokenAccountIn}),s({pubkey:t.tokenAccountOut}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})),new Pe({programId:n.programId,keys:a,data:i})}function br(n){let i=n,{owner:t}=i,e=ee(i,["owner"]),o=Buffer.alloc(fn.span);fn.encode({instruction:10,nonce:e.nonce},o);let r=[...Oe,s({pubkey:e.targetOrders}),s({pubkey:e.withdrawQueue}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.lpMint}),s({pubkey:e.baseMint,isWritable:!1}),s({pubkey:e.quoteMint,isWritable:!1}),s({pubkey:e.baseVault}),s({pubkey:e.quoteVault}),s({pubkey:e.lpVault}),s({pubkey:e.marketId,isWritable:!1}),s({pubkey:t,isSigner:!0})];return new Pe({programId:e.programId,keys:r,data:o})}function yr(n){let{poolKeys:t,userKeys:e,startTime:o}=n,r=Buffer.alloc(bn.span);bn.encode({instruction:0,nonce:t.nonce,startTime:x(o)},r);let i=[...Oe,s({pubkey:t.id}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.openOrders}),s({pubkey:t.lpMint}),s({pubkey:t.baseMint,isWritable:!1}),s({pubkey:t.quoteMint,isWritable:!1}),s({pubkey:t.baseVault,isWritable:!1}),s({pubkey:t.quoteVault,isWritable:!1}),s({pubkey:t.withdrawQueue}),s({pubkey:t.targetOrders}),s({pubkey:e.lpTokenAccount}),s({pubkey:t.lpVault,isWritable:!1}),s({pubkey:t.marketProgramId,isWritable:!1}),s({pubkey:t.marketId,isWritable:!1}),s({pubkey:e.payer,isSigner:!0})];return new Pe({programId:t.programId,keys:i,data:r})}function gr(n){let{poolKeys:t,userKeys:e,baseAmountIn:o,quoteAmountIn:r,fixedSide:i}=n,{version:a}=t;if(a===4||a===5){let u=Buffer.alloc(yn.span);yn.encode({instruction:3,baseAmountIn:x(o),quoteAmountIn:x(r),fixedSide:x(i==="base"?0:1)},u);let c=[s({pubkey:wn,isWritable:!1}),s({pubkey:t.id}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.openOrders,isWritable:!1}),s({pubkey:t.targetOrders}),s({pubkey:t.lpMint}),s({pubkey:t.baseVault}),s({pubkey:t.quoteVault})];return a===5&&c.push(s({pubkey:ke})),c.push(s({pubkey:t.marketId,isWritable:!1}),s({pubkey:e.baseTokenAccount}),s({pubkey:e.quoteTokenAccount}),s({pubkey:e.lpTokenAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})),new Pe({programId:t.programId,keys:c,data:u})}return qt.logWithError("invalid version","poolKeys.version",a),new Pe({programId:t.programId,keys:[]})}function hr(n){let{poolKeys:t,userKeys:e,amountIn:o}=n,{version:r}=t;if(r===4||r===5){let i=Buffer.alloc(gn.span);gn.encode({instruction:4,amountIn:x(o)},i);let a=[s({pubkey:wn,isWritable:!1}),s({pubkey:t.id}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.openOrders}),s({pubkey:t.targetOrders}),s({pubkey:t.lpMint}),s({pubkey:t.baseVault}),s({pubkey:t.quoteVault})];return r===5?a.push(s({pubkey:ke})):a.push(s({pubkey:t.withdrawQueue}),s({pubkey:t.lpVault})),a.push(s({pubkey:t.marketProgramId,isWritable:!1}),s({pubkey:t.marketId}),s({pubkey:t.marketBaseVault}),s({pubkey:t.marketQuoteVault}),s({pubkey:t.marketAuthority,isWritable:!1}),s({pubkey:e.lpTokenAccount}),s({pubkey:e.baseTokenAccount}),s({pubkey:e.quoteTokenAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0}),s({pubkey:t.marketEventQueue}),s({pubkey:t.marketBids}),s({pubkey:t.marketAsks})),new Pe({programId:t.programId,keys:a,data:i})}return qt.logWithError("invalid version","poolKeys.version",r),new Pe({programId:t.programId,keys:[]})}import{OpenOrders as xd}from"@project-serum/serum";import at from"bn.js";import{PublicKey as wr}from"@solana/web3.js";var kn=M("Raydium_liquidity_serum"),kr="9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin",Oa=new wr(kr),kd={[kr]:3},Fa={3:Oa};function Pr(n){let t=sr[n];return t||kn.logWithError("invalid version","version",n),t}function Ir(n){let t=Fa[n];return t||kn.logWithError("invalid version","version",n),t}async function Ar({programId:n,marketId:t}){let e=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=e.concat(Buffer.from([o]),Buffer.alloc(7));r=await wr.createProgramAddress(i,n)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}throw kn.logWithError("unable to find a viable program address nonce","params",{programId:n,marketId:t}),new Error("unable to find a viable program address nonce")}var Pn=M("Raydium_liquidity_util");function In(n,t){let e=n instanceof F?n.token:G.WSOL,{baseMint:o,quoteMint:r}=t;if(e.mint.equals(o))return"base";if(e.mint.equals(r))return"quote";let i=`liquidity getTokenSide - token not match with pool, params: ${JSON.stringify({token:e.mint,baseMint:o,quoteMint:r})}`;throw console.error(i),new Error(i)}function Ve(n,t){let{baseMint:e,quoteMint:o}=t;return n.mint.equals(e)||n.mint.equals(o)}function An(n){let{status:t,startTime:e}=n,o=t.toNumber();return{[0]:{swap:!1,addLiquidity:!1,removeLiquidity:!1},[1]:{swap:!0,addLiquidity:!0,removeLiquidity:!0},[2]:{swap:!1,addLiquidity:!1,removeLiquidity:!1},[3]:{swap:!1,addLiquidity:!1,removeLiquidity:!0},[4]:{swap:!1,addLiquidity:!0,removeLiquidity:!0},[5]:{swap:!1,addLiquidity:!0,removeLiquidity:!0},[6]:{swap:!0,addLiquidity:!0,removeLiquidity:!0},[7]:{swap:Date.now()/1e3>=e.toNumber(),addLiquidity:!0,removeLiquidity:!0}}[o]||{swap:!1,addLiquidity:!1,removeLiquidity:!1}}function qa(n){let t=ar[n];return t||Pn.logWithError("invalid version","version",n),t}async function _e({name:n,programId:t,marketId:e}){let{publicKey:o}=await he([t.toBuffer(),e.toBuffer(),Buffer.from(n,"utf-8")],t);return o}async function Na({programId:n}){return he([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],n)}async function Tn({version:n,marketId:t,baseMint:e,quoteMint:o}){let r=qa(n),[i,a,u]=[V({publicKey:t}),V({publicKey:e,transformSol:!0}),V({publicKey:o,transformSol:!0})],c=await _e({name:"amm_associated_seed",programId:r,marketId:i}),m=await _e({name:"lp_mint_associated_seed",programId:r,marketId:i}),{publicKey:d,nonce:p}=await Na({programId:r}),b=await _e({name:"coin_vault_associated_seed",programId:r,marketId:i}),f=await _e({name:"pc_vault_associated_seed",programId:r,marketId:i}),y=await _e({name:"temp_lp_token_associated_seed",programId:r,marketId:i}),h=await _e({name:"open_order_associated_seed",programId:r,marketId:i}),L=await _e({name:"target_associated_seed",programId:r,marketId:i}),g=await _e({name:"withdraw_associated_seed",programId:r,marketId:i}),k=Pr(n),_=Ir(k),{publicKey:P}=await Ar({programId:_,marketId:i});return{id:c,baseMint:a,quoteMint:u,lpMint:m,version:n,programId:r,authority:d,nonce:p,baseVault:b,quoteVault:f,lpVault:y,openOrders:h,targetOrders:L,withdrawQueue:g,marketVersion:k,marketProgramId:_,marketId:i,marketAuthority:P}}async function xr({connection:n,pools:t}){let e=t.map(r=>fr(r));return(await so(n,e,"GetPoolData")).map(r=>{let i=uo(r,"GetPoolData"),a=new at(ge(i,"status")),u=Number(ge(i,"coin_decimals")),c=Number(ge(i,"pc_decimals")),m=Number(ge(i,"lp_decimals")),d=new at(ge(i,"pool_coin_amount")),p=new at(ge(i,"pool_pc_amount")),b=new at(ge(i,"pool_lp_supply")),f="0";try{f=ge(i,"pool_open_time")}catch{f="0"}return{status:a,baseDecimals:u,quoteDecimals:c,lpDecimals:m,baseReserve:d,quoteReserve:p,lpSupply:b,startTime:new at(f)}})}function Sr(n,t,e){return Da(n.token,t.token,e)}function Da(n,t,e){let{baseMint:o,quoteMint:r}=e,i=Tr(n,e),a=Tr(t,e);return i===a&&Pn.logWithError("tokens not match with pool","params",{tokenA:n.mint,tokenB:t.mint,baseMint:o,quoteMint:r}),[i,a]}function Tr(n,t){let{baseMint:e,quoteMint:o}=t;return n.mint.equals(e)?"base":n.mint.equals(o)?"quote":(Pn.logWithError("token not match with pool","params",{token:n.mint,baseMint:e,quoteMint:o}),"base")}var Lr=n=>n==="a"||n==="b";var st=class extends re{constructor(e){super(e);this._poolInfos=[];this._poolInfoMap=new Map;this._pairsInfo=[];this._pairsInfoMap=new Map;this._lpTokenMap=new Map;this._lpPriceMap=new Map;this._officialIds=new Set;this._unOfficialIds=new Set;this._sdkParseInfoCache=new Map;this._stableLayout=new Ft({connection:this.scope.connection})}async load(e){if(await this.scope.fetchLiquidity(e==null?void 0:e.forceUpdate),!this.scope.apiData.liquidityPools)return;let{data:o}=this.scope.apiData.liquidityPools,[r,i]=[o.official||[],o.unOfficial||[]];this._poolInfos=[...r,...i],this._officialIds=new Set(r.map(a=>{var c,m;let u=`${(c=this.scope.token.allTokenMap.get(a.baseMint))==null?void 0:c.symbol} - ${(m=this.scope.token.allTokenMap.get(a.quoteMint))==null?void 0:m.symbol}`;return this._poolInfoMap.set(a.id,a),this._lpTokenMap.set(a.lpMint,new G({mint:a.lpMint,decimals:a.lpDecimals,symbol:u,name:`${u} LP`})),a.id})),this._unOfficialIds=new Set(i.map(a=>{var c,m;let u=`${(c=this.scope.token.allTokenMap.get(a.baseMint))==null?void 0:c.symbol} - ${(m=this.scope.token.allTokenMap.get(a.quoteMint))==null?void 0:m.symbol}`;return this._poolInfoMap.set(a.id,a),this._lpTokenMap.set(a.lpMint,new G({mint:a.lpMint,decimals:a.lpDecimals,symbol:u,name:`${u} LP`})),a.id}))}async loadPairs(e){var o;return await this.scope.fetchPairs(e==null?void 0:e.forceUpdate),this._pairsInfo=((o=this.scope.apiData.liquidityPairsInfo)==null?void 0:o.data)||[],this._pairsInfoMap=new Map(this._pairsInfo.map(r=>{let i=this._lpTokenMap.get(r.lpMint),a=i&&r.lpPrice?$e({token:i,numberPrice:r.lpPrice,decimalDone:!0}):null;return a&&this._lpPriceMap.set(r.lpMint,a),[r.ammId,r]})),this._pairsInfo}get allPools(){return this._poolInfos}get allPoolIdSet(){return{official:this._officialIds,unOfficial:this._unOfficialIds}}get allPoolMap(){return this._poolInfoMap}get allPairs(){return this._pairsInfo}get allPairsMap(){return this._pairsInfoMap}get lpTokenMap(){return this._lpTokenMap}get lpPriceMap(){return this._lpPriceMap}async fetchMultipleInfo(e){return await this._stableLayout.initStableModelLayout(),await xr(O(S({},e),{connection:this.scope.connection}))}async sdkParseJsonLiquidityInfo(e){if(!e.length)return[];let o=e.map(r=>r.id).join("-");if(this._sdkParseInfoCache.has(o))return this._sdkParseInfoCache.get(o);try{let i=(await this.fetchMultipleInfo({pools:e.map(me)})).map((a,u)=>S(S({jsonInfo:e[u]},me(e[u])),a));return this._sdkParseInfoCache.set(o,i),i}catch(r){return console.error(r),[]}}computeAmountOut({poolKeys:e,poolInfo:o,amountIn:r,outputToken:i,slippage:a}){this.checkDisabled();let u=M("Raydium_computeAmountOut"),c=r.token,m=i;(!Ve(c,e)||!Ve(m,e))&&u.logWithError("token not match with pool","poolKeys",e);let{baseReserve:d,quoteReserve:p}=o;this.logDebug("baseReserve:",d.toString(),"quoteReserve:",p.toString());let b=r.token;this.logDebug("inputToken:",b),this.logDebug("amountIn:",r.toFixed()),this.logDebug("outputToken:",i),this.logDebug("slippage:",`${a.toSignificant()}%`);let f=[d,p],y=In(r,e);y==="quote"&&f.reverse(),this.logDebug("input side:",y);let[h,L]=f,g;if(e.version===4)g=new Q({baseToken:b,denominator:h,quoteToken:i,numerator:L});else{let j=dr(this._stableLayout.stableModelData,d.toNumber(),p.toNumber(),!1);g=new Q({baseToken:b,denominator:y==="quote"?new Ie(j*1e6):new Ie(1e6),quoteToken:i,numerator:y==="quote"?new Ie(1e6):new Ie(j*1e6)})}this.logDebug("currentPrice:",`1 ${b.symbol} \u2248 ${g.toFixed()} ${i.symbol}`),this.logDebug("currentPrice invert:",`1 ${i.symbol} \u2248 ${g.invert().toFixed()} ${b.symbol}`);let k=r.raw,_=ae,P=ae;if(!k.isZero())if(e.version===4){P=k.mul(nr).div(or);let j=k.sub(P),ne=h.add(j);_=L.mul(j).div(ne)}else{P=k.mul(new Ie(2)).div(new Ie(1e4));let j=k.sub(P),ne=y==="quote"?mr:lr;_=new Ie(ne(this._stableLayout.stableModelData,p.toNumber(),d.toNumber(),j.toNumber()))}let N=new oe(pe).add(a).invert().mul(_).quotient,D=new F(i,_),$=new F(i,N);this.logDebug("amountOut:",D.toFixed(),"minAmountOut:",$.toFixed());let E=new Q({baseToken:b,denominator:k.sub(P),quoteToken:i,numerator:_});!k.isZero()&&!_.isZero()&&(E=new Q({baseToken:b,denominator:k.sub(P),quoteToken:i,numerator:_}),this.logDebug("executionPrice:",`1 ${b.symbol} \u2248 ${E.toFixed()} ${i.symbol}`),this.logDebug("executionPrice invert:",`1 ${i.symbol} \u2248 ${E.invert().toFixed()} ${b.symbol}`));let U=new oe(parseInt(String(Math.abs(parseFloat(E.toFixed())-parseFloat(g.toFixed()))*1e9)),parseInt(String(parseFloat(g.toFixed())*1e9))),X=new F(b,P);return{amountOut:D,minAmountOut:$,currentPrice:g,executionPrice:E,priceImpact:U,fee:X}}async computePairAmount({poolId:e,amount:o,anotherToken:r,slippage:i}){let a=V({publicKey:e}),u=this._poolInfoMap.get(a.toBase58());u||this.logAndCreateError("pool not found",a.toBase58());let c=(await this.sdkParseJsonLiquidityInfo([u]))[0];c||this.logAndCreateError("pool parseInfo not found",a.toBase58());let{baseReserve:m,quoteReserve:d}=c;this.logDebug("baseReserve:",m.toString(),"quoteReserve:",d.toString());let p=o.token;this.logDebug("tokenIn:",p,"amount:",o.toFixed(),"anotherToken:",r,"slippage:",`${i.toSignificant()}%`);let b=In(o,me(u));this.logDebug("input side:",b);let f=ae;o.isZero()||(f=b==="base"?Wt(o.raw.mul(d),m):Wt(o.raw.mul(m),d));let h=new oe(pe).add(i).mul(f).quotient,L=new F(r,f),g=new F(r,h);return this.logDebug("anotherAmount:",L.toFixed(),"maxAnotherAmount:",g.toFixed()),{anotherAmount:L,maxAnotherAmount:g}}async swapWithAMM(e){let{poolKeys:o,payer:r,amountIn:i,amountOut:a,fixedSide:u,config:c}=e;this.logDebug("amountIn:",i),this.logDebug("amountOut:",a),(i.isZero()||a.isZero())&&this.logAndCreateError("amounts must greater than zero","amounts",{amountIn:i.toFixed(),amountOut:a.toFixed()});let{account:m}=this.scope,d=this.createTxBuilder(),{bypassAssociatedCheck:p=!1}=c||{},[b,f]=[i.token,a.token],y=await m.getCreatedTokenAccount({mint:b.mint,associatedOnly:!1}),h=await m.getCreatedTokenAccount({mint:f.mint}),[L,g]=[i.raw,a.raw],N=await m.handleTokenAccount({side:"in",amount:L,mint:b.mint,tokenAccount:y,bypassAssociatedCheck:p}),{tokenAccount:k}=N,_=ee(N,["tokenAccount"]);d.addInstruction(_);let D=await m.handleTokenAccount({side:"out",amount:0,mint:f.mint,tokenAccount:h,payer:r,bypassAssociatedCheck:p}),{tokenAccount:P}=D,q=ee(D,["tokenAccount"]);return d.addInstruction(q),d.addInstruction({instructions:[pr({poolKeys:o,userKeys:{tokenAccountIn:k,tokenAccountOut:P,owner:this.scope.ownerPubKey},amountIn:L,amountOut:g,fixedSide:u})]}),d.buildMultiTx({extInfo:{amountOut:a}})}async createPool(e){this.checkDisabled(),this.scope.checkOwner(),e.version!==4&&this.logAndCreateError("invalid version","poolKeys.version",e.version);let o=this.createTxBuilder(),r=await Tn(e);return await o.addInstruction({instructions:[br(O(S({},r),{owner:this.scope.ownerPubKey}))]}).build()}async initPool(e){e.version!==4&&this.logAndCreateError("invalid version","poolKeys.version",e.version);let{baseAmount:o,quoteAmount:r,startTime:i=0,config:a}=e,u=await Tn(e),{baseMint:c,quoteMint:m,lpMint:d,baseVault:p,quoteVault:b}=u,f=this.createTxBuilder(),{account:y}=this.scope,h=!!(a!=null&&a.bypassAssociatedCheck),L=await y.getCreatedTokenAccount({mint:c,associatedOnly:!1}),g=await y.getCreatedTokenAccount({mint:m,associatedOnly:!1});!L&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",y.tokenAccounts);let k=await y.getCreatedTokenAccount({mint:d,associatedOnly:!1}),E=await y.handleTokenAccount({side:"in",amount:o.raw,mint:c,tokenAccount:L,bypassAssociatedCheck:h}),{tokenAccount:_}=E,P=ee(E,["tokenAccount"]);f.addInstruction(P);let U=await y.handleTokenAccount({side:"in",amount:r.raw,mint:m,tokenAccount:g,bypassAssociatedCheck:h}),{tokenAccount:q}=U,N=ee(U,["tokenAccount"]);f.addInstruction(N);let X=await y.handleTokenAccount({side:"out",amount:0,mint:d,tokenAccount:k,bypassAssociatedCheck:h}),{tokenAccount:D}=X,$=ee(X,["tokenAccount"]);return f.addInstruction($),f.addInstruction({instructions:[Ke({source:_,destination:p,owner:this.scope.ownerPubKey,amount:o.raw}),Ke({source:q,destination:b,owner:this.scope.ownerPubKey,amount:r.raw}),yr({poolKeys:u,userKeys:{lpTokenAccount:D,payer:this.scope.ownerPubKey},startTime:i})]}),await f.build()}async addLiquidity(e){let{poolId:o,amountInA:r,amountInB:i,fixedSide:a,config:u}=e,c=V({publicKey:o}),m=this.allPools.find(ft=>ft.id===c.toBase58());m||this.logAndCreateError("pool not found",o);let p=(await this.sdkParseJsonLiquidityInfo([m]))[0];p||this.logAndCreateError("pool parse error",p),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:b}=this.scope,f=(u==null?void 0:u.bypassAssociatedCheck)||!1,[y,h]=[r.token,i.token],L=await b.getCreatedTokenAccount({mint:y.mint,associatedOnly:!1}),g=await b.getCreatedTokenAccount({mint:h.mint,associatedOnly:!1});!L&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",b.tokenAccounts);let k=await b.getCreatedTokenAccount({mint:p.lpMint}),_=[y,h],P=[L,g],q=[r.raw,i.raw],[N]=Sr(r,i,p),D="base";(!["quote","base"].includes(N)||!Lr(a))&&this.logAndCreateError("invalid fixedSide","fixedSide",a),N==="quote"?(_.reverse(),P.reverse(),q.reverse(),D=a==="a"?"quote":"base"):N==="base"&&(D=a==="a"?"base":"quote");let[$,E]=_,[U,X]=P,[j,ne]=q,ie=this.createTxBuilder(),Ce=await b.handleTokenAccount({side:"in",amount:j,mint:$.mint,tokenAccount:U,bypassAssociatedCheck:f}),{tokenAccount:Ae}=Ce,ce=ee(Ce,["tokenAccount"]);ie.addInstruction(ce);let We=await b.handleTokenAccount({side:"in",amount:ne,mint:E.mint,tokenAccount:X,bypassAssociatedCheck:f}),{tokenAccount:fe}=We,de=ee(We,["tokenAccount"]);ie.addInstruction(de);let Ue=await b.handleTokenAccount({side:"out",amount:0,mint:p.lpMint,tokenAccount:k,bypassAssociatedCheck:f}),{tokenAccount:dt}=Ue,pt=ee(Ue,["tokenAccount"]);return ie.addInstruction(pt),ie.addInstruction({instructions:[gr({poolKeys:p,userKeys:{baseTokenAccount:Ae,quoteTokenAccount:fe,lpTokenAccount:dt,owner:this.scope.ownerPubKey},baseAmountIn:j,quoteAmountIn:ne,fixedSide:D})]}),await ie.build()}async removeLiquidity(e){let{poolId:o,amountIn:r,config:i}=e,a=V({publicKey:o}),u=this.allPools.find(E=>E.id===a.toBase58());u||this.logAndCreateError("pool not found",o);let m=(await this.sdkParseJsonLiquidityInfo([u]))[0];m||this.logAndCreateError("pool pass error",m);let{baseMint:d,quoteMint:p,lpMint:b}=m;this.logDebug("amountIn:",r),r.isZero()&&this.logAndCreateError("amount must greater than zero","amountIn",r.toFixed()),r.token.mint.equals(b)||this.logAndCreateError("amountIn's token not match lpMint","amountIn",r);let{account:f}=this.scope,y=await f.getCreatedTokenAccount({mint:b,associatedOnly:!1});y||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",f.tokenAccounts);let h=await f.getCreatedTokenAccount({mint:d}),L=await f.getCreatedTokenAccount({mint:p}),g=this.createTxBuilder(),k=(i==null?void 0:i.bypassAssociatedCheck)||!1,D=await f.handleTokenAccount({side:"out",amount:0,mint:d,tokenAccount:h,bypassAssociatedCheck:k}),{tokenAccount:_}=D,P=ee(D,["tokenAccount"]);g.addInstruction(P);let $=await f.handleTokenAccount({side:"out",amount:0,mint:p,tokenAccount:L,bypassAssociatedCheck:k}),{tokenAccount:q}=$,N=ee($,["tokenAccount"]);return g.addInstruction(N),g.addInstruction({instructions:[va.requestUnits({units:4e5,additionalFee:0}),hr({poolKeys:m,userKeys:{lpTokenAccount:y,baseTokenAccount:_,quoteTokenAccount:q,owner:this.scope.ownerPubKey},amountIn:r.raw})]}),await g.build()}lpMintToTokenAmount({poolId:e,amount:o,decimalDone:r}){let i=V({publicKey:e});i||this.logAndCreateError("pool not found");let a=this._poolInfoMap.get(i.toBase58()),u=se(o),c=new G({mint:a.lpMint,decimals:a.lpDecimals}),m=r?new T(u.numerator,u.denominator):new T(u.numerator,u.denominator).mul(new Ie(10).pow(new Ie(c.decimals)));return new F(c,Te(m))}getFixedSide({poolId:e,inputMint:o}){let[r,i]=[V({publicKey:e}),V({publicKey:o})],a=this._poolInfoMap.get(r.toBase58());a||this.logAndCreateError("pool not found",r.toBase58());let u=a.baseMint===i.toBase58();return(i.equals(xe)||i.equals(W))&&(u=!u),u?"a":"b"}};import{PublicKey as qr}from"@solana/web3.js";import{intersection as Nr,xor as Ua}from"lodash";import{PublicKey as Ea}from"@solana/web3.js";var Ka="routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS",ut=new Ea(Ka),_r=["amm","serum","route"],Rr=[zn,At,xe,Xn,Hn,eo,to,Zn,no].map(n=>n.toBase58());import{TOKEN_PROGRAM_ID as vt}from"@solana/spl-token";import{SystemProgram as Mr,TransactionInstruction as Br}from"@solana/web3.js";var Nt=R([v("instruction"),l("amountIn"),l("amountOut")]),Dt=R([v("instruction")]);var Va=M("Raydium_route_instruction");function Or(n){let{fixedSide:t}=n;if(t==="in")return[Ca(n),Wa(n)];throw Va.logWithError("invalid params","params",n),new Error(`invalid params, params: ${n}`)}function Ca({fromPoolKeys:n,toPoolKeys:t,userKeys:e,amountIn:o,amountOut:r}){let i=Buffer.alloc(Nt.span),a;return n.version===4?(Nt.encode({instruction:0,amountIn:x(o),amountOut:x(r)},i),a=[s({pubkey:Mr.programId,isWritable:!1}),s({pubkey:vt,isWritable:!1}),s({pubkey:n.programId,isWritable:!1}),s({pubkey:n.id}),s({pubkey:t.id,isWritable:!1}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders}),s({pubkey:n.baseVault}),s({pubkey:n.quoteVault}),s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.marketBaseVault}),s({pubkey:n.marketQuoteVault}),s({pubkey:n.marketAuthority,isWritable:!1}),s({pubkey:e.inTokenAccount}),s({pubkey:e.middleTokenAccount}),s({pubkey:e.middleStatusAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})]):(Nt.encode({instruction:2,amountIn:x(o),amountOut:x(r)},i),a=[s({pubkey:Mr.programId,isWritable:!1}),s({pubkey:vt,isWritable:!1}),s({pubkey:n.programId,isWritable:!1}),s({pubkey:n.id}),s({pubkey:t.id,isWritable:!1}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders}),s({pubkey:n.baseVault}),s({pubkey:n.quoteVault}),s({pubkey:ke,isWritable:!1}),s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.id}),s({pubkey:n.id}),s({pubkey:n.id}),s({pubkey:e.inTokenAccount}),s({pubkey:e.middleTokenAccount}),s({pubkey:e.middleStatusAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})]),new Br({programId:ut,keys:a,data:i})}function Wa({fromPoolKeys:n,toPoolKeys:t,userKeys:e}){let o=Buffer.alloc(Dt.span),r;return t.version===4?(Dt.encode({instruction:1},o),r=[s({pubkey:vt,isWritable:!1}),s({pubkey:t.programId,isWritable:!1}),s({pubkey:n.id,isWritable:!1}),s({pubkey:t.id}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.openOrders}),s({pubkey:t.baseVault}),s({pubkey:t.quoteVault}),s({pubkey:t.marketProgramId,isWritable:!1}),s({pubkey:t.marketId}),s({pubkey:t.marketBids}),s({pubkey:t.marketAsks}),s({pubkey:t.marketEventQueue}),s({pubkey:t.marketBaseVault}),s({pubkey:t.marketQuoteVault}),s({pubkey:t.marketAuthority,isWritable:!1}),s({pubkey:e.middleTokenAccount}),s({pubkey:e.outTokenAccount}),s({pubkey:e.middleStatusAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})]):(Dt.encode({instruction:3},o),r=[s({pubkey:vt,isWritable:!1}),s({pubkey:t.programId,isWritable:!1}),s({pubkey:n.id,isWritable:!1}),s({pubkey:t.id}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.openOrders}),s({pubkey:t.baseVault}),s({pubkey:t.quoteVault}),s({pubkey:ke,isWritable:!1}),s({pubkey:t.marketProgramId,isWritable:!1}),s({pubkey:t.marketId}),s({pubkey:t.marketBids}),s({pubkey:t.marketAsks}),s({pubkey:t.marketEventQueue}),s({pubkey:t.id}),s({pubkey:t.id}),s({pubkey:t.id}),s({pubkey:e.middleTokenAccount}),s({pubkey:e.outTokenAccount}),s({pubkey:e.middleStatusAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})]),new Br({programId:ut,keys:r,data:o})}async function Fr({programId:n,fromPoolId:t,middleMint:e,owner:o}){let{publicKey:r}=await he([t.toBuffer(),e.toBuffer(),o.toBuffer()],n);return r}var ct=class extends re{constructor(t){super(t)}computeRouteAmountOut({fromPoolKeys:t,toPoolKeys:e,fromPoolInfo:o,toPoolInfo:r,amountIn:i,outputToken:a,slippage:u}){let{swap:c}=An(o),{swap:m}=An(r);(!c||!m)&&this.logAndCreateError("pools swap not enabled","pools",{fromPoolKeys:t,toPoolKeys:e,fromPoolInfo:o,toPoolInfo:r});let d=i.token,p=a;(!Ve(d,t)||!Ve(p,e))&&this.logAndCreateError("pools cannot be routed","pools",{fromPoolKeys:t,toPoolKeys:e});let b=[t.baseMint.toBase58(),t.quoteMint.toBase58()],f=[e.baseMint.toBase58(),e.quoteMint.toBase58()],y=[...b,...f],h=[o.baseDecimals,o.quoteDecimals,r.baseDecimals,r.quoteDecimals],[L,g]=[d.mint.toBase58(),p.mint.toBase58()],k=Ua(b,f);(k.length!==2||!k.includes(L)||!k.includes(g))&&this.logAndCreateError("xor tokens not match","pools",{fromPoolKeys:t,toPoolKeys:e});let _=Nr(b,f);_.length!==1&&this.logAndCreateError("cannot found middle token of two pools","pools",{fromPoolKeys:t,toPoolKeys:e});let P=_[0],q=y.indexOf(P);q===-1&&this.logAndCreateError("cannot found middle token","pools",{fromPoolKeys:t,toPoolKeys:e});let N=h[q],D=new qr(P),$=new G({mint:D,decimals:N});this.logInfo("from pool:",t),this.logInfo("to pool:",e),this.logInfo("intersection mints:",_),this.logInfo("xor mints:",k),this.logInfo("middleMint:",P);let{minAmountOut:E,priceImpact:U,fee:X}=this.scope.liquidity.computeAmountOut({poolKeys:t,poolInfo:o,amountIn:i,outputToken:$,slippage:u}),{amountOut:j,minAmountOut:ne,priceImpact:ie,fee:Ae}=this.scope.liquidity.computeAmountOut({poolKeys:e,poolInfo:r,amountIn:E,outputToken:a,slippage:u}),ce=null,[fe,de]=[i.raw,j.raw];return!fe.isZero()&&!de.isZero()&&(ce=new Q({baseToken:d,denominator:fe,quoteToken:a,numerator:de}),this.logDebug("executionPrice:",`1 ${d.symbol} \u2248 ${ce.toFixed()} ${a.symbol}`),this.logDebug("executionPrice invert:",`1 ${a.symbol} \u2248 ${ce.invert().toFixed()} ${d.symbol}`)),{amountOut:j,minAmountOut:ne,executionPrice:ce,priceImpact:U.add(ie),fee:[X,Ae]}}async swapWithRoute(t){let{fromPoolKeys:e,toPoolKeys:o,amountIn:r,amountOut:i,fixedSide:a,config:u}=t;this.logDebug("amountIn:",r,"amountOut:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amounts",{amountIn:r.toFixed(),amountOut:i.toFixed()});let{account:c}=this.scope,{bypassAssociatedCheck:m=!1}=u||{},[d,p]=[r.token,i.token],b=await this.scope.account.getCreatedTokenAccount({mint:d.mint,associatedOnly:!1}),f=await this.scope.account.getCreatedTokenAccount({mint:p.mint}),y=[e.baseMint.toBase58(),e.quoteMint.toBase58()],h=[o.baseMint.toBase58(),o.quoteMint.toBase58()],g=Nr(y,h)[0],k=new qr(g),_=await this.scope.account.getCreatedTokenAccount({mint:k}),[P,q]=[r.raw,i.raw],N=this.createTxBuilder(),D=this.createTxBuilder(),ce=await c.handleTokenAccount({side:"in",amount:P,mint:d.mint,tokenAccount:b,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:$}=ce,E=ee(ce,["tokenAccount"]);N.addInstruction(E);let fe=await c.handleTokenAccount({side:"out",amount:0,mint:p.mint,tokenAccount:f,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:U}=fe,X=ee(fe,["tokenAccount"]);N.addInstruction(X);let de=await c.handleTokenAccount({side:"in",amount:0,mint:k,tokenAccount:_,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:j}=de,ne=ee(de,["tokenAccount"]);N.addInstruction(ne),D.addInstruction({instructions:Or({fromPoolKeys:e,toPoolKeys:o,userKeys:{inTokenAccount:$,outTokenAccount:U,middleTokenAccount:j,middleStatusAccount:await Fr({programId:ut,fromPoolId:e.id,middleMint:k,owner:this.scope.ownerPubKey}),owner:this.scope.ownerPubKey},amountIn:P,amountOut:q,fixedSide:a})});let ie=N.build();return await D.buildMultiTx({extraPreBuildData:[ie],extInfo:{amountOut:q}})}};import{PublicKey as $a}from"@solana/web3.js";import vr from"bn.js";var Ga=R([Fe("mintAuthorityOption"),w("mintAuthority"),l("supply"),v("decimals"),v("isInitialized"),Fe("freezeAuthorityOption"),w("freezeAuthority")]);function Dr(n,t){return n.sort((e,o)=>{let{official:r,unOfficial:i}=t,a=new Set(r),u=new Set(i),c=p=>a.has(p.mint)?1:u.has(p.mint)?2:3,m=c(e)-c(o),d=p=>!/^[a-zA-Z]/.test(p);if(m===0){let p=d(e.symbol),b=d(o.symbol);return p&&!b?1:!p&&b?-1:e.symbol.localeCompare(o.symbol)}else return m})}var mt=class extends re{constructor(e){super(e);this._tokens=[];this._tokenMap=new Map;this._tokenPrice=new Map;this._mintList={official:[],unOfficial:[],unNamed:[]}}async load(e){this.checkDisabled(),await this.scope.fetchTokens(e==null?void 0:e.forceUpdate),this._mintList={official:[],unOfficial:[],unNamed:[]},this._tokens=[],this._tokenMap=new Map;let{data:o}=this.scope.apiData.tokens||{data:{official:[],unOfficial:[],unNamed:[],blacklist:[]}},r=new Set(o.blacklist);[o.official,o.unOfficial,o.unNamed].forEach((i,a)=>{i.forEach(u=>{let c=["official","unOfficial","unNamed"][a];!r.has(u.mint)&&u.mint!==W.toBase58()&&(this._tokens.push(O(S({},u),{symbol:u.symbol||"",name:u.name||""})),this._mintList[c].push(u.mint))})}),this._mintList.official.push(Qe.mint.toBase58()),this._tokens=Dr(this._tokens,this._mintList),this._tokens.push(O(S({},Qe),{mint:W.toBase58()})),this._tokens.forEach(i=>{this._tokenMap.set(i.mint,O(S({},i),{id:i.mint}))}),this._tokenMap.set(Y.mint,O(S({},Y),{icon:Qe.icon,id:"wsol"})),this._tokenMap.set(W.toBase58(),O(S({},Qe),{mint:W.toBase58()}))}get allTokens(){return this._tokens}get allTokenMap(){return this._tokenMap}get tokenMints(){return this._mintList}get tokenPrices(){return this._tokenPrice}async fetchTokenPrices(e){let o=this.allTokens.filter(m=>{var d;return!!((d=m.extensions)!=null&&d.coingeckoId)&&m.mint!==$a.default.toBase58()}),r=o.map(m=>m.extensions.coingeckoId),i=await this.scope.api.getCoingeckoPrice(r),a=o.reduce((m,d)=>i[d.extensions.coingeckoId].usd?O(S({},m),{[d.mint]:$e({token:this._tokenMap.get(d.mint),numberPrice:i[d.extensions.coingeckoId].usd,decimalDone:!0})}):m,{}),u=e||await this.scope.api.getRaydiumTokenPrice(),c=Object.keys(u).reduce((m,d)=>this._tokenMap.get(d)?O(S({},m),{[d]:$e({token:this._tokenMap.get(d),numberPrice:u[d],decimalDone:!0})}):m,{});return this._tokenPrice=new Map([...Object.entries(a),...Object.entries(c)]),this._tokenPrice}mintToToken(e){let o=V({publicKey:e,transformSol:!0}),r=this.allTokenMap.get(o.toBase58());r||this.logAndCreateError("token not found, mint:",o.toBase58());let{decimals:i,name:a,symbol:u}=r;return new G({mint:e,decimals:i,name:a,symbol:u})}mintToTokenAmount({mint:e,amount:o,decimalDone:r}){let i=this.mintToToken(e);return r?new F(i,x(o)):new F(i,this.decimalAmount({mint:e,amount:o,decimalDone:r}))}decimalAmount({mint:e,amount:o}){let r=se(o),i=this.mintToToken(e);return Te(new T(r.numerator,r.denominator).mul(new vr(10**i.decimals)))}uiAmount({mint:e,amount:o}){let r=se(o),i=this.mintToToken(e);return i?new T(r.numerator,r.denominator).div(new vr(10**i.decimals)).toSignificant(i.decimals):""}};function Er(n){let t=[];for(let e=0;e<n.length;e++)for(let o=0;o<n.length;o++)e!=o&&t.push([n[e],n[o]]);return t}var lt=class extends re{async load(){this.checkDisabled(),await this.scope.fetchLiquidity()}async _getBestSwapPool({availablePools:t,officialPoolIdSet:e}){if(t.length===0)return;if(t.length===1)return t[0];let o=t.filter(a=>e.has(a.id));return o.length===1?o[0]:(await this.scope.liquidity.sdkParseJsonLiquidityInfo(o.length?o:t)).reduce((a,u)=>{let c=a.version===5,m=u.version===5;return c&&!m?a:!c&&m?u:lo(Qt(a.lpSupply,10**a.lpDecimals),Qt(u.lpSupply,10**u.lpDecimals))?a:u}).jsonInfo}async getAvailablePools(t){this.checkDisabled();let{inputMint:e,outputMint:o}=t,[r,i]=[V({publicKey:e,transformSol:!0}).toBase58(),V({publicKey:o,transformSol:!0}).toBase58()],a=this.scope.liquidity.allPools.filter(p=>p.baseMint===r&&p.quoteMint===i||p.baseMint===i&&p.quoteMint===r),u=new Set([...Rr,r,i]),c=new Set(JSON.parse(JSON.stringify([...u])));c.delete(r),c.delete(i);let m=this.scope.liquidity.allPools.filter(p=>{let b=u.has(p.baseMint)&&u.has(p.quoteMint),f=c.has(p.baseMint)&&c.has(p.quoteMint);return b&&!f}),d=await this._getBestSwapPool({availablePools:a,officialPoolIdSet:this.scope.liquidity.allPoolIdSet.official});return{availablePools:a,best:d,routedPools:m}}async getBestAmountOut({pools:t,amountIn:e,inputToken:o,outputToken:r,slippage:i,features:a}){if(this.checkDisabled(),!t){let{routedPools:_}=await this.getAvailablePools({inputMint:o.mint,outputMint:r.mint});t=_}let u=await this.scope.liquidity.sdkParseJsonLiquidityInfo(t||[]),c=(t||[]).map((_,P)=>({poolKeys:me(_),poolInfo:u[P]})),m=a||_r;this.logDebug("features:",m),c.length||this.logAndCreateError("please provide at least one source of trade or (inputMint & outputMint)",c);let d=[],p="amm",b=new F(o,e),f=new F(r,0),y=f,h=null,L=null,g=new oe(ae),k=[];if(m.includes("amm"))for(let{poolKeys:_,poolInfo:P}of c)try{let{amountOut:q,minAmountOut:N,currentPrice:D,executionPrice:$,priceImpact:E,fee:U}=this.scope.liquidity.computeAmountOut({poolKeys:_,poolInfo:P,amountIn:b,outputToken:r,slippage:i});q.gt(f)&&(console.log("amm",P),d=[{source:"amm",keys:_}],p="amm",f=q,y=N,h=D,L=$,g=E,k=[U])}catch{}if(m.includes("route")){let _=Er(c);for(let P of _){if(P.length!==2)continue;let[q,N]=P,{poolKeys:D,poolInfo:$}=q,{poolKeys:E,poolInfo:U}=N;try{let{amountOut:X,minAmountOut:j,executionPrice:ne,priceImpact:ie,fee:Ae}=this.scope.route.computeRouteAmountOut({fromPoolKeys:D,toPoolKeys:E,fromPoolInfo:$,toPoolInfo:U,amountIn:b,outputToken:r,slippage:i});X.gt(f)&&(d=[{source:"amm",keys:D},{source:"amm",keys:E}],p="route",f=X,y=j,L=ne,g=ie,k=Ae)}catch{}}}return{routes:d,routeType:p,amountOut:f,minAmountOut:y,fixedSide:"in",currentPrice:h,executionPrice:L,priceImpact:g,fee:k}}async directSwap(t){this.checkDisabled();let{amountOut:e,amountIn:o,slippage:r,config:i}=t,a=o.token,u=e.token,{routes:c,routeType:m,minAmountOut:d}=await this.getBestAmountOut({inputToken:a,outputToken:u,amountIn:o.raw,slippage:r});return await this.swap({routes:c,routeType:m,amountIn:o,amountOut:d,fixedSide:"in",config:i})}async swap(t){this.checkDisabled(),this.scope.checkOwner();let{routes:e,routeType:o,amountIn:r,amountOut:i,fixedSide:a,config:u}=t;if(o==="amm"&&e.length===1)return await this.scope.liquidity.swapWithAMM({poolKeys:e[0].keys,amountIn:r,amountOut:i,fixedSide:a,config:u});if(o==="route"&&e.length===2)return await this.scope.route.swapWithRoute({fromPoolKeys:e[0].keys,toPoolKeys:e[1].keys,amountIn:r,amountOut:i,fixedSide:a,config:u});throw this.logAndCreateError("invalid routes with routeType","routes",{routeType:o,routes:e}),new Error("invalid routes with routeType")}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let t=this.scope.account.tokenAccounts.filter(e=>e.mint.equals(xe));return t.sort((e,o)=>e.isAssociated?1:o.isAssociated||e.amount.lt(o.amount)?-1:1),t}async unWrapWSol(t){let e=await this.getWSolAccounts(),o=this.createTxBuilder(),r=await Le({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:0});o.addInstruction(r);let i=x(t);for(let a=0;a<e.length;a++)i.gte(e[a].amount)?(o.addInstruction({instructions:[qe({tokenAccount:e[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),i.sub(e[a].amount)):(o.addInstruction({instructions:[qe({tokenAccount:e[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),Ke({destination:r.signers[0].publicKey,source:e[a].publicKey,amount:i,owner:this.scope.ownerPubKey}));return o.build()}async wrapWSol(t){let e=await this.getWSolAccounts(),o=this.createTxBuilder(),r=await Le({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:t,skipCloseAccount:!0});return o.addInstruction(r),e.length&&o.addInstruction({instructions:[Ke({destination:e[0].publicKey,source:r.signers[0].publicKey,amount:t,owner:this.scope.ownerPubKey})],endInstructions:[qe({tokenAccount:r.signers[0].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),o.build()}};var Re={},Et=class{constructor(t){this.rawBalances=new Map;let{connection:e,cluster:o,owner:r,api:i,defaultApiTokens:a,defaultApiLiquidityPools:u,defaultApiFarmPools:c,defaultApiPairsInfo:m,apiCacheTime:d}=t;this._connection=e,this.cluster=o,this._owner=r?new le(r):void 0,this._signAllTransactions=t.signAllTransactions,this.api=i,this._apiCacheTime=d||5*60*1e3,this.logger=M("Raydium"),this.farm=new it({scope:this,moduleName:"Raydium_Farm"}),this.account=new Ze({scope:this,moduleName:"Raydium_Account",tokenAccounts:t.tokenAccounts,tokenAccountRawInfos:t.tokenAccountRawInfos}),this.liquidity=new st({scope:this,moduleName:"Raydium_Liquidity"}),this.token=new mt({scope:this,moduleName:"Raydium_token"}),this.trade=new lt({scope:this,moduleName:"Raydium_trade"}),this.route=new ct({scope:this,moduleName:"Raydium_route"});let p=new Date().getTime(),[b,f,y,h]=[a?{fetched:p,data:a}:Re.tokens,u?{fetched:p,data:u}:Re.liquidityPools,c?{fetched:p,data:c}:Re.farmPools,m?{fetched:p,data:m}:Re.liquidityPairsInfo];this.apiData=S(S(S(S({},b?{tokens:b}:{}),f?{liquidityPools:f}:{}),y?{farmPools:y}:{}),h?{liquidityPairsInfo:h}:{})}static async load(t){let e=ja({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},t),{cluster:o,apiRequestTimeout:r}=e,i=new _t({cluster:o,timeout:r}),a=new Et(O(S({},e),{api:i}));return await a.token.load(),await a.liquidity.load(),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(Rt);return this._owner.publicKey}setOwner(t){return this._owner=t?new le(t):void 0,this}get connection(){if(!this._connection)throw new Error(go);return this._connection}setConnection(t){return this._connection=t,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(t){return this._signAllTransactions=t,this}checkOwner(){if(!this.owner)throw this.logger.error(Rt),new Error(Rt)}isCacheInvalidate(t){return new Date().getTime()-t>this._apiCacheTime}async fetchTokens(t){if(this.apiData.tokens&&!this.isCacheInvalidate(this.apiData.tokens.fetched)&&!t)return this.apiData.tokens.data;let e={fetched:Date.now(),data:await this.api.getTokens()};return this.apiData.tokens=e,Re.tokens=e,e.data}async fetchLiquidity(t){if(this.apiData.liquidityPools&&!this.isCacheInvalidate(this.apiData.liquidityPools.fetched)&&!t)return this.apiData.liquidityPools.data;let e={fetched:Date.now(),data:await this.api.getLiquidityPools()};return this.apiData.liquidityPools=e,Re.liquidityPools=e,e.data}async fetchPairs(t){var o;if(this.apiData.liquidityPairsInfo&&!this.isCacheInvalidate(this.apiData.liquidityPairsInfo.fetched)&&!t)return((o=this.apiData.liquidityPairsInfo)==null?void 0:o.data)||[];let e={fetched:Date.now(),data:await this.api.getPairsInfo()};return this.apiData.liquidityPairsInfo=e,Re.liquidityPairsInfo=e,e.data}async fetchFarms(t){if(this.apiData.farmPools&&!this.isCacheInvalidate(this.apiData.farmPools.fetched)&&!t)return this.apiData.farmPools.data;let e={fetched:Date.now(),data:await this.api.getFarmPools()};return this.apiData.farmPools=e,Re.farmPools=e,e.data}async chainTimeOffset(){let t=await this.connection.getBlockTime(await this.connection.getSlot());return t?(t*1e3,Number((t*1e3-Date.now()).toFixed(0))):0}mintToToken(t){return this.token.mintToToken(t)}mintToTokenAmount(t){return this.token.mintToTokenAmount(t)}decimalAmount(t){return this.token.decimalAmount(t)}uiAmount(t){return this.token.uiAmount(t)}};export{Et as Raydium};
//# sourceMappingURL=raydium.mjs.map