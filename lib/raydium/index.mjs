var Yr=Object.defineProperty,Qr=Object.defineProperties;var Hr=Object.getOwnPropertyDescriptors;var gt=Object.getOwnPropertySymbols;var Cn=Object.prototype.hasOwnProperty,Wn=Object.prototype.propertyIsEnumerable;var Vn=(n,t,e)=>t in n?Yr(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,L=(n,t)=>{for(var e in t||(t={}))Cn.call(t,e)&&Vn(n,e,t[e]);if(gt)for(var e of gt(t))Wn.call(t,e)&&Vn(n,e,t[e]);return n},K=(n,t)=>Qr(n,Hr(t));var ee=(n,t)=>{var e={};for(var o in n)Cn.call(n,o)&&t.indexOf(o)<0&&(e[o]=n[o]);if(n!=null&&gt)for(var o of gt(n))t.indexOf(o)<0&&Wn.call(n,o)&&(e[o]=n[o]);return e};import{merge as Ha}from"lodash";import Ri from"axios";import{get as Un,set as zr}from"lodash";import Zr from"pino";import Xr from"pino-pretty";var Gn={},ei={},ti=Xr({colorize:!0,levelFirst:!0,translateTime:"SYS:yyyymmdd HH:MM:ss.l"}),ni=Zr({base:null,level:"silent"},ti);function M(n){let t=Un(Gn,n);if(!t){let e=Un(ei,n);t=ni.child({name:n},{level:e}),zr(Gn,n,t)}return t.logWithError=(...e)=>{let o=e.map(r=>typeof r=="object"?JSON.stringify(r):r).join(", ");throw new Error(o)},t}import{PublicKey as Pi}from"@solana/web3.js";import wi from"bn.js";import mi from"big.js";import Tt from"bn.js";import V from"bn.js";var Pt=M("Raydium_bignumber");var ae=new V(0),pe=new V(1),ss=new V(2),us=new V(3),cs=new V(5),be=new V(10),jn=new V(100),ms=new V(1e3),ls=new V(1e4),Jn=9007199254740991;function x(n){if(n instanceof V)return n;if(typeof n=="string"){if(n.match(/^-?[0-9]+$/))return new V(n);Pt.logWithError(`invalid BigNumberish string: ${n}`)}return typeof n=="number"?(n%1&&Pt.logWithError(`BigNumberish number underflow: ${n}`),(n>=Jn||n<=-Jn)&&Pt.logWithError(`BigNumberish number overflow: ${n}`),new V(String(n))):typeof n=="bigint"?new V(n.toString()):(Pt.logWithError(`invalid BigNumberish value: ${n}`),new V(0))}function Wt(n){return be.pow(x(n))}function se(n){var u;if(n===void 0)return{denominator:"1",numerator:"0"};if(n instanceof V)return{numerator:n.toString(),denominator:"1"};if(n instanceof I)return{denominator:n.denominator.toString(),numerator:n.numerator.toString()};let t=String(n),[,e="",o="",r=""]=(u=t.replace(",","").match(/(-?)(\d*)\.?(\d*)/))!=null?u:[],i="1"+"0".repeat(r.length),a=e+(o==="0"?"":o)+r||"0";return{denominator:i,numerator:a,sign:e,int:o,dec:r}}function Ut(n,t){let e=n.divmod(t);return e.mod.isZero()?e.div:e.div.negative!==0?e.div.isubn(1):e.div.iaddn(1)}function oi(n){var o;let[,t="",e=""]=(o=n.toFixed(2).match(/(-?)(\d*)\.?(\d*)/))!=null?o:[];return`${t}${e}`}function Ie(n,t=0){return n instanceof V?n:new V(oi(Be(n).mul(be.pow(new V(String(t))))))}function Be(n){if(n instanceof oe)return new I(n.numerator,n.denominator);if(n instanceof Q)return n.adjusted;if(n instanceof O)try{return Be(n.toExact())}catch{return new I(ae)}if(n instanceof I)return n;let t=String(n),e=se(t);return new I(e.numerator,e.denominator)}function wt(n,t){let{numerator:e,denominator:o}=se(n);return new oe(new V(e),new V(o).mul(t!=null&&t.alreadyDecimaled?new V(100):new V(1)))}function Je(n){let{token:t,numberPrice:e,decimalDone:o}=n,r=new G({mint:"",decimals:6,symbol:"usd",name:"usd",skipMint:!0}),{numerator:i,denominator:a}=se(e),u=o?new V(i).mul(be.pow(new V(t.decimals))):i,c=new V(a).mul(be.pow(new V(r.decimals)));return new Q({baseToken:r,denominator:c.toString(),quoteToken:new G(K(L({},t),{skipMint:!0,mint:""})),numerator:u.toString()})}function Yn(n,t){if(n==null||t==null)return;let e=Be(n),o=Be(t);return e.mul(o)}function $n(n){let t=new G({mint:"",decimals:6,symbol:"usd",name:"usd",skipMint:!0}),e=Ie(Yn(n,10**t.decimals));return new O(t,e)}function $e(n,t){return $n(!t||!n?0:Yn(n,t))}import ri from"toformat";var ii=ri,je=ii;import kt from"big.js";import si from"decimal.js-light";var ht=M("module/fraction"),Gt=je(kt),Ye=je(si),ui={[0]:Ye.ROUND_DOWN,[1]:Ye.ROUND_HALF_UP,[2]:Ye.ROUND_UP},ci={[0]:kt.roundDown,[1]:kt.roundHalfUp,[2]:kt.roundUp},I=class{constructor(t,e=pe){this.numerator=x(t),this.denominator=x(e)}get quotient(){return this.numerator.div(this.denominator)}invert(){return new I(this.denominator,this.numerator)}add(t){let e=t instanceof I?t:new I(x(t));return this.denominator.eq(e.denominator)?new I(this.numerator.add(e.numerator),this.denominator):new I(this.numerator.mul(e.denominator).add(e.numerator.mul(this.denominator)),this.denominator.mul(e.denominator))}sub(t){let e=t instanceof I?t:new I(x(t));return this.denominator.eq(e.denominator)?new I(this.numerator.sub(e.numerator),this.denominator):new I(this.numerator.mul(e.denominator).sub(e.numerator.mul(this.denominator)),this.denominator.mul(e.denominator))}mul(t){let e=t instanceof I?t:new I(x(t));return new I(this.numerator.mul(e.numerator),this.denominator.mul(e.denominator))}div(t){let e=t instanceof I?t:new I(x(t));return new I(this.numerator.mul(e.denominator),this.denominator.mul(e.numerator))}toSignificant(t,e={groupSeparator:""},o=1){Number.isInteger(t)||ht.logWithError(`${t} is not an integer.`),t<=0&&ht.logWithError(`${t} is not positive.`),Ye.set({precision:t+1,rounding:ui[o]});let r=new Ye(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(t);return r.toFormat(r.decimalPlaces(),e)}toFixed(t,e={groupSeparator:""},o=1){return Number.isInteger(t)||ht.logWithError(`${t} is not an integer.`),t<0&&ht.logWithError(`${t} is negative.`),Gt.DP=t,Gt.RM=ci[o]||1,new Gt(this.numerator.toString()).div(this.denominator.toString()).toFormat(t,e)}isZero(){return this.numerator.isZero()}};var li=M("Raydium_amount"),Qn=je(mi);function di(n,t){let e="0",o="0";if(n.includes(".")){let r=n.split(".");r.length===2?([e,o]=r,o=o.padEnd(t,"0")):li.logWithError(`invalid number string, num: ${n}`)}else e=n;return[e,o.slice(0,t)||o]}var O=class extends I{constructor(e,o,r=!0,i){let a=new Tt(0),u=be.pow(new Tt(e.decimals));if(r)a=x(o);else{let c=new Tt(0),m=new Tt(0);if(typeof o=="string"||typeof o=="number"||typeof o=="bigint"){let[d,p]=di(o.toString(),e.decimals);c=x(d),m=x(p)}c=c.mul(u),a=c.add(m)}super(a,u);this.logger=M(i||"Amount"),this.token=e}get raw(){return this.numerator}isZero(){return this.raw.isZero()}gt(e){return this.token.equals(e.token)||this.logger.logWithError("gt token not equals"),this.raw.gt(e.raw)}lt(e){return this.token.equals(e.token)||this.logger.logWithError("lt token not equals"),this.raw.lt(e.raw)}add(e){return this.token.equals(e.token)||this.logger.logWithError("add token not equals"),new O(this.token,this.raw.add(e.raw))}subtract(e){return this.token.equals(e.token)||this.logger.logWithError("sub token not equals"),new O(this.token,this.raw.sub(e.raw))}toSignificant(e=this.token.decimals,o,r=0){return super.toSignificant(e,o,r)}toFixed(e=this.token.decimals,o,r=0){return e>this.token.decimals&&this.logger.logWithError("decimals overflow"),super.toFixed(e,o,r)}toExact(e={groupSeparator:""}){return Qn.DP=this.token.decimals,new Qn(this.numerator.toString()).div(this.denominator.toString()).toFormat(e)}};import{PublicKey as pi}from"@solana/web3.js";var Hn={symbol:"SOL",name:"Solana",decimals:9},j={symbol:"WSOL",name:"Wrapped SOL",mint:"So11111111111111111111111111111111111111112",decimals:9,extensions:{coingeckoId:"solana"}},Qe={isQuantumSOL:!0,isLp:!1,official:!0,mint:new pi(j.mint),decimals:9,symbol:"SOL",id:"sol",name:"solana",icon:"https://img.raydium.io/icon/So11111111111111111111111111111111111111112.png",extensions:{coingeckoId:"solana"}};import{PublicKey as Jt}from"@solana/web3.js";import{TOKEN_PROGRAM_ID as fi}from"@solana/spl-token";import{PublicKey as te,SystemProgram as yi,SYSVAR_RENT_PUBKEY as bi}from"@solana/web3.js";function s({pubkey:n,isSigner:t=!1,isWritable:e=!0}){return{pubkey:n,isWritable:e,isSigner:t}}var Ke=[s({pubkey:fi,isWritable:!1}),s({pubkey:yi.programId,isWritable:!1}),s({pubkey:bi,isWritable:!1})];function E({publicKey:n,transformSol:t}){if(n instanceof te)return t&&n.equals(W)?xe:n;if(t&&n===W.toBase58())return xe;if(typeof n=="string")try{return new te(n)}catch{throw new Error("invalid public key")}throw new Error("invalid public key")}function zn(n){try{return new te(n)}catch{return n}}var At=new te("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Zn=new te("Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS"),Ds=new te("SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt"),Xn=new te("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"),eo=new te("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB"),to=new te("mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So"),no=new te("7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj"),oo=new te("USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX"),Es=new te("NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa"),Vs=new te("ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo"),ro=new te("7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs"),xe=new te("So11111111111111111111111111111111111111112"),W=te.default;var $t=class{constructor({mint:t,decimals:e,symbol:o="UNKNOWN",name:r="UNKNOWN",skipMint:i=!1}){if(t===W.toBase58()||t instanceof Jt&&W.equals(t)){this.decimals=j.decimals,this.symbol=j.symbol,this.name=j.name,this.mint=new Jt(j.mint);return}this.decimals=e,this.symbol=o,this.name=r,this.mint=i?Jt.default:E({publicKey:t})}equals(t){return this===t?!0:this.mint.equals(t.mint)}},G=$t;G.WSOL=new $t(j);var Yt=class{constructor({decimals:t,symbol:e="UNKNOWN",name:o="UNKNOWN"}){this.decimals=t,this.symbol=e,this.name=o}equals(t){return this===t}},jt=Yt;jt.SOL=new Yt(Hn);var io=new I(jn),oe=class extends I{toSignificant(t=5,e,o){return this.mul(io).toSignificant(t,e,o)}toFixed(t=2,e,o){return this.mul(io).toFixed(t,e,o)}};var gi=M("Raydium_price"),Q=class extends I{constructor(e){let{baseToken:o,quoteToken:r,numerator:i,denominator:a}=e;super(i,a);this.baseToken=o,this.quoteToken=r,this.scalar=new I(Wt(o.decimals),Wt(r.decimals))}get raw(){return new I(this.numerator,this.denominator)}get adjusted(){return super.mul(this.scalar)}invert(){return new Q({baseToken:this.quoteToken,quoteToken:this.baseToken,denominator:this.numerator,numerator:this.denominator})}mul(e){this.quoteToken!==e.baseToken&&gi.logWithError("mul token not equals");let o=super.mul(e);return new Q({baseToken:this.baseToken,quoteToken:e.quoteToken,denominator:o.denominator,numerator:o.numerator})}toSignificant(e=this.quoteToken.decimals,o,r){return this.adjusted.toSignificant(e,o,r)}toFixed(e=this.quoteToken.decimals,o,r){return this.adjusted.toFixed(e,o,r)}};var hi=[G,O,Pi,I,wi,Q,oe];function ki(n){return typeof n=="object"&&n!==null&&!hi.some(t=>typeof t=="object"&&n instanceof t)}function me(n){return typeof n=="string"?zn(n):Array.isArray(n)?n.map(t=>me(t)):ki(n)?Object.fromEntries(Object.entries(n).map(([t,e])=>[t,me(e)])):n}import{PACKET_DATA_SIZE as Ti,PublicKey as uo,sendAndConfirmTransaction as ao,Transaction as It}from"@solana/web3.js";var Se=M("Raydium_txTool"),xt=class{constructor(t){this.instructions=[];this.endInstructions=[];this.signers=[];this.connection=t.connection,this.feePayer=t.feePayer,this.signAllTransactions=t.signAllTransactions,this.owner=t.owner}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers}}get allInstructions(){return[...this.instructions,...this.endInstructions]}addInstruction({instructions:t=[],endInstructions:e=[],signers:o=[]}){return this.instructions.push(...t),this.endInstructions.push(...e),this.signers.push(...o),this}build(t){let e=new It;return this.allInstructions.length&&e.add(...this.allInstructions),e.feePayer=this.feePayer,{transaction:e,signers:this.signers,execute:async()=>{var r;let o=await so(this.connection);if(e.recentBlockhash=o,(r=this.owner)!=null&&r.isKeyPair)return ao(this.connection,e,this.signers);if(this.signAllTransactions){this.signers.length&&e.partialSign(...this.signers);let i=await this.signAllTransactions([e]);return await this.connection.sendRawTransaction(i[0].serialize(),{skipPreflight:!0})}throw new Error("please connect wallet first")},extInfo:t||{}}}buildMultiTx(t){let{extraPreBuildData:e=[],extInfo:o}=t,{transaction:r}=this.build(o),i=e.filter(c=>c.transaction.instructions.length>0),a=[...i.map(c=>c.transaction),r],u=[...i.map(c=>c.signers),this.signers];return{transactions:a,signers:u,execute:async()=>{var m;let c=await so(this.connection);if((m=this.owner)!=null&&m.isKeyPair)return await Promise.all(a.map(async(d,p)=>(d.recentBlockhash=c,await ao(this.connection,d,u[p]))));if(this.signAllTransactions){let d=a.map((f,b)=>(f.recentBlockhash=c,u[b].length&&f.partialSign(...u[b]),f)),p=await this.signAllTransactions(d),y=[];for(let f=0;f<p.length;f+=1){let b=await this.connection.sendRawTransaction(p[f].serialize(),{skipPreflight:!0});y.push(b)}return y}throw new Error("please connect wallet first")},extInfo:o||{}}}};async function so(n){var t,e;try{return((e=await((t=n.getLatestBlockhash)==null?void 0:t.call(n)))==null?void 0:e.blockhash)||(await n.getRecentBlockhash()).blockhash}catch{return(await n.getRecentBlockhash()).blockhash}}function Ai(n,t){n.length<1&&Se.logWithError(`no instructions provided: ${n.toString()}`),t.length<1&&Se.logWithError(`no signers provided:, ${t.toString()}`);let e=new It;e.recentBlockhash="11111111111111111111111111111111",e.feePayer=t[0],e.add(...n);let o=e.compileMessage().serialize();return t.length+t.length*64+o.length}async function co(n,t,e){let o=new uo("RaydiumSimuLateTransaction11111111111111111"),r=[],i=new It;i.feePayer=o;for(let c of t)Ai([...i.instructions,c],[o])>Ti&&(r.push(i),i=new It,i.feePayer=o),i.add(c);i.instructions.length>0&&r.push(i);let a=[];try{a=await Promise.all(r.map(c=>n.simulateTransaction(c)))}catch(c){c instanceof Error&&Se.logWithError(`failed to simulate for instructions, RPC_ERROR, ${c.message}`)}let u=[];for(let c of a){let{value:m}=c;if(Se.debug(`simulate result: ${JSON.stringify(c)}`),m.logs){let d=m.logs.filter(p=>p&&p.includes(e));Se.debug(`filteredLog: ${JSON.stringify(u)}`),d.length||Se.logWithError(` "simulate log not match keyword, keyword: ${e}`),u.push(...d)}}return u}function mo(n,t){let e=n.match(/{["\w:,]+}/g);return!e||e.length!==1?Se.logWithError(`simulate log fail to match json, keyword: ${t}`):e[0]}function ge(n,t){let o=new RegExp(`"${t}":(\\d+)`,"g").exec(n);return!o||o.length!==2?Se.logWithError(`simulate log fail to match key", key: ${t}`):o[1]}async function Pe(n,t){let[e,o]=await uo.findProgramAddress(n,t);return{publicKey:e,nonce:o}}var le=class{constructor(t){this._owner=t}get publicKey(){return le.isKeyPair(this._owner)?this._owner.publicKey:this._owner}get signer(){return le.isKeyPair(this._owner)?this._owner:void 0}get isKeyPair(){return le.isKeyPair(this._owner)}get isPublicKey(){return le.isPublicKey(this._owner)}static isKeyPair(t){return t.secretKey!==void 0}static isPublicKey(t){return!le.isKeyPair(t)}};function lo(n,t=1,e=[]){let o=[...n];if(t<=0)return e;for(;o.length;)e.push(o.splice(0,t));return e}import{PublicKey as Ii}from"@solana/web3.js";var Qt=M("Raydium_accountInfo_util");async function xi(n,t,e){let{batchRequest:o,commitment:r}=L({batchRequest:!1},e),i=lo(t,100),a=new Array(i.length).fill([]);if(o){let u=i.map(m=>{let d=n._buildArgs([m.map(p=>p.toBase58())],r,"base64");return{methodName:"getMultipleAccounts",args:d}});a=(await n._rpcBatchRequest(u)).map(m=>(m.error&&Qt.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${m.error.message}`),m.result.value.map(d=>{if(d){let{data:p,executable:y,lamports:f,owner:b,rentEpoch:h}=d;return p.length!==2&&p[1]!=="base64"&&Qt.logWithError("info must be base64 encoded, RPC_ERROR"),{data:Buffer.from(p[0],"base64"),executable:y,lamports:f,owner:new Ii(b),rentEpoch:h}}return null})))}else try{a=await Promise.all(i.map(u=>n.getMultipleAccountsInfo(u,r)))}catch(u){u instanceof Error&&Qt.logWithError(`failed to get info for multiple accounts, RPC_ERROR, ${u.message}`)}return a.flat()}async function po(n,t,e){let o=await xi(n,t.map(r=>r.pubkey),e);return t.map((r,i)=>K(L({},r),{accountInfo:o[i]}))}function ue(n){if(n instanceof oe)return new I(n.numerator,n.denominator);if(n instanceof Q)return n.adjusted;if(n instanceof O)try{return ue(n.toExact())}catch{return new I(ae)}if(n instanceof I)return n;let t=String(n),e=se(t);return new I(e.numerator,e.denominator)}function Si(n,t){if(n==null||t==null)return!1;let e=ue(n),o=ue(t);return e.sub(o).numerator.gt(ae)}function fo(n,t){if(n==null||t==null)return!1;let e=ue(n),o=ue(t);return e.sub(o).numerator.gte(ae)}function Li(n,t){if(n==null||t==null)return!1;let e=ue(n),o=ue(t);return e.sub(o).numerator.eq(ae)}function Ht(n,t){if(n==null||t==null)return;let e=ue(n),o=ue(t);try{return e.div(o)}catch{return e}}function yo(n,t){if(n==null||t==null)return;let e=ue(n),o=ue(t);return e.sub(o)}function St(n){return n==null?!1:!Li(n,0)}function bo(n,t){return Si(t,n)?t:n}var go=n=>typeof n=="number",Po=n=>n?new Date(n):new Date,_i=n=>Po(n).getTime();function He(n,t,e){let o=go(t)?t*((e==null?void 0:e.unit)==="s"?1e3:1):t;return new Date(n).getTime()<=o}function De(n,t,e){let o=go(t)?t*((e==null?void 0:e.unit)==="s"?1e3:1):t;return new Date(n).getTime()>o}function zt(n,t){let o=_i(n)+(t.days?t.days*24*60*60*1e3:0)+(t.hours?t.hours*60*60*1e3:0)+(t.minutes?t.minutes*60*1e3:0)+(t.seconds?t.seconds*1e3:0)+(t.milliseconds?t.milliseconds:0);return Po(o)}var Lt=M("Raydium_Api");var _t=class{constructor({cluster:t,timeout:e}){this.cluster=t,this.api=Ri.create({baseURL:"https://api.raydium.io/v2",timeout:e}),this.api.interceptors.request.use(o=>{let{method:r,baseURL:i,url:a}=o;return Lt.debug(`${r==null?void 0:r.toUpperCase()} ${i}${a}`),o},o=>(Lt.error("Request failed"),Promise.reject(o))),this.api.interceptors.response.use(o=>{let{config:r,data:i,status:a}=o,{method:u,baseURL:c,url:m}=r;return Lt.debug(`${u==null?void 0:u.toUpperCase()} ${c}${m}  ${a}`),i},o=>{let{config:r,response:i={}}=o,{status:a}=i,{method:u,baseURL:c,url:m}=r;return Lt.error(`${u.toUpperCase()} ${c}${m} ${a||o.message}`),Promise.reject(o)})}async getTokens(){return this.api.get("/sdk/token/raydium.mainnet.json")}async getLiquidityPools(){return this.api.get(`/sdk/liquidity/${this.cluster}.json`)}async getPairsInfo(){return this.api.get("https://api.raydium.io/v2/main/pairs")}async getFarmPools(){return this.api.get(`/sdk/farm-v2/${this.cluster}.json`)}async getCoingeckoPrice(t){return this.api.get(`https://api.coingecko.com/api/v3/simple/price?ids=${t.join(",")}&vs_currencies=usd`)}async getRaydiumTokenPrice(){return this.api.get("https://api.raydium.io/v2/main/price")}async getBlockSlotCountForSecond(t){if(!t)return 2;let o=(await this.api.post(t,{id:"getRecentPerformanceSamples",jsonrpc:"2.0",method:"getRecentPerformanceSamples",params:[4]})).result.map(r=>r.numSlots);return o.reduce((r,i)=>r+i,0)/o.length/60}};var Rt="please provide owner in load() initialization or you can set by calling raydium.setOwner(owner)",wo="please provide connection in load() initialization or set it by raydium.setConnection(connection)";import{getAssociatedTokenAddress as xo,createAssociatedTokenAccountInstruction as So,TOKEN_PROGRAM_ID as Yi}from"@solana/spl-token";import{PublicKey as Qi}from"@solana/web3.js";var Zt=(...n)=>n.map(t=>{try{return typeof t=="object"?JSON.stringify(t):t}catch{return t}}).join(", "),re=class{constructor({scope:t,moduleName:e}){this.disabled=!1;this.scope=t,this.logger=M(e)}createTxBuilder(t){return this.scope.checkOwner(),new xt({connection:this.scope.connection,feePayer:t||this.scope.ownerPubKey,owner:this.scope.owner,signAllTransactions:this.scope.signAllTransactions})}logDebug(...t){this.logger.debug(Zt(t))}logInfo(...t){this.logger.info(Zt(t))}logAndCreateError(...t){let e=Zt(t);throw new Error(e)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};import{createInitializeAccountInstruction as Ni,createCloseAccountInstruction as vi,createTransferInstruction as Di,TOKEN_PROGRAM_ID as Ei}from"@solana/spl-token";import{Keypair as Vi,PublicKey as Ci,SystemProgram as Wi}from"@solana/web3.js";import Ui from"bn.js";import{PublicKey as Fi}from"@solana/web3.js";import To,{isBN as Ao}from"bn.js";import{bits as lc,BitStructure as dc,blob as Mi,Blob as pc,cstr as fc,f32 as yc,f32be as bc,f64 as gc,f64be as Pc,greedy as wc,Layout as Bi,ns64 as hc,ns64be as kc,nu64 as Tc,nu64be as Ac,offset as Ic,s16 as xc,s16be as Sc,s24 as Lc,s24be as _c,s32 as Rc,s32be as Mc,s40 as Bc,s40be as Kc,s48 as Oc,s48be as qc,s8 as Fc,seq as Ki,struct as Nc,Structure as Oi,u16 as vc,u16be as Dc,u24 as Ec,u24be as Vc,u32 as Cc,u32be as Wc,u40 as Uc,u40be as Gc,u48 as Jc,u48be as $c,u8 as jc,UInt as qi,union as Yc,Union as Qc,unionLayoutDiscriminator as Hc,utf8 as zc}from"@solana/buffer-layout";var Xt=Bi,ho=Oi;var en=qi;var ko=Ki;var ze=Mi;var Mt=class extends Xt{constructor(e,o,r){super(e,r);this.blob=ze(e),this.signed=o}decode(e,o=0){let r=new To(this.blob.decode(e,o),10,"le");return this.signed?r.fromTwos(this.span*8).clone():r}encode(e,o,r=0){return typeof e=="number"&&(e=new To(e)),this.signed&&(e=e.toTwos(this.span*8)),this.blob.encode(e.toArrayLike(Buffer,"le",this.span),o,r)}};function v(n){return new en(1,n)}function Oe(n){return new en(4,n)}function l(n){return new Mt(8,!1,n)}function Y(n){return new Mt(16,!1,n)}var tn=class extends Xt{constructor(e,o,r,i){super(e.span,i);this.layout=e,this.decoder=o,this.encoder=r}decode(e,o){return this.decoder(this.layout.decode(e,o))}encode(e,o,r){return this.layout.encode(this.encoder(e),o,r)}getSpan(e,o){return this.layout.getSpan(e,o)}};function k(n){return new tn(ze(32),t=>new Fi(t),t=>t.toBuffer(),n)}var nn=class extends ho{decode(t,e){return super.decode(t,e)}};function R(n,t,e){return new nn(n,t,e)}function H(n,t,e){let o,r=typeof t=="number"?t:Ao(t)?t.toNumber():new Proxy(t,{get(i,a){if(!o){let u=Reflect.get(i,"count");o=Ao(u)?u.toNumber():u,Reflect.set(i,"count",o)}return Reflect.get(i,a)},set(i,a,u){return a==="count"&&(o=u),Reflect.set(i,a,u)}});return ko(n,r,e)}var we=R([k("mint"),k("owner"),l("amount"),Oe("delegateOption"),k("delegate"),v("state"),Oe("isNativeOption"),l("isNative"),l("delegatedAmount"),Oe("closeAuthorityOption"),k("closeAuthority")]);function Gi(n){let{mint:t,tokenAccount:e,owner:o}=n;return Ni(e,t,o)}function qe(n){let{tokenAccount:t,payer:e,multiSigners:o=[],owner:r}=n;return vi(t,e,r,o)}async function Le(n){let{connection:t,amount:e,commitment:o,payer:r,owner:i,skipCloseAccount:a}=n,u=await t.getMinimumBalanceForRentExemption(we.span,o),c=x(e).add(new Ui(u)),m=Vi.generate();return{signers:[m],instructions:[Wi.createAccount({fromPubkey:r,newAccountPubkey:m.publicKey,lamports:c.toNumber(),space:we.span,programId:Ei}),Gi({mint:new Ci(j.mint),tokenAccount:m.publicKey,owner:i})],endInstructions:a?[]:[qe({tokenAccount:m.publicKey,payer:r,owner:i})]}}function Ee({source:n,destination:t,owner:e,amount:o,multiSigners:r=[]}){return Di(n,t,e,x(o).toNumber(),r)}import{PublicKey as Ji}from"@solana/web3.js";import $i from"bn.js";var ji=M("Raydium_Util");function Io({solAccountResp:n,tokenAccountResp:t}){let e=[],o=[];for(let{pubkey:r,account:i}of t.value){if(i.data.length!==we.span)throw ji.error("invalid token account layout length","publicKey",r.toBase58()),new Error("invalid token account layout length");let a=we.decode(i.data),{mint:u,amount:c}=a;e.push({publicKey:r,mint:u,amount:c,isNative:!1}),o.push({pubkey:r,accountInfo:a})}return n&&e.push({mint:Ji.default,amount:new $i(n.lamports),isNative:!0}),{tokenAccounts:e,tokenAccountRawInfos:o}}var Ze=class extends re{constructor(e){super(e);this._tokenAccounts=[];this._tokenAccountRawInfos=[];this._ataCache=new Map;this._accountListener=[];this._clientOwnedToken=!1;let{tokenAccounts:o,tokenAccountRawInfos:r}=e;this._tokenAccounts=o||[],this._tokenAccountRawInfos=r||[],this._clientOwnedToken=!!(o||r)}get tokenAccounts(){return this._tokenAccounts}get tokenAccountRawInfos(){return this._tokenAccountRawInfos}updateTokenAccount({tokenAccounts:e,tokenAccountRawInfos:o}){return e&&(this._tokenAccounts=e),o&&(this._tokenAccountRawInfos=o),this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=void 0,this._clientOwnedToken=!0,this}addAccountChangeListener(e){return this._accountListener.push(e),this}removeAccountChangeListener(e){return this._accountListener=this._accountListener.filter(o=>o!==e),this}async getAssociatedTokenAccount(e){this.scope.checkOwner();let o=`${this.scope.ownerPubKey.toBase58()}_${e.toBase58()}`;if(this._ataCache.has(o))return this._ataCache.get(o);let r=await xo(e,this.scope.ownerPubKey,!0);return this._ataCache.set(o,r),r}async fetchWalletTokenAccounts(e){if(this._clientOwnedToken||!(e!=null&&e.forceUpdate)&&this._tokenAccounts.length)return{tokenAccounts:this._tokenAccounts,tokenAccountRawInfos:this._tokenAccountRawInfos};this.scope.checkOwner();let r=L(L({},{}),e),i=await this.scope.connection.getAccountInfo(this.scope.ownerPubKey,r.commitment),a=await this.scope.connection.getTokenAccountsByOwner(this.scope.ownerPubKey,{programId:Yi},r.commitment),{tokenAccounts:u,tokenAccountRawInfos:c}=Io({solAccountResp:i,tokenAccountResp:a});return this._tokenAccounts=u,this._tokenAccountRawInfos=c,this._accountChangeListenerId&&this.scope.connection.removeAccountChangeListener(this._accountChangeListenerId),this._accountChangeListenerId=this.scope.connection.onAccountChange(this.scope.ownerPubKey,()=>this.fetchWalletTokenAccounts({forceUpdate:!0}),"confirmed"),{tokenAccounts:u,tokenAccountRawInfos:c}}async getCreatedTokenAccount({mint:e,associatedOnly:o=!0}){await this.fetchWalletTokenAccounts();let r=this._tokenAccounts.filter(({mint:a})=>a==null?void 0:a.equals(e)).sort((a,u)=>a.amount.lt(u.amount)?1:-1),i=await this.getAssociatedTokenAccount(e);for(let a of r){let{publicKey:u}=a;if(u)return o&&i.equals(u),u}}async checkOrCreateAta({mint:e,autoUnwrapWSOLToSOL:o}){var u;await this.fetchWalletTokenAccounts();let r=(u=this.scope.account.tokenAccounts.find(({mint:c})=>(c==null?void 0:c.toBase58())===e.toBase58()))==null?void 0:u.publicKey,i=this.scope.ownerPubKey,a={};if(!r){let c=await this.getAssociatedTokenAccount(e),m=await So(i,c,i,e);a.instructions=[m],r=c}return o&&j.mint===e.toBase58()&&(a.endInstructions=[qe({owner:i,payer:i,tokenAccount:r})]),{pubKey:r,newInstructions:a}}async handleTokenAccount(e){let{side:o,amount:r,mint:i,tokenAccount:a,payer:u=this.scope.ownerPubKey,bypassAssociatedCheck:c,skipCloseAccount:m}=e,d=this.createTxBuilder(),p=await xo(i,this.scope.ownerPubKey,!0);if(new Qi(j.mint).equals(i)){let y=await Le({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:u,amount:r,skipCloseAccount:m});return d.addInstruction(y),L({tokenAccount:y.signers[0].publicKey},y)}else if(!a||o==="out"&&!p.equals(a)&&!c)return{tokenAccount:p,instructions:[So(this.scope.ownerPubKey,p,this.scope.ownerPubKey,i)]};return{tokenAccount:a}}};import{TOKEN_PROGRAM_ID as ot,createAssociatedTokenAccountInstruction as ya}from"@solana/spl-token";import{Keypair as ba,PublicKey as Z,SystemProgram as tr,SYSVAR_CLOCK_PUBKEY as ga,TransactionInstruction as rt}from"@solana/web3.js";import dn from"bn.js";import{PublicKey as tt}from"@solana/web3.js";var on=R([v("instruction")]),rn=R([v("instruction")]),Hi=R([l("rewardState"),l("rewardOpenTime"),l("rewardEndTime"),l("rewardLastUpdateTime"),l("totalReward"),l("totalRewardEmissioned"),l("rewardClaimed"),l("rewardPerSecond"),Y("accRewardPerShare"),k("rewardVault"),k("rewardMint"),k("rewardSender"),l("rewardType"),H(l(),15,"padding")]),zi=R([l("state"),l("nonce"),k("lpVault"),k("rewardVault"),k(),k(),l(),l(),l("totalReward"),Y("perShareReward"),l("lastSlot"),l("perSlotReward")]),Zi=R([l("state"),l("nonce"),k("lpVault"),k("rewardVaultA"),l("totalRewardA"),Y("perShareRewardA"),l("perSlotRewardA"),v("option"),k("rewardVaultB"),ze(7),l("totalRewardB"),Y("perShareRewardB"),l("perSlotRewardB"),l("lastSlot"),k()]),Xi=R([l(),l("state"),l("nonce"),l("validRewardTokenNum"),Y("rewardMultiplier"),l("rewardPeriodMax"),l("rewardPeriodMin"),l("rewardPeriodExtend"),k("lpMint"),k("lpVault"),H(Hi,5,"rewardInfos"),k("creator"),k(),H(l(),32,"padding")]),Lo=new Proxy(zi,{get(n,t,e){return t==="decode"?(...o)=>{let r=n.decode(...o);return K(L({},r),{version:3,rewardInfos:[{rewardVault:r.rewardVault,totalReward:r.totalReward,perSlotReward:r.perSlotReward,perShareReward:r.perShareReward}]})}:Reflect.get(n,t,e)}}),_o=new Proxy(Zi,{get(n,t,e){return t==="decode"?(...o)=>{let r=n.decode(...o);return K(L({},r),{version:5,rewardInfos:[{rewardVault:r.rewardVaultA,totalReward:r.totalRewardA,perSlotReward:r.perSlotRewardA,perShareReward:r.perShareRewardA},{rewardVault:r.rewardVaultB,totalReward:r.totalRewardB,perSlotReward:r.perSlotRewardB,perShareReward:r.perShareRewardB}]})}:Reflect.get(n,t,e)}}),Xe=new Proxy(Xi,{get(n,t,e){return t==="decode"?(...o)=>{let r=n.decode(...o);return K(L({},r),{version:6,rewardInfos:r.rewardInfos.map(i=>{var a;return K(L({},i),{rewardType:((a=Object.entries(Bt).find(u=>String(u[1])===i.rewardType.toString()))!=null?a:["Standard SPL"])[0]})})})}:Reflect.get(n,t,e)}}),ea=R([l("isSet"),l("rewardPerSecond"),l("rewardOpenTime"),l("rewardEndTime"),l("rewardType")]),an=R([v("instruction"),l("nonce"),H(ea,5,"rewardTimeInfo")]),sn=R([v("instruction"),l("rewardReopenTime"),l("rewardEndTime"),l("rewardPerSecond")]),un=R([v("instruction"),l("isSet"),l("rewardPerSecond"),l("rewardOpenTime"),l("rewardEndTime")]),$m=R([l("state"),k("id"),k("owner"),l("deposited"),H(l(),1,"rewardDebts")]),Ro=R([l("state"),k("id"),k("owner"),l("deposited"),H(Y(),1,"rewardDebts"),H(l(),17)]),jm=R([l("state"),k("id"),k("owner"),l("deposited"),H(l(),2,"rewardDebts")]),Mo=R([l("state"),k("id"),k("owner"),l("deposited"),H(Y(),2,"rewardDebts"),H(l(),17)]),Bo=R([l(),l("state"),k("id"),k("owner"),l("deposited"),H(Y(),5,"rewardDebts"),H(l(),16)]),et=R([v("instruction"),l("amount")]);var Ko=M("Raydium_farm_config"),Oo="EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q",ta=new tt(Oo),qo="9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z",na=new tt(qo),Fo="FarmqiPv5eAj3j1GMdMCMUGXqPUvmquZtMy86QH6rzhG",oa=new tt(Fo),No={[Oo]:3,[qo]:5,[Fo]:6},vo={3:ta,5:na,6:oa},Do=new tt("4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R"),Eo=new tt("FrspKwj8i3pNmKwXreTveC4fu7KL5ZbGeXdZBe2XViu1"),Vo={3:Lo,5:_o,6:Xe},Co={3:Ro,5:Mo,6:Bo},cn=n=>[3,5,6].indexOf(n)!==-1,ra={3:10,5:11,6:1},Wo=n=>{let t=ra[n];return t||Ko.logWithError("invalid deposit farm version"),t},ia={3:11,5:12,6:2},Uo=n=>{let t=ia[n];return t||Ko.logWithError("invalid withdraw farm version"),t},Go=n=>{var a;let{version:t,rewardInfos:e,rewardTokenAccountsPublicKeys:o}=n,r=`rewardInfo:${JSON.stringify(e)}, rewardAccount:${JSON.stringify(o)}`,i={3:()=>{if(e.length!==1||o.length!==1)return`rewardInfos or rewardTokenAccounts lengths not equal 1: ${r}`},5:()=>{if(e.length!==o.length)return`rewardInfos and rewardTokenAccounts lengths not equal: ${r}`},6:()=>{if(!o.length||e.length!==o.length)return`no rewardTokenAccounts or rewardInfos and rewardTokenAccounts lengths not equal: ${r}`}};return(a=i[t])==null?void 0:a.call(i)},Bt={"Standard SPL":0,"Option tokens":1};import{SystemProgram as aa,SYSVAR_RENT_PUBKEY as sa,TransactionInstruction as Jo}from"@solana/web3.js";import ua from"bn.js";var ca=M("Raydium_farm_instruction");async function $o(n){let{version:t,id:e,ledger:o,programId:r,owner:i}=n,a={3:9,5:10}[t];a||ca.logWithError(`invalid farm pool version: ${t}`);let u=Buffer.alloc(on.span);on.encode({instruction:a},u);let c=[s({pubkey:e}),s({pubkey:o}),s({pubkey:i,isWritable:!1}),s({pubkey:aa.programId,isWritable:!1}),s({pubkey:sa,isWritable:!1})];return new Jo({programId:r,keys:c,data:u})}function jo(n){var o;let t=Buffer.alloc(an.span);an.encode({instruction:0,nonce:new ua(n.nonce),rewardTimeInfo:n.rewardInfoConfig},t);let e=[...Ke,s({pubkey:n.farmKeyPair.publicKey}),s({pubkey:n.farmAuthority,isWritable:!1}),s({pubkey:n.lpVault}),s({pubkey:n.lpMint,isWritable:!1}),s({pubkey:n.lockVault}),s({pubkey:n.lockMint,isWritable:!1}),s({pubkey:(o=n.lockUserAccount)!=null?o:W}),s({pubkey:n.owner,isWritable:!1,isSigner:!0})];for(let r of n.rewardInfo)e.push(s({pubkey:r.rewardMint,isWritable:!1}),s({pubkey:r.rewardVault}),s({pubkey:r.userRewardToken}));return new Jo({programId:n.programId,keys:e,data:t})}import z from"bn.js";var nt=M("Raydium.farm.util");async function Kt({programId:n,poolId:t,mint:e,type:o}){let{publicKey:r}=await Pe([t.toBuffer(),e.toBuffer(),Buffer.from(o==="lpVault"?"lp_vault_associated_seed":o==="rewardVault"?"reward_vault_associated_seed":"","utf-8")],n);return r}function ma(n){let e=E({publicKey:n}).toBase58();return No[e]}async function mn({programId:n,poolId:t,owner:e}){let{publicKey:o}=await Pe([t.toBuffer(),e.toBuffer(),Buffer.from(ma(n)===6?"farmer_info_associated_seed":"staker_info_v2_associated_seed","utf-8")],n);return o}var Yo=async({programId:n,poolId:t})=>await Pe([t.toBuffer()],n);function Qo(n){return vo[n]}function Ho(n){return{isSet:new z(1),rewardPerSecond:x(n.rewardPerSecond),rewardOpenTime:x(n.rewardOpenTime),rewardEndTime:x(n.rewardEndTime),rewardType:x(n.rewardType)}}function ln(n){return x(n.rewardEndTime).sub(x(n.rewardOpenTime)).mul(x(n.rewardPerSecond))}function la(n){let t=Co[n];return t||nt.logWithError("invalid version",n),t}function da(n){let t=Vo[n];return t||nt.logWithError("invalid version",n),t}function pa(n,t,e,o){if(n.version===3||n.version===5){if(n.lastSlot.gte(new z(e)))return n;let r=new z(e).sub(n.lastSlot);n.lastSlot=new z(e);for(let i of n.rewardInfos){if(t.amount.eq(new z(0)))continue;let a=i.perSlotReward.mul(r);i.perShareReward=i.perShareReward.add(a.mul(new z(10).pow(new z(n.version===3?9:15))).div(t.amount)),i.totalReward=i.totalReward.add(a)}}else if(n.version===6)for(let r of n.rewardInfos){if(r.rewardState.eq(new z(0)))continue;let i=z.min(new z(o),r.rewardEndTime);if(r.rewardOpenTime.gte(i))continue;let u=i.sub(r.rewardLastUpdateTime).mul(r.rewardPerSecond),c=r.totalReward.sub(r.totalRewardEmissioned);c.lt(u)?(u=c,r.rewardLastUpdateTime=r.rewardLastUpdateTime.add(c.div(r.rewardPerSecond))):r.rewardLastUpdateTime=i,!t.amount.eq(new z(0))&&(r.accRewardPerShare=r.accRewardPerShare.add(u.mul(n.rewardMultiplier).div(t.amount)),r.totalRewardEmissioned=r.totalRewardEmissioned.add(u))}return n}async function fa({connection:n,farmPools:t,owner:e,config:o}){var y;let r=!1,i=!1,a=new z(10),u=[];for(let f of t){let b=me(f);b.version===6?i=!0:r=!0,u.push({pubkey:b.id,version:b.version,key:"state",poolId:b.id},{pubkey:b.lpVault,version:b.version,key:"lpVault",poolId:b.id}),e&&u.push({pubkey:await mn({programId:b.programId,poolId:b.id,owner:e}),version:b.version,key:"ledger",poolId:b.id})}let c={},m=await po(n,u,o);for(let{pubkey:f,version:b,key:h,poolId:S,accountInfo:g}of m){let T=S.toBase58();if(c[T]=L({},c[T]),h==="state"){let _=da(b);(!g||!g.data||g.data.length!==_.span)&&nt.logWithError(`invalid farm state account info, pools.id, ${f}`),c[T].state=_.decode(g.data)}else if(h==="lpVault")(!g||!g.data||g.data.length!==we.span)&&nt.logWithError(`invalid farm lp vault account info, pools.lpVault, ${f}`),c[T].lpVault=we.decode(g.data);else if(h==="ledger"){let _=la(b);g&&g.data&&(g.data.length!==_.span&&nt.logWithError(`invalid farm ledger account info, ledger, ${f}`),c[T].ledger=_.decode(g.data))}}let d=i||r?await n.getSlot():0,p=i&&(y=await n.getBlockTime(d))!=null?y:0;for(let f of Object.keys(c))c[f].state=pa(c[f].state,c[f].lpVault,d,p);for(let[f,{state:b,ledger:h}]of Object.entries(c))if(h){let S=b.version===6?b.rewardMultiplier:b.rewardInfos.length===1?a.pow(new z(9)):a.pow(new z(15)),g=b.rewardInfos.map((T,_)=>{let A=h.rewardDebts[_];return h.deposited.mul(b.version===6?T.accRewardPerShare:T.perShareReward).div(S).sub(A)});c[f].wrapped=K(L({},c[f].wrapped),{pendingRewards:g})}return c}async function zo(n){let{farmPools:t}=n,e=await fa(n);return t.map((r,i)=>K(L(L(L({},t[i]),me(r)),e[r.id]),{jsonInfo:t[i]}))}function Zo(n,t=Date.now()){if(n.version===6){let e=n.state.rewardInfos;if(e.every(({rewardOpenTime:o})=>He(t,o.toNumber(),{unit:"s"})))return"upcoming pool";if(e.every(({rewardEndTime:o})=>De(t,o.toNumber(),{unit:"s"})))return"closed pool"}else{let e=n.state.rewardInfos.map(({perSlotReward:o})=>o);if(e.length===2){if(String(e[0])==="0"&&String(e[1])!=="0")return"normal fusion pool";if(String(e[0])!=="0"&&String(e[1])!=="0")return"dual fusion pool";if(String(e[0])==="0"&&String(e[1])==="0")return"closed pool"}else if(e.length===1&&String(e[0])==="0")return"closed pool"}}function Xo(n){return n.state.rewardInfos.length===1&&String(n.lpMint)===At.toBase58()}function er(n,t){return n.version===6?n.state.rewardInfos.map(({rewardPerSecond:e,rewardOpenTime:o,rewardEndTime:r},i)=>{var y;let a=He(t.currentBlockChainDate,o.toNumber(),{unit:"s"}),u=De(t.currentBlockChainDate,r.toNumber(),{unit:"s"});if(a||u)return;let c=t.rewardTokens[i];if(!c)return;let m=t.rewardTokenPrices[i];if(!m)return;let d=$e(new I(e,pe).div(be.pow(new z(c.decimals||1))).mul(new z(60*60*24*365)),m);return t.tvl?t.tvl.isZero()?Be(0):d.div((y=t.tvl)!=null?y:pe):void 0}):n.state.rewardInfos.map(({perSlotReward:o},r)=>{var m;let i=t.rewardTokens[r];if(!i)return;let a=t.rewardTokenPrices[r];if(!a)return;let u=$e(new I(o,pe).div(be.pow(new z(i.decimals||1))).mul(new z(t.blockSlotCountForSecond*60*60*24*365)),a);return t.tvl?t.tvl.isZero()?Be(0):u.div((m=t.tvl)!=null?m:pe):void 0})}var it=class extends re{constructor(){super(...arguments);this._farmPools=[];this._hydratedFarmPools=[];this._hydratedFarmMap=new Map;this._sdkParsedFarmPools=[];this._lpTokenInfoMap=new Map}async load(e){var r;await this.scope.liquidity.load(e),await this.scope.fetchFarms(e==null?void 0:e.forceUpdate);let o=((r=this.scope.apiData.farmPools)==null?void 0:r.data)||{};this._farmPools=Object.keys(o||{}).reduce((i,a)=>{var u,c;return i.concat(((c=(u=o[a]).map)==null?void 0:c.call(u,m=>{let d=this.scope.token.allTokenMap.get(m.baseMint),p=this.scope.token.allTokenMap.get(m.quoteMint);return d&&p&&this._lpTokenInfoMap.set(m.lpMint,new G({mint:m.lpMint,decimals:d.decimals,symbol:`${d.symbol} - ${p.name}`,name:`${d.symbol} - ${p.name} LP`})),K(L({},m),{name:m.symbol,category:a})}))||[])},[]),await this.fetchSdkFarmInfo()}async fetchSdkFarmInfo(){var e;this._sdkParsedFarmPools=await zo({connection:this.scope.connection,farmPools:this._farmPools,owner:(e=this.scope.owner)==null?void 0:e.publicKey,config:{commitment:"confirmed"}})}async loadHydratedFarmInfo(e){let{forceUpdate:o,skipPrice:r}=e||{};if(this._hydratedFarmPools.length&&!o)return this._hydratedFarmPools;await this.scope.farm.load(),!r&&await this.scope.token.fetchTokenPrices(),await this.scope.liquidity.loadPairs();let i=await this.scope.chainTimeOffset(),a=zt(Date.now()+i,{minutes:0}),u=await this.scope.api.getBlockSlotCountForSecond(this.scope.connection.rpcEndpoint),c=Object.fromEntries(this.scope.liquidity.allPairs.map(m=>[m.ammId,{apr30d:m.apr30d,apr7d:m.apr7d,apr24h:m.apr24h}]));return this._hydratedFarmPools=this._sdkParsedFarmPools.map(m=>{let d=this.hydrateFarmInfo({farmInfo:m,blockSlotCountForSecond:u,farmAprs:c,currentBlockChainDate:a,chainTimeOffset:i});return this._hydratedFarmMap.set(m.id.toBase58(),d),d}),this._hydratedFarmPools}get allFarms(){return this._farmPools}get allParsedFarms(){return this._sdkParsedFarmPools}get allHydratedFarms(){return this._hydratedFarmPools}get allHydratedFarmMap(){return this._hydratedFarmMap}getFarm(e){let o=E({publicKey:e}),r=this.allFarms.find(i=>i.id===o.toBase58());return r||this.logAndCreateError("invalid farm id"),r}getParsedFarm(e){let o=E({publicKey:e}),r=this.allParsedFarms.find(i=>o.equals(i.id));return r||this.logAndCreateError("invalid farm id"),r}getLpTokenInfo(e){let o=E({publicKey:e}),r=this._lpTokenInfoMap.get(o.toBase58());return r||this.logAndCreateError("LP Token not found",o.toBase58()),r}lpDecimalAmount({mint:e,amount:o}){let r=se(o),i=this.getLpTokenInfo(e);return Ie(new I(r.numerator,r.denominator).mul(new dn(10).pow(new dn(i.decimals))))}hydrateFarmInfo(e){var dt,pt,Ce,We,Ue,ft,Ln,_n,Rn,Mn,Bn,Kn;let{farmInfo:o,blockSlotCountForSecond:r,farmAprs:i,currentBlockChainDate:a,chainTimeOffset:u=0}=e,c=Zo(o,a),m=Xo(o),d=c==="dual fusion pool",p=c==="normal fusion pool",y=c==="closed pool"&&!o.upcoming,f=o.version!==6?o.upcoming&&y:o.upcoming,b=o.version!==6&&o.upcoming&&!y,h=((dt=this.scope.liquidity.allPools.find(B=>B.lpMint===o.lpMint.toBase58()))==null?void 0:dt.version)===5,S=m?this.scope.mintToToken(o.lpMint):this.getLpTokenInfo(o.lpMint),g=this.scope.mintToToken(m?o.lpMint:o.baseMint),T=this.scope.mintToToken(m?o.lpMint:o.quoteMint);g!=null&&g.symbol;let _=m?`${(pt=g==null?void 0:g.symbol)!=null?pt:"unknown"}`:`${(Ce=g==null?void 0:g.symbol)!=null?Ce:"unknown"}-${(We=T==null?void 0:T.symbol)!=null?We:"unknown"}`,A=o.jsonInfo.rewardInfos.map(({rewardMint:B})=>this.scope.mintToToken(B)),q=(Ue=o.wrapped)==null?void 0:Ue.pendingRewards.map((B,C)=>A[C]?new O(A[C],Ie(bo(B,0))):void 0),F=m?this.scope.token.tokenPrices.get(o.lpMint.toBase58()):this.scope.liquidity.lpPriceMap.get(o.lpMint.toBase58()),N=S&&new O(S,o.lpVault.amount),J=F&&S?$e(new O(S,o.lpVault.amount),F):void 0,D=er(o,{tvl:J,currentBlockChainDate:a,rewardTokens:A,rewardTokenPrices:(ft=o.rewardInfos.map(({rewardMint:B})=>this.scope.token.tokenPrices.get(B.toBase58())))!=null?ft:[],blockSlotCountForSecond:r}),U=(Ln=this.scope.liquidity.allPools.find(B=>B.lpMint===o.lpMint.toBase58()))==null?void 0:Ln.id,X=U?wt((_n=i[U])==null?void 0:_n.apr7d,{alreadyDecimaled:!0}):void 0,$=U?wt((Rn=i[U])==null?void 0:Rn.apr30d,{alreadyDecimaled:!0}):void 0,ne=U?wt((Mn=i[U])==null?void 0:Mn.apr24h,{alreadyDecimaled:!0}):void 0,ie=D.reduce((B,C)=>B?C?B.add(C):B:C,X),Ae=D.reduce((B,C)=>B?C?B.add(C):B:C,$),ce=D.reduce((B,C)=>B?C?B.add(C):B:C,ne),fe=o.version===6?o.state.rewardInfos.map((B,C)=>{var Nn,vn,Dn,En;let{rewardOpenTime:Ge,rewardEndTime:yt,rewardPerSecond:Vt}=B,Me=Ge.toNumber()?new Date(Ge.toNumber()*1e3+u):void 0,ye=yt.toNumber()?new Date(yt.toNumber()*1e3+u):void 0,Ct=Date.now()+u;if(!Me&&!ye)return;let ve=this.scope.mintToToken((Dn=(vn=B.rewardMint)!=null?vn:(Nn=o.rewardInfos[C])==null?void 0:Nn.rewardMint)==null?void 0:Dn.toBase58()),On=Boolean(Me&&He(Ct,Me)),qn=Boolean(ye&&De(Ct,ye)),Fn=!Me&&!ye||!qn&&!On,Ur=Fn&&De(Ct,zt(ye,{seconds:-((En=o.jsonInfo.rewardPeriodExtend)!=null?En:72*60*60)})),Gr=ve&&this.scope.mintToTokenAmount({mint:ve.mint,amount:yo(B.totalReward,B.totalRewardEmissioned).toFixed(ve.decimals)}),Jr=q==null?void 0:q[C],$r=D[C],jr=Boolean(ye),bt=o.rewardInfos[C];return K(L(L({},bt),B),{owner:bt==null?void 0:bt.rewardSender,apr:$r,token:ve,userPendingReward:Jr,userHavedReward:jr,perSecond:ve&&this.scope.mintToTokenAmount({mint:ve.mint,amount:Vt}).toSignificant(),openTime:Me,endTime:ye,isOptionToken:B.rewardType==="Option tokens",isRewardBeforeStart:On,isRewardEnded:qn,isRewarding:Fn,isRwardingBeforeEnd72h:Ur,claimableRewards:Gr,version:6})}).filter(B=>!!B):o.state.rewardInfos.map((B,C)=>{let Ge=q==null?void 0:q[C],yt=D[C],Vt=A[C],{perSlotReward:Me}=B,ye=St(Ge)||St(Me);return K(L({},B),{apr:yt,token:Vt,userPendingReward:Ge,userHavedReward:ye,version:o.version})}),de=S&&((Bn=o.ledger)==null?void 0:Bn.deposited)?new O(S,(Kn=o.ledger)==null?void 0:Kn.deposited):void 0;return K(L({},o),{lp:S,lpPrice:F,base:g,quote:T,name:_,isStakePool:m,isDualFusionPool:d,isNormalFusionPool:p,isClosedPool:y,isUpcomingPool:f,isStablePool:h,isNewPool:b,totalApr7d:ie,raydiumFeeApr7d:X,totalApr24h:ce,raydiumFeeApr24h:ne,totalApr30d:Ae,raydiumFeeApr30d:$,ammId:U,tvl:J,userHasStaked:St(de),rewards:fe,userStakedLpAmount:de,stakedLpAmount:N})}async _getUserRewardInfo({payer:e,rewardInfo:o}){if(o.rewardMint.equals(W)){let r=await Le({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:e,amount:ln(o)});return{rewardPubKey:r.signers[0].publicKey,newInstruction:r}}return{rewardPubKey:await this.scope.account.getCreatedTokenAccount({mint:o.rewardMint})}}async create({poolId:e,rewardInfos:o,payer:r}){this.checkDisabled(),this.scope.checkOwner();let i=E({publicKey:e}),a=this.scope.liquidity.allPools.find(A=>A.id===i.toBase58());a||this.logAndCreateError("invalid pool id");let c={lpMint:new Z(a.lpMint),lockInfo:{lockMint:Do,lockVault:Eo},version:6,rewardInfos:o,programId:Qo(6)},m=this.createTxBuilder(),d=r!=null?r:this.scope.ownerPubKey,p=ba.generate(),y=await this.scope.connection.getMinimumBalanceForRentExemption(Xe.span);m.addInstruction({instructions:[tr.createAccount({fromPubkey:d,newAccountPubkey:p.publicKey,lamports:y,space:Xe.span,programId:c.programId})],signers:[p]});let{publicKey:f,nonce:b}=await Yo({programId:c.programId,poolId:p.publicKey}),h=await Kt({programId:c.programId,poolId:p.publicKey,mint:c.lpMint,type:"lpVault"}),S=[],g=[];for(let A of c.rewardInfos){A.rewardOpenTime>=A.rewardEndTime&&this.logAndCreateError("start time error","rewardInfo.rewardOpenTime",A.rewardOpenTime.toString()),Bt[A.rewardType]||this.logAndCreateError("rewardType error",A.rewardType),A.rewardPerSecond<=0&&this.logAndCreateError("rewardPerSecond error",A.rewardPerSecond.toString()),S.push(Ho(A));let{rewardPubKey:q,newInstruction:F}=await this._getUserRewardInfo({rewardInfo:A,payer:d});F&&m.addInstruction(F),q||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let N=A.rewardMint.equals(W)?new Z(j.mint):A.rewardMint;g.push({rewardMint:N,rewardVault:await Kt({programId:c.programId,poolId:p.publicKey,mint:N,type:"rewardVault"}),userRewardToken:q})}let T=await this.scope.account.getCreatedTokenAccount({mint:c.lockInfo.lockMint});T||this.logAndCreateError("cannot found lock vault","tokenAccounts",this.scope.account.tokenAccounts);let _=jo({farmKeyPair:p,owner:this.scope.ownerPubKey,farmAuthority:f,lpVault:h,lpMint:c.lpMint,lockVault:c.lockInfo.lockVault,lockMint:c.lockInfo.lockMint,lockUserAccount:T,programId:c.programId,rewardInfo:g,rewardInfoConfig:S,nonce:b});return await m.addInstruction({instructions:[_]}).build()}async restartReward({farmId:e,payer:o,newRewardInfo:r}){let i=this.getFarm(e);i.version!==6&&this.logAndCreateError("invalid farm version",i.version);let a={id:new Z(i.id),rewardInfos:i.rewardInfos,lpVault:new Z(i.lpVault),programId:new Z(i.programId)};r.rewardOpenTime>=r.rewardEndTime&&this.logAndCreateError("start time error","newRewardInfo",r);let u=o||this.scope.ownerPubKey,c=r.rewardMint.equals(W)?new Z(j.mint):r.rewardMint,m=a.rewardInfos.find(S=>new Z(S.rewardMint).equals(c));m||this.logAndCreateError("configuration does not exist","rewardMint",c);let d=m.rewardVault?new Z(m.rewardVault):W,p=this.createTxBuilder(),{rewardPubKey:y,newInstruction:f}=await this._getUserRewardInfo({rewardInfo:r,payer:u});f&&p.addInstruction(f),y||this.logAndCreateError("cannot found target token accounts",this.scope.account.tokenAccounts);let b=Buffer.alloc(sn.span);sn.encode({instruction:3,rewardReopenTime:x(r.rewardOpenTime),rewardEndTime:x(r.rewardEndTime),rewardPerSecond:x(r.rewardPerSecond)},b);let h=[s({pubkey:ot,isWritable:!1}),s({pubkey:a.id}),s({pubkey:a.lpVault,isWritable:!1}),s({pubkey:d}),s({pubkey:y}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await p.addInstruction({instructions:[new rt({programId:a.programId,keys:h,data:b})]}).build()}async addNewRewardToken(e){let{farmId:o,newRewardInfo:r,payer:i}=e,a=this.getFarm(o);a.version!==6&&this.logAndCreateError("invalid farm version",a.version);let u=i!=null?i:this.scope.ownerPubKey,c=this.createTxBuilder(),m=await Kt({programId:new Z(a.programId),poolId:new Z(a.id),mint:r.rewardMint,type:"rewardVault"}),{rewardPubKey:d,newInstruction:p}=await this._getUserRewardInfo({rewardInfo:r,payer:u});p&&c.addInstruction(p),d||this.logAndCreateError("annot found target token accounts",this.scope.account.tokenAccounts);let y=r.rewardMint.equals(W)?new Z(j.mint):r.rewardMint,f=Buffer.alloc(un.span);un.encode({instruction:4,isSet:new dn(1),rewardPerSecond:x(r.rewardPerSecond),rewardOpenTime:x(r.rewardOpenTime),rewardEndTime:x(r.rewardEndTime)},f);let b=[...Ke,s({pubkey:new Z(a.id)}),s({pubkey:new Z(a.authority),isWritable:!1}),s({pubkey:y,isWritable:!1}),s({pubkey:m}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await c.addInstruction({instructions:[new rt({programId:new Z(a.programId),keys:b,data:f})]}).build()}async _prepareFarmAccounts(e){let o=this.createTxBuilder(),{farmInfo:r}=e,{pubKey:i,newInstructions:a}=await this.scope.account.checkOrCreateAta({mint:r.lpMint});o.addInstruction(a);let u=await Promise.all(r.rewardInfos.map(async({rewardMint:d})=>{let{pubKey:p,newInstructions:y}=await this.scope.account.checkOrCreateAta({mint:d,autoUnwrapWSOLToSOL:!0});return o.addInstruction(y),p})),c=await mn({programId:new Z(r.programId),poolId:new Z(r.id),owner:this.scope.ownerPubKey});if(!r.ledger&&r.version<6){let d=await $o({id:r.id,programId:r.programId,version:r.version,ledger:c,owner:this.scope.ownerPubKey});o.addInstruction({instructions:[d]})}let m=[s({pubkey:r.id}),s({pubkey:r.authority,isWritable:!1}),s({pubkey:c}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:i}),s({pubkey:new Z(r.jsonInfo.lpVault)}),s({pubkey:u[0]}),s({pubkey:r.rewardInfos[0].rewardVault}),s({pubkey:ga,isWritable:!1}),s({pubkey:ot,isWritable:!1})];return{txBuilder:o,lpTokenAccount:i,rewardTokenAccountsPublicKeys:u,ledgerAddress:c,lowVersionKeys:m}}async deposit(e){this.scope.checkOwner();let{farmId:o,amount:r}=e,i=this.getParsedFarm(o),a=i.lpMint,{version:u,rewardInfos:c}=i;cn(u)||this.logAndCreateError("invalid farm version:",u);let{txBuilder:m,ledgerAddress:d,lpTokenAccount:p,lowVersionKeys:y,rewardTokenAccountsPublicKeys:f}=await this._prepareFarmAccounts({mint:a,farmInfo:i}),b=Go({version:u,rewardInfos:c,rewardTokenAccountsPublicKeys:f});b&&this.logAndCreateError(b);let h=Buffer.alloc(et.span);et.encode({instruction:Wo(u),amount:x(r)},h);let S=u===6?[s({pubkey:ot,isWritable:!1}),s({pubkey:tr.programId,isWritable:!1}),s({pubkey:i.id}),s({pubkey:i.authority,isWritable:!1}),s({pubkey:i.lpVault.mint}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:p})]:y;if(u!==3)for(let T=1;T<c.length;T++)S.push(s({pubkey:f[T]})),S.push(s({pubkey:c[T].rewardVault}));let g=new rt({programId:i.programId,keys:S,data:h});return await m.addInstruction({instructions:[g]}).build()}async withdraw(e){this.scope.checkOwner();let{farmId:o,amount:r}=e,i=this.getParsedFarm(o),a=i.lpMint,{version:u,rewardInfos:c}=i;cn(u)||this.logAndCreateError("invalid farm version:",u);let{txBuilder:m,ledgerAddress:d,lpTokenAccount:p,lowVersionKeys:y,rewardTokenAccountsPublicKeys:f}=await this._prepareFarmAccounts({mint:a,farmInfo:i}),b=Buffer.alloc(et.span);et.encode({instruction:Uo(u),amount:x(r)},b);let h=u===6?[s({pubkey:ot,isWritable:!1}),s({pubkey:i.id}),s({pubkey:i.authority,isWritable:!1}),s({pubkey:i.lpVault.mint}),s({pubkey:d}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0}),s({pubkey:p})]:y;if(u!==3)for(let g=1;g<c.length;g++)h.push(s({pubkey:f[g]})),h.push(s({pubkey:c[g].rewardVault}));let S=new rt({programId:i.programId,keys:h,data:b});return await m.addInstruction({instructions:[S]}).build()}async withdrawFarmReward({farmId:e,withdrawMint:o}){var y;this.scope.checkOwner();let r=this.getParsedFarm(e),{version:i}=r;i!==6&&this.logAndCreateError("invalid farm version",r.version);let a=r.rewardInfos.find(f=>f.rewardMint.equals(o.equals(W)?new Z(j.mint):o));a||this.logAndCreateError("withdraw mint error","rewardInfos",r);let u=(y=a==null?void 0:a.rewardVault)!=null?y:W,c=this.createTxBuilder(),m;if(this._getUserRewardInfo({payer:this.scope.ownerPubKey,rewardInfo:a}),o.equals(W)){let f=await Le({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:ln(a)});m=f.signers[0].publicKey,c.addInstruction(f)}else{let f=await this.scope.account.getCreatedTokenAccount({mint:o});f===null?(m=await this.scope.account.getAssociatedTokenAccount(o),c.addInstruction({instructions:[ya(this.scope.ownerPubKey,m,this.scope.ownerPubKey,o)]})):m=f}let d=Buffer.alloc(rn.span);rn.encode({instruction:5},d);let p=[s({pubkey:ot,isWritable:!1}),s({pubkey:r.id}),s({pubkey:r.authority,isWritable:!1}),s({pubkey:r.lpVault.mint,isWritable:!1}),s({pubkey:u}),s({pubkey:m}),s({pubkey:this.scope.ownerPubKey,isWritable:!1,isSigner:!0})];return await c.addInstruction({instructions:[new rt({programId:r.programId,keys:p,data:d})]}).build()}};import{ComputeBudgetProgram as Wa}from"@solana/web3.js";import Te from"bn.js";import{PublicKey as nr}from"@solana/web3.js";import or from"bn.js";var rr=(c=>(c[c.Uninitialized=0]="Uninitialized",c[c.Initialized=1]="Initialized",c[c.Disabled=2]="Disabled",c[c.RemoveLiquidityOnly=3]="RemoveLiquidityOnly",c[c.LiquidityOnly=4]="LiquidityOnly",c[c.OrderBook=5]="OrderBook",c[c.Swap=6]="Swap",c[c.WaitingForStart=7]="WaitingForStart",c))(rr||{}),ir=new or(25),ar=new or(1e4),sr="675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8",Pa=new nr(sr),ur="5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h",wa=new nr(ur),td={[sr]:4,[ur]:5},cr={4:Pa,5:wa},mr={4:3,5:3};import{TOKEN_PROGRAM_ID as kn}from"@solana/spl-token";import{SystemProgram as Oa,TransactionInstruction as ke}from"@solana/web3.js";var pn=R([v("instruction"),l("amountIn"),l("minAmountOut")]),fn=R([v("instruction"),l("maxAmountIn"),l("amountOut")]),yn=R([v("instruction"),v("nonce")]),bn=R([v("instruction"),v("nonce"),l("startTime")]),gn=R([l("status"),l("nonce"),l("maxOrder"),l("depth"),l("baseDecimal"),l("quoteDecimal"),l("state"),l("resetFlag"),l("minSize"),l("volMaxCutRatio"),l("amountWaveRatio"),l("baseLotSize"),l("quoteLotSize"),l("minPriceMultiplier"),l("maxPriceMultiplier"),l("systemDecimalValue"),l("minSeparateNumerator"),l("minSeparateDenominator"),l("tradeFeeNumerator"),l("tradeFeeDenominator"),l("pnlNumerator"),l("pnlDenominator"),l("swapFeeNumerator"),l("swapFeeDenominator"),l("baseNeedTakePnl"),l("quoteNeedTakePnl"),l("quoteTotalPnl"),l("baseTotalPnl"),Y("quoteTotalDeposited"),Y("baseTotalDeposited"),Y("swapBaseInAmount"),Y("swapQuoteOutAmount"),l("swapBase2QuoteFee"),Y("swapQuoteInAmount"),Y("swapBaseOutAmount"),l("swapQuote2BaseFee"),k("baseVault"),k("quoteVault"),k("baseMint"),k("quoteMint"),k("lpMint"),k("openOrders"),k("marketId"),k("marketProgramId"),k("targetOrders"),k("withdrawQueue"),k("lpVault"),k("owner"),l("lpReserve"),H(l(),3,"padding")]),ha=R([l("accountType"),l("status"),l("nonce"),l("maxOrder"),l("depth"),l("baseDecimal"),l("quoteDecimal"),l("state"),l("resetFlag"),l("minSize"),l("volMaxCutRatio"),l("amountWaveRatio"),l("baseLotSize"),l("quoteLotSize"),l("minPriceMultiplier"),l("maxPriceMultiplier"),l("systemDecimalsValue"),l("abortTradeFactor"),l("priceTickMultiplier"),l("priceTick"),l("minSeparateNumerator"),l("minSeparateDenominator"),l("tradeFeeNumerator"),l("tradeFeeDenominator"),l("pnlNumerator"),l("pnlDenominator"),l("swapFeeNumerator"),l("swapFeeDenominator"),l("baseNeedTakePnl"),l("quoteNeedTakePnl"),l("quoteTotalPnl"),l("baseTotalPnl"),l("poolOpenTime"),l("punishPcAmount"),l("punishCoinAmount"),l("orderbookToInitTime"),Y("swapBaseInAmount"),Y("swapQuoteOutAmount"),Y("swapQuoteInAmount"),Y("swapBaseOutAmount"),l("swapQuote2BaseFee"),l("swapBase2QuoteFee"),k("baseVault"),k("quoteVault"),k("baseMint"),k("quoteMint"),k("lpMint"),k("modelDataAccount"),k("openOrders"),k("marketId"),k("marketProgramId"),k("targetOrders"),k("owner"),H(l(),64,"padding")]),Pn=R([v("instruction"),l("baseAmountIn"),l("quoteAmountIn"),l("fixedSide")]),wn=R([v("instruction"),l("amountIn")]),lr={4:gn,5:ha};import{PublicKey as ka}from"@solana/web3.js";var he=new ka("CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo"),Ne=5e4,Ta=R([l("x"),l("y"),l("price")]),Aa=R([l("accountType"),l("status"),l("multiplier"),l("validDataCount"),H(Ta,Ne,"DataElement")]);function Ia(n,t){return[0,Ne-2]}function xa(n){return[0,Ne-2]}function Sa(n){return[0,Ne-2]}function La(n,t,e){let[o,r]=Ia(t,e),i=o,a=r,u=0,c=t*n.multiplier/e;for(;i<=a;){if(u=Math.floor((a+i)/2),u===0||u>=Ne-2)return[u,u,!1];let m=n.DataElement[u].x*n.multiplier/n.DataElement[u].y,d=n.DataElement[u-1].x*n.multiplier/n.DataElement[u-1].y,p=n.DataElement[u+1].x*n.multiplier/n.DataElement[u+1].y;if(c===m)return[u,u,!0];if(c===d)return[u-1,u-1,!0];if(c===p)return[u+1,u+1,!0];if(c<d)a=u-1;else{if(c>d&&c<m)return[u-1,u,!0];if(c>m&&c<p)return[u,u+1,!0];i=u+1}}return[u,u,!1]}function hn(n,t,e){let[o,r,i]=La(n,t,e);if(!i)return 0;if(o===r){let a=n.DataElement[o].x;return t*n.multiplier/a}else{let a=n.DataElement[o].x,u=n.DataElement[o].y,c=n.DataElement[r].x,m=n.DataElement[r].y,d=e*(c*u-a*m),p=a*d,y=(c-a)*(t*u-a*e)*m,f=p+y;return t*n.multiplier*d/f}}function Fe(n,t,e){return t*n.multiplier/e}function dr(n,t,e){return t*e/n.multiplier}function _a(n,t){let[e,o]=xa(t),r=e,i=o,a=0,u=t;for(;r<i;){if(a=Math.floor((i+r)/2),a<=0||a>Ne-2)return[a,a,!1];let c=n.DataElement[a].x,m=n.DataElement[a-1].x,d=n.DataElement[a+1].x;if(u===c)return[a,a,!0];if(u===m)return[a-1,a-1,!0];if(u===d)return[a+1,a+1,!0];if(u<m)i=a-1;else{if(u>m&&u<c)return[a-1,a,!0];if(u>c&&u<d)return[a,a+1,!0];r=a+1}}return[a,a,!1]}function Ra(n,t){let[e,o]=Sa(t),r=e,i=o,a=0,u=t;for(;r<=i;){if(a=Math.floor((i+r)/2),a<=0||a>=Ne-2)return[a,a,!1];let c=n.DataElement[a].y,m=n.DataElement[a-1].y,d=n.DataElement[a+1].y;if(u===c)return[a,a,!0];if(u===m)return[a-1,a-1,!0];if(u===d)return[a+1,a+1,!0];if(u<d)r=a+1;else{if(u<m&&u>c)return[a-1,a,!0];if(u<c&&u>d)return[a,a+1,!0];i=a-1}}return[a,a,!1]}function pr(n,t,e,o){let r=o?t+e:t-e,[i,a,u]=_a(n,r);if(!u)return[0,0,!1,u];if(i===a)return[n.DataElement[a].price,n.DataElement[a].y,!1,u];{let c=n.DataElement[i].x,m=n.DataElement[a].x,d=n.DataElement[i].price,p=n.DataElement[a].price,y=n.DataElement[i].y,f=n.DataElement[a].y;if(t>=c&&t<=m)return o?[p,f,!0,u]:[d,y,!0,u];{let b,h;return o?(b=d+(p-d)*(t-c)/(m-c),h=y-(r-c)*n.multiplier/p):(b=d+(p-d)*(t-c)/(m-c),h=f+(m-r)*n.multiplier/d),[b,h,!1,u]}}}function Ma(n,t,e,o){let r=o?t-e:t+e,[i,a,u]=Ra(n,r);if(!u)return[0,0,!1,u];if(i===a)return[n.DataElement[a].price,n.DataElement[a].x,!1,u];{let c=n.DataElement[i].x,m=n.DataElement[a].x,d=n.DataElement[i].price,p=n.DataElement[a].price,y=n.DataElement[i].y,f=n.DataElement[a].y;if(t>=f&&t<=y)return o?[p,m,!0,u]:[d,c,!0,u];{let b,h;return o?(b=d+(p-d)*(y-t)/(y-f),h=c+p*(y-r)/n.multiplier):(b=d+(p-d)*(y-t)/(y-f),h=m-d*(r-f)/n.multiplier),[b,h,!1,u]}}}function Ba(n,t){let e=pr(n,t,0,!1);return e[3]?e[0]:0}function fr(n,t,e,o){let r=hn(n,t,e),i=Fe(n,t,r),a=Fe(n,e,r),u=Fe(n,o,r),c=!0,[m,d,p,y]=pr(n,i,u,c);if(!y)return 0;if(p)return o*n.multiplier/m;{let f=a-d;return dr(n,f,r)}}function yr(n,t,e,o){let r=hn(n,t,e),i=Fe(n,t,r),a=Fe(n,e,r),u=Fe(n,o,r),c=!1,[m,d,p,y]=Ma(n,a,u,c);if(!y)return 0;if(p)return o*m/n.multiplier;{let f=i-d;return dr(n,f,r)}}function Ka(n){let t=Aa.decode(n);return{accountType:t.accountType.toNumber(),status:t.status.toNumber(),multiplier:t.multiplier.toNumber(),validDataCount:t.validDataCount.toNumber(),DataElement:t.DataElement.map(e=>({x:e.x.toNumber(),y:e.y.toNumber(),price:e.price.toNumber()}))}}function br(n,t,e,o){let r=Ba(n,Fe(n,t,hn(n,t,e)))/n.multiplier;return o?r:1/r}var Ot=class{constructor({connection:t}){this._layoutData={accountType:0,status:0,multiplier:0,validDataCount:0,DataElement:[]};this.connection=t}get stableModelData(){return this._layoutData}async initStableModelLayout(){if(this._layoutData.validDataCount===0&&this.connection){let t=await this.connection.getAccountInfo(he);t&&(this._layoutData=Ka(t==null?void 0:t.data))}}};var qt=M("Raydium_liquidity_instruction");function gr(n){let{poolKeys:t,userKeys:e,amountIn:o,amountOut:r,fixedSide:i}=n,{version:a}=t;if(a===4||a===5){let u={poolKeys:t,userKeys:e};if(i==="in")return qa(K(L({},u),{amountIn:o,minAmountOut:r}),a);if(i==="out")return Fa(K(L({},u),{maxAmountIn:o,amountOut:r}),a);qt.logWithError("invalid params","params",n)}throw qt.logWithError("invalid version","poolKeys.version",a),new Error("invalid version")}function Pr(n){let t=R([v("instruction"),v("simulateType")]),e=Buffer.alloc(t.span);t.encode({instruction:12,simulateType:0},e);let o=[s({pubkey:n.id,isWritable:!1}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders,isWritable:!1}),s({pubkey:n.baseVault,isWritable:!1}),s({pubkey:n.quoteVault,isWritable:!1}),s({pubkey:n.lpMint,isWritable:!1}),s({pubkey:n.marketId,isWritable:!1})];return new ke({programId:n.programId,keys:o,data:e})}function qa({poolKeys:n,userKeys:t,amountIn:e,minAmountOut:o},r){let i=Buffer.alloc(pn.span);pn.encode({instruction:9,amountIn:x(e),minAmountOut:x(o)},i);let a=[s({pubkey:kn,isWritable:!1}),s({pubkey:n.id}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders})];return r===4&&a.push(s({pubkey:n.targetOrders})),a.push(s({pubkey:n.baseVault}),s({pubkey:n.quoteVault})),r===5&&a.push(s({pubkey:he})),a.push(s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.marketBaseVault}),s({pubkey:n.marketQuoteVault}),s({pubkey:n.marketAuthority,isWritable:!1}),s({pubkey:t.tokenAccountIn}),s({pubkey:t.tokenAccountOut}),s({pubkey:t.owner,isWritable:!1})),new ke({programId:n.programId,keys:a,data:i})}function Fa({poolKeys:n,userKeys:t,maxAmountIn:e,amountOut:o},r){let i=Buffer.alloc(fn.span);fn.encode({instruction:11,maxAmountIn:x(e),amountOut:x(o)},i);let a=[s({pubkey:Oa.programId,isWritable:!1}),s({pubkey:n.id}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders}),s({pubkey:n.targetOrders}),s({pubkey:n.baseVault}),s({pubkey:n.quoteVault})];return r===5&&a.push(s({pubkey:he})),a.push(s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.marketBaseVault}),s({pubkey:n.marketQuoteVault}),s({pubkey:n.marketAuthority,isWritable:!1}),s({pubkey:t.tokenAccountIn}),s({pubkey:t.tokenAccountOut}),s({pubkey:t.owner,isWritable:!1,isSigner:!0})),new ke({programId:n.programId,keys:a,data:i})}function wr(n){let i=n,{owner:t}=i,e=ee(i,["owner"]),o=Buffer.alloc(yn.span);yn.encode({instruction:10,nonce:e.nonce},o);let r=[...Ke,s({pubkey:e.targetOrders}),s({pubkey:e.withdrawQueue}),s({pubkey:e.authority,isWritable:!1}),s({pubkey:e.lpMint}),s({pubkey:e.baseMint,isWritable:!1}),s({pubkey:e.quoteMint,isWritable:!1}),s({pubkey:e.baseVault}),s({pubkey:e.quoteVault}),s({pubkey:e.lpVault}),s({pubkey:e.marketId,isWritable:!1}),s({pubkey:t,isSigner:!0})];return new ke({programId:e.programId,keys:r,data:o})}function hr(n){let{poolKeys:t,userKeys:e,startTime:o}=n,r=Buffer.alloc(bn.span);bn.encode({instruction:0,nonce:t.nonce,startTime:x(o)},r);let i=[...Ke,s({pubkey:t.id}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.openOrders}),s({pubkey:t.lpMint}),s({pubkey:t.baseMint,isWritable:!1}),s({pubkey:t.quoteMint,isWritable:!1}),s({pubkey:t.baseVault,isWritable:!1}),s({pubkey:t.quoteVault,isWritable:!1}),s({pubkey:t.withdrawQueue}),s({pubkey:t.targetOrders}),s({pubkey:e.lpTokenAccount}),s({pubkey:t.lpVault,isWritable:!1}),s({pubkey:t.marketProgramId,isWritable:!1}),s({pubkey:t.marketId,isWritable:!1}),s({pubkey:e.payer,isSigner:!0})];return new ke({programId:t.programId,keys:i,data:r})}function kr(n){let{poolKeys:t,userKeys:e,baseAmountIn:o,quoteAmountIn:r,fixedSide:i}=n,{version:a}=t;if(a===4||a===5){let u=Buffer.alloc(Pn.span);Pn.encode({instruction:3,baseAmountIn:x(o),quoteAmountIn:x(r),fixedSide:x(i==="base"?0:1)},u);let c=[s({pubkey:kn,isWritable:!1}),s({pubkey:t.id}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.openOrders,isWritable:!1}),s({pubkey:t.targetOrders}),s({pubkey:t.lpMint}),s({pubkey:t.baseVault}),s({pubkey:t.quoteVault})];return a===5&&c.push(s({pubkey:he})),c.push(s({pubkey:t.marketId,isWritable:!1}),s({pubkey:e.baseTokenAccount}),s({pubkey:e.quoteTokenAccount}),s({pubkey:e.lpTokenAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})),new ke({programId:t.programId,keys:c,data:u})}return qt.logWithError("invalid version","poolKeys.version",a),new ke({programId:t.programId,keys:[]})}function Tr(n){let{poolKeys:t,userKeys:e,amountIn:o}=n,{version:r}=t;if(r===4||r===5){let i=Buffer.alloc(wn.span);wn.encode({instruction:4,amountIn:x(o)},i);let a=[s({pubkey:kn,isWritable:!1}),s({pubkey:t.id}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.openOrders}),s({pubkey:t.targetOrders}),s({pubkey:t.lpMint}),s({pubkey:t.baseVault}),s({pubkey:t.quoteVault})];return r===5?a.push(s({pubkey:he})):a.push(s({pubkey:t.withdrawQueue}),s({pubkey:t.lpVault})),a.push(s({pubkey:t.marketProgramId,isWritable:!1}),s({pubkey:t.marketId}),s({pubkey:t.marketBaseVault}),s({pubkey:t.marketQuoteVault}),s({pubkey:t.marketAuthority,isWritable:!1}),s({pubkey:e.lpTokenAccount}),s({pubkey:e.baseTokenAccount}),s({pubkey:e.quoteTokenAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0}),s({pubkey:t.marketEventQueue}),s({pubkey:t.marketBids}),s({pubkey:t.marketAsks})),new ke({programId:t.programId,keys:a,data:i})}return qt.logWithError("invalid version","poolKeys.version",r),new ke({programId:t.programId,keys:[]})}import{OpenOrders as Da}from"@project-serum/serum";import at from"bn.js";import{PublicKey as Ar}from"@solana/web3.js";var Tn=M("Raydium_liquidity_serum"),Ir="9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin",Na=new Ar(Ir),Ad={[Ir]:3},va={3:Na};function xr(n){let t=mr[n];return t||Tn.logWithError("invalid version","version",n),t}function Sr(n){let t=va[n];return t||Tn.logWithError("invalid version","version",n),t}async function Lr({programId:n,marketId:t}){let e=[t.toBuffer()],o=0,r;for(;o<100;){try{let i=e.concat(Buffer.from([o]),Buffer.alloc(7));r=await Ar.createProgramAddress(i,n)}catch(i){if(i instanceof TypeError)throw i;o++;continue}return{publicKey:r,nonce:o}}throw Tn.logWithError("unable to find a viable program address nonce","params",{programId:n,marketId:t}),new Error("unable to find a viable program address nonce")}var Ft=M("Raydium_liquidity_util");function An(n,t){let e=n instanceof O?n.token:G.WSOL,{baseMint:o,quoteMint:r}=t;if(e.mint.equals(o))return"base";if(e.mint.equals(r))return"quote";let i=`liquidity getTokenSide - token not match with pool, params: ${JSON.stringify({token:e.mint,baseMint:o,quoteMint:r})}`;throw console.error(i),new Error(i)}function Ve(n,t){let{baseMint:e,quoteMint:o}=t;return n.mint.equals(e)||n.mint.equals(o)}function In(n){let{status:t,startTime:e}=n,o=t.toNumber();return{[0]:{swap:!1,addLiquidity:!1,removeLiquidity:!1},[1]:{swap:!0,addLiquidity:!0,removeLiquidity:!0},[2]:{swap:!1,addLiquidity:!1,removeLiquidity:!1},[3]:{swap:!1,addLiquidity:!1,removeLiquidity:!0},[4]:{swap:!1,addLiquidity:!0,removeLiquidity:!0},[5]:{swap:!1,addLiquidity:!0,removeLiquidity:!0},[6]:{swap:!0,addLiquidity:!0,removeLiquidity:!0},[7]:{swap:Date.now()/1e3>=e.toNumber(),addLiquidity:!0,removeLiquidity:!0}}[o]||{swap:!1,addLiquidity:!1,removeLiquidity:!1}}function vd(n){let t=lr[n];return t||Ft.logWithError("invalid version","version",n),t}function Ea(n){let t=cr[n];return t||Ft.logWithError("invalid version","version",n),t}async function _e({name:n,programId:t,marketId:e}){let{publicKey:o}=await Pe([t.toBuffer(),e.toBuffer(),Buffer.from(n,"utf-8")],t);return o}async function Va({programId:n}){return Pe([Buffer.from([97,109,109,32,97,117,116,104,111,114,105,116,121])],n)}async function xn({version:n,marketId:t,baseMint:e,quoteMint:o}){let r=Ea(n),[i,a,u]=[E({publicKey:t}),E({publicKey:e,transformSol:!0}),E({publicKey:o,transformSol:!0})],c=await _e({name:"amm_associated_seed",programId:r,marketId:i}),m=await _e({name:"lp_mint_associated_seed",programId:r,marketId:i}),{publicKey:d,nonce:p}=await Va({programId:r}),y=await _e({name:"coin_vault_associated_seed",programId:r,marketId:i}),f=await _e({name:"pc_vault_associated_seed",programId:r,marketId:i}),b=await _e({name:"temp_lp_token_associated_seed",programId:r,marketId:i}),h=await _e({name:"open_order_associated_seed",programId:r,marketId:i}),S=await _e({name:"target_associated_seed",programId:r,marketId:i}),g=await _e({name:"withdraw_associated_seed",programId:r,marketId:i}),T=xr(n),_=Sr(T),{publicKey:A}=await Lr({programId:_,marketId:i});return{id:c,baseMint:a,quoteMint:u,lpMint:m,version:n,programId:r,authority:d,nonce:p,baseVault:y,quoteVault:f,lpVault:b,openOrders:h,targetOrders:S,withdrawQueue:g,marketVersion:T,marketProgramId:_,marketId:i,marketAuthority:A}}async function Rr({connection:n,pools:t}){let e=t.map(r=>Pr(r));return(await co(n,e,"GetPoolData")).map(r=>{let i=mo(r,"GetPoolData"),a=new at(ge(i,"status")),u=Number(ge(i,"coin_decimals")),c=Number(ge(i,"pc_decimals")),m=Number(ge(i,"lp_decimals")),d=new at(ge(i,"pool_coin_amount")),p=new at(ge(i,"pool_pc_amount")),y=new at(ge(i,"pool_lp_supply")),f="0";try{f=ge(i,"pool_open_time")}catch{f="0"}return{status:a,baseDecimals:u,quoteDecimals:c,lpDecimals:m,baseReserve:d,quoteReserve:p,lpSupply:y,startTime:new at(f)}})}function Mr(n,t,e){return Ca(n.token,t.token,e)}function Ca(n,t,e){let{baseMint:o,quoteMint:r}=e,i=_r(n,e),a=_r(t,e);return i===a&&Ft.logWithError("tokens not match with pool","params",{tokenA:n.mint,tokenB:t.mint,baseMint:o,quoteMint:r}),[i,a]}function _r(n,t){let{baseMint:e,quoteMint:o}=t;return n.mint.equals(e)?"base":n.mint.equals(o)?"quote":(Ft.logWithError("token not match with pool","params",{token:n.mint,baseMint:e,quoteMint:o}),"base")}var Br=n=>n==="a"||n==="b";async function Dd(n,t,e){let o=await n.getAccountInfo(t);if(o===null)return null;let r=gn.decode(o.data),i=await n.getTokenAccountBalance(r.baseVault),a=await n.getTokenAccountBalance(r.quoteVault),u=await Da.load(n,r.openOrders,e),c=10**r.baseDecimal.toNumber(),m=10**r.quoteDecimal.toNumber(),d=u.baseTokenTotal.toNumber()/c,p=u.quoteTokenTotal.toNumber()/m,y=r.baseNeedTakePnl.toNumber()/c,f=r.quoteNeedTakePnl.toNumber()/m,b=i.value.uiAmount+d-y,h=a.value.uiAmount+p-f,S=parseFloat(r.lpReserve.toString()),g=b/h;return{baseAmount:b,quoteAmount:h,lpSupply:S,baseVaultKey:r.baseVault,quoteVaultKey:r.quoteVault,baseVaultBalance:i.value.uiAmount,quoteVaultBalance:a.value.uiAmount,openOrdersKey:r.openOrders,openOrdersTotalBase:d,openOrdersTotalQuote:p,basePnl:y,quotePnl:f,priceInQuote:g}}var st=class extends re{constructor(e){super(e);this._poolInfos=[];this._poolInfoMap=new Map;this._pairsInfo=[];this._pairsInfoMap=new Map;this._lpTokenMap=new Map;this._lpPriceMap=new Map;this._officialIds=new Set;this._unOfficialIds=new Set;this._sdkParseInfoCache=new Map;this._stableLayout=new Ot({connection:this.scope.connection})}async load(e){if(await this.scope.fetchLiquidity(e==null?void 0:e.forceUpdate),!this.scope.apiData.liquidityPools)return;let{data:o}=this.scope.apiData.liquidityPools,[r,i]=[o.official||[],o.unOfficial||[]];this._poolInfos=[...r,...i],this._officialIds=new Set(r.map(a=>{var c,m;let u=`${(c=this.scope.token.allTokenMap.get(a.baseMint))==null?void 0:c.symbol} - ${(m=this.scope.token.allTokenMap.get(a.quoteMint))==null?void 0:m.symbol}`;return this._poolInfoMap.set(a.id,a),this._lpTokenMap.set(a.lpMint,new G({mint:a.lpMint,decimals:a.lpDecimals,symbol:u,name:`${u} LP`})),a.id})),this._unOfficialIds=new Set(i.map(a=>{var c,m;let u=`${(c=this.scope.token.allTokenMap.get(a.baseMint))==null?void 0:c.symbol} - ${(m=this.scope.token.allTokenMap.get(a.quoteMint))==null?void 0:m.symbol}`;return this._poolInfoMap.set(a.id,a),this._lpTokenMap.set(a.lpMint,new G({mint:a.lpMint,decimals:a.lpDecimals,symbol:u,name:`${u} LP`})),a.id}))}async loadPairs(e){var o;return await this.scope.fetchPairs(e==null?void 0:e.forceUpdate),this._pairsInfo=((o=this.scope.apiData.liquidityPairsInfo)==null?void 0:o.data)||[],this._pairsInfoMap=new Map(this._pairsInfo.map(r=>{let i=this._lpTokenMap.get(r.lpMint),a=i&&r.lpPrice?Je({token:i,numberPrice:r.lpPrice,decimalDone:!0}):null;return a&&this._lpPriceMap.set(r.lpMint,a),[r.ammId,r]})),this._pairsInfo}get allPools(){return this._poolInfos}get allPoolIdSet(){return{official:this._officialIds,unOfficial:this._unOfficialIds}}get allPoolMap(){return this._poolInfoMap}get allPairs(){return this._pairsInfo}get allPairsMap(){return this._pairsInfoMap}get lpTokenMap(){return this._lpTokenMap}get lpPriceMap(){return this._lpPriceMap}async fetchMultipleInfo(e){return await this._stableLayout.initStableModelLayout(),await Rr(K(L({},e),{connection:this.scope.connection}))}async sdkParseJsonLiquidityInfo(e){if(!e.length)return[];let o=e.map(r=>r.id).join("-");if(this._sdkParseInfoCache.has(o))return this._sdkParseInfoCache.get(o);try{let i=(await this.fetchMultipleInfo({pools:e.map(me)})).map((a,u)=>L(L({jsonInfo:e[u]},me(e[u])),a));return this._sdkParseInfoCache.set(o,i),i}catch(r){return console.error(r),[]}}computeAmountOut({poolKeys:e,poolInfo:o,amountIn:r,outputToken:i,slippage:a}){this.checkDisabled();let u=M("Raydium_computeAmountOut"),c=r.token,m=i;(!Ve(c,e)||!Ve(m,e))&&u.logWithError("token not match with pool","poolKeys",e);let{baseReserve:d,quoteReserve:p}=o;this.logDebug("baseReserve:",d.toString(),"quoteReserve:",p.toString());let y=r.token;this.logDebug("inputToken:",y),this.logDebug("amountIn:",r.toFixed()),this.logDebug("outputToken:",i),this.logDebug("slippage:",`${a.toSignificant()}%`);let f=[d,p],b=An(r,e);b==="quote"&&f.reverse(),this.logDebug("input side:",b);let[h,S]=f,g;if(e.version===4)g=new Q({baseToken:y,denominator:h,quoteToken:i,numerator:S});else{let $=br(this._stableLayout.stableModelData,d.toNumber(),p.toNumber(),!1);g=new Q({baseToken:y,denominator:b==="quote"?new Te($*1e6):new Te(1e6),quoteToken:i,numerator:b==="quote"?new Te(1e6):new Te($*1e6)})}this.logDebug("currentPrice:",`1 ${y.symbol} \u2248 ${g.toFixed()} ${i.symbol}`),this.logDebug("currentPrice invert:",`1 ${i.symbol} \u2248 ${g.invert().toFixed()} ${y.symbol}`);let T=r.raw,_=ae,A=ae;if(!T.isZero())if(e.version===4){A=T.mul(ir).div(ar);let $=T.sub(A),ne=h.add($);_=S.mul($).div(ne)}else{A=T.mul(new Te(2)).div(new Te(1e4));let $=T.sub(A),ne=b==="quote"?fr:yr;_=new Te(ne(this._stableLayout.stableModelData,p.toNumber(),d.toNumber(),$.toNumber()))}let F=new oe(pe).add(a).invert().mul(_).quotient,N=new O(i,_),J=new O(i,F);this.logDebug("amountOut:",N.toFixed(),"minAmountOut:",J.toFixed());let D=new Q({baseToken:y,denominator:T.sub(A),quoteToken:i,numerator:_});!T.isZero()&&!_.isZero()&&(D=new Q({baseToken:y,denominator:T.sub(A),quoteToken:i,numerator:_}),this.logDebug("executionPrice:",`1 ${y.symbol} \u2248 ${D.toFixed()} ${i.symbol}`),this.logDebug("executionPrice invert:",`1 ${i.symbol} \u2248 ${D.invert().toFixed()} ${y.symbol}`));let U=new oe(parseInt(String(Math.abs(parseFloat(D.toFixed())-parseFloat(g.toFixed()))*1e9)),parseInt(String(parseFloat(g.toFixed())*1e9))),X=new O(y,A);return{amountOut:N,minAmountOut:J,currentPrice:g,executionPrice:D,priceImpact:U,fee:X}}async computePairAmount({poolId:e,amount:o,anotherToken:r,slippage:i}){let a=E({publicKey:e}),u=this._poolInfoMap.get(a.toBase58());u||this.logAndCreateError("pool not found",a.toBase58());let c=(await this.sdkParseJsonLiquidityInfo([u]))[0];c||this.logAndCreateError("pool parseInfo not found",a.toBase58());let{baseReserve:m,quoteReserve:d}=c;this.logDebug("baseReserve:",m.toString(),"quoteReserve:",d.toString());let p=o.token;this.logDebug("tokenIn:",p,"amount:",o.toFixed(),"anotherToken:",r,"slippage:",`${i.toSignificant()}%`);let y=An(o,me(u));this.logDebug("input side:",y);let f=ae;o.isZero()||(f=y==="base"?Ut(o.raw.mul(d),m):Ut(o.raw.mul(m),d));let h=new oe(pe).add(i).mul(f).quotient,S=new O(r,f),g=new O(r,h);return this.logDebug("anotherAmount:",S.toFixed(),"maxAnotherAmount:",g.toFixed()),{anotherAmount:S,maxAnotherAmount:g}}async swapWithAMM(e){let{poolKeys:o,payer:r,amountIn:i,amountOut:a,fixedSide:u,config:c}=e;this.logDebug("amountIn:",i),this.logDebug("amountOut:",a),(i.isZero()||a.isZero())&&this.logAndCreateError("amounts must greater than zero","amounts",{amountIn:i.toFixed(),amountOut:a.toFixed()});let{account:m}=this.scope,d=this.createTxBuilder(),{bypassAssociatedCheck:p=!1}=c||{},[y,f]=[i.token,a.token],b=await m.getCreatedTokenAccount({mint:y.mint,associatedOnly:!1}),h=await m.getCreatedTokenAccount({mint:f.mint}),[S,g]=[i.raw,a.raw],F=await m.handleTokenAccount({side:"in",amount:S,mint:y.mint,tokenAccount:b,bypassAssociatedCheck:p}),{tokenAccount:T}=F,_=ee(F,["tokenAccount"]);d.addInstruction(_);let N=await m.handleTokenAccount({side:"out",amount:0,mint:f.mint,tokenAccount:h,payer:r,bypassAssociatedCheck:p}),{tokenAccount:A}=N,q=ee(N,["tokenAccount"]);return d.addInstruction(q),d.addInstruction({instructions:[gr({poolKeys:o,userKeys:{tokenAccountIn:T,tokenAccountOut:A,owner:this.scope.ownerPubKey},amountIn:S,amountOut:g,fixedSide:u})]}),d.buildMultiTx({extInfo:{amountOut:a}})}async createPool(e){this.checkDisabled(),this.scope.checkOwner(),e.version!==4&&this.logAndCreateError("invalid version","poolKeys.version",e.version);let o=this.createTxBuilder(),r=await xn(e);return await o.addInstruction({instructions:[wr(K(L({},r),{owner:this.scope.ownerPubKey}))]}).build()}async initPool(e){e.version!==4&&this.logAndCreateError("invalid version","poolKeys.version",e.version);let{baseAmount:o,quoteAmount:r,startTime:i=0,config:a}=e,u=await xn(e),{baseMint:c,quoteMint:m,lpMint:d,baseVault:p,quoteVault:y}=u,f=this.createTxBuilder(),{account:b}=this.scope,h=!!(a!=null&&a.bypassAssociatedCheck),S=await b.getCreatedTokenAccount({mint:c,associatedOnly:!1}),g=await b.getCreatedTokenAccount({mint:m,associatedOnly:!1});!S&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",b.tokenAccounts);let T=await b.getCreatedTokenAccount({mint:d,associatedOnly:!1}),D=await b.handleTokenAccount({side:"in",amount:o.raw,mint:c,tokenAccount:S,bypassAssociatedCheck:h}),{tokenAccount:_}=D,A=ee(D,["tokenAccount"]);f.addInstruction(A);let U=await b.handleTokenAccount({side:"in",amount:r.raw,mint:m,tokenAccount:g,bypassAssociatedCheck:h}),{tokenAccount:q}=U,F=ee(U,["tokenAccount"]);f.addInstruction(F);let X=await b.handleTokenAccount({side:"out",amount:0,mint:d,tokenAccount:T,bypassAssociatedCheck:h}),{tokenAccount:N}=X,J=ee(X,["tokenAccount"]);return f.addInstruction(J),f.addInstruction({instructions:[Ee({source:_,destination:p,owner:this.scope.ownerPubKey,amount:o.raw}),Ee({source:q,destination:y,owner:this.scope.ownerPubKey,amount:r.raw}),hr({poolKeys:u,userKeys:{lpTokenAccount:N,payer:this.scope.ownerPubKey},startTime:i})]}),await f.build()}async addLiquidity(e){let{poolId:o,amountInA:r,amountInB:i,fixedSide:a,config:u}=e,c=E({publicKey:o}),m=this.allPools.find(ft=>ft.id===c.toBase58());m||this.logAndCreateError("pool not found",o);let p=(await this.sdkParseJsonLiquidityInfo([m]))[0];p||this.logAndCreateError("pool parse error",p),this.logDebug("amountInA:",r,"amountInB:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amountInA & amountInB",{amountInA:r.toFixed(),amountInB:i.toFixed()});let{account:y}=this.scope,f=(u==null?void 0:u.bypassAssociatedCheck)||!1,[b,h]=[r.token,i.token],S=await y.getCreatedTokenAccount({mint:b.mint,associatedOnly:!1}),g=await y.getCreatedTokenAccount({mint:h.mint,associatedOnly:!1});!S&&!g&&this.logAndCreateError("cannot found target token accounts","tokenAccounts",y.tokenAccounts);let T=await y.getCreatedTokenAccount({mint:p.lpMint}),_=[b,h],A=[S,g],q=[r.raw,i.raw],[F]=Mr(r,i,p),N="base";(!["quote","base"].includes(F)||!Br(a))&&this.logAndCreateError("invalid fixedSide","fixedSide",a),F==="quote"?(_.reverse(),A.reverse(),q.reverse(),N=a==="a"?"quote":"base"):F==="base"&&(N=a==="a"?"base":"quote");let[J,D]=_,[U,X]=A,[$,ne]=q,ie=this.createTxBuilder(),Ce=await y.handleTokenAccount({side:"in",amount:$,mint:J.mint,tokenAccount:U,bypassAssociatedCheck:f}),{tokenAccount:Ae}=Ce,ce=ee(Ce,["tokenAccount"]);ie.addInstruction(ce);let We=await y.handleTokenAccount({side:"in",amount:ne,mint:D.mint,tokenAccount:X,bypassAssociatedCheck:f}),{tokenAccount:fe}=We,de=ee(We,["tokenAccount"]);ie.addInstruction(de);let Ue=await y.handleTokenAccount({side:"out",amount:0,mint:p.lpMint,tokenAccount:T,bypassAssociatedCheck:f}),{tokenAccount:dt}=Ue,pt=ee(Ue,["tokenAccount"]);return ie.addInstruction(pt),ie.addInstruction({instructions:[kr({poolKeys:p,userKeys:{baseTokenAccount:Ae,quoteTokenAccount:fe,lpTokenAccount:dt,owner:this.scope.ownerPubKey},baseAmountIn:$,quoteAmountIn:ne,fixedSide:N})]}),await ie.build()}async removeLiquidity(e){let{poolId:o,amountIn:r,config:i}=e,a=E({publicKey:o}),u=this.allPools.find(D=>D.id===a.toBase58());u||this.logAndCreateError("pool not found",o);let m=(await this.sdkParseJsonLiquidityInfo([u]))[0];m||this.logAndCreateError("pool pass error",m);let{baseMint:d,quoteMint:p,lpMint:y}=m;this.logDebug("amountIn:",r),r.isZero()&&this.logAndCreateError("amount must greater than zero","amountIn",r.toFixed()),r.token.mint.equals(y)||this.logAndCreateError("amountIn's token not match lpMint","amountIn",r);let{account:f}=this.scope,b=await f.getCreatedTokenAccount({mint:y,associatedOnly:!1});b||this.logAndCreateError("cannot found lpTokenAccount","tokenAccounts",f.tokenAccounts);let h=await f.getCreatedTokenAccount({mint:d}),S=await f.getCreatedTokenAccount({mint:p}),g=this.createTxBuilder(),T=(i==null?void 0:i.bypassAssociatedCheck)||!1,N=await f.handleTokenAccount({side:"out",amount:0,mint:d,tokenAccount:h,bypassAssociatedCheck:T}),{tokenAccount:_}=N,A=ee(N,["tokenAccount"]);g.addInstruction(A);let J=await f.handleTokenAccount({side:"out",amount:0,mint:p,tokenAccount:S,bypassAssociatedCheck:T}),{tokenAccount:q}=J,F=ee(J,["tokenAccount"]);return g.addInstruction(F),g.addInstruction({instructions:[Wa.requestUnits({units:4e5,additionalFee:0}),Tr({poolKeys:m,userKeys:{lpTokenAccount:b,baseTokenAccount:_,quoteTokenAccount:q,owner:this.scope.ownerPubKey},amountIn:r.raw})]}),await g.build()}lpMintToTokenAmount({poolId:e,amount:o,decimalDone:r}){let i=E({publicKey:e});i||this.logAndCreateError("pool not found");let a=this._poolInfoMap.get(i.toBase58()),u=se(o),c=new G({mint:a.lpMint,decimals:a.lpDecimals}),m=r?new I(u.numerator,u.denominator):new I(u.numerator,u.denominator).mul(new Te(10).pow(new Te(c.decimals)));return new O(c,Ie(m))}getFixedSide({poolId:e,inputMint:o}){let[r,i]=[E({publicKey:e}),E({publicKey:o})],a=this._poolInfoMap.get(r.toBase58());a||this.logAndCreateError("pool not found",r.toBase58());let u=a.baseMint===i.toBase58();return(i.equals(xe)||i.equals(W))&&(u=!u),u?"a":"b"}};import{PublicKey as Dr}from"@solana/web3.js";import{intersection as Er,xor as Ya}from"lodash";import{PublicKey as Ua}from"@solana/web3.js";var Ga="routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS",ut=new Ua(Ga),Kr=["amm","serum","route"],Or=[Xn,At,xe,to,Zn,no,oo,eo,ro].map(n=>n.toBase58());import{TOKEN_PROGRAM_ID as Dt}from"@solana/spl-token";import{SystemProgram as qr,TransactionInstruction as Fr}from"@solana/web3.js";var Nt=R([v("instruction"),l("amountIn"),l("amountOut")]),vt=R([v("instruction")]);var Ja=M("Raydium_route_instruction");function Nr(n){let{fixedSide:t}=n;if(t==="in")return[$a(n),ja(n)];throw Ja.logWithError("invalid params","params",n),new Error(`invalid params, params: ${n}`)}function $a({fromPoolKeys:n,toPoolKeys:t,userKeys:e,amountIn:o,amountOut:r}){let i=Buffer.alloc(Nt.span),a;return n.version===4?(Nt.encode({instruction:0,amountIn:x(o),amountOut:x(r)},i),a=[s({pubkey:qr.programId,isWritable:!1}),s({pubkey:Dt,isWritable:!1}),s({pubkey:n.programId,isWritable:!1}),s({pubkey:n.id}),s({pubkey:t.id,isWritable:!1}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders}),s({pubkey:n.baseVault}),s({pubkey:n.quoteVault}),s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.marketBaseVault}),s({pubkey:n.marketQuoteVault}),s({pubkey:n.marketAuthority,isWritable:!1}),s({pubkey:e.inTokenAccount}),s({pubkey:e.middleTokenAccount}),s({pubkey:e.middleStatusAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})]):(Nt.encode({instruction:2,amountIn:x(o),amountOut:x(r)},i),a=[s({pubkey:qr.programId,isWritable:!1}),s({pubkey:Dt,isWritable:!1}),s({pubkey:n.programId,isWritable:!1}),s({pubkey:n.id}),s({pubkey:t.id,isWritable:!1}),s({pubkey:n.authority,isWritable:!1}),s({pubkey:n.openOrders}),s({pubkey:n.baseVault}),s({pubkey:n.quoteVault}),s({pubkey:he,isWritable:!1}),s({pubkey:n.marketProgramId,isWritable:!1}),s({pubkey:n.marketId}),s({pubkey:n.marketBids}),s({pubkey:n.marketAsks}),s({pubkey:n.marketEventQueue}),s({pubkey:n.id}),s({pubkey:n.id}),s({pubkey:n.id}),s({pubkey:e.inTokenAccount}),s({pubkey:e.middleTokenAccount}),s({pubkey:e.middleStatusAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})]),new Fr({programId:ut,keys:a,data:i})}function ja({fromPoolKeys:n,toPoolKeys:t,userKeys:e}){let o=Buffer.alloc(vt.span),r;return t.version===4?(vt.encode({instruction:1},o),r=[s({pubkey:Dt,isWritable:!1}),s({pubkey:t.programId,isWritable:!1}),s({pubkey:n.id,isWritable:!1}),s({pubkey:t.id}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.openOrders}),s({pubkey:t.baseVault}),s({pubkey:t.quoteVault}),s({pubkey:t.marketProgramId,isWritable:!1}),s({pubkey:t.marketId}),s({pubkey:t.marketBids}),s({pubkey:t.marketAsks}),s({pubkey:t.marketEventQueue}),s({pubkey:t.marketBaseVault}),s({pubkey:t.marketQuoteVault}),s({pubkey:t.marketAuthority,isWritable:!1}),s({pubkey:e.middleTokenAccount}),s({pubkey:e.outTokenAccount}),s({pubkey:e.middleStatusAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})]):(vt.encode({instruction:3},o),r=[s({pubkey:Dt,isWritable:!1}),s({pubkey:t.programId,isWritable:!1}),s({pubkey:n.id,isWritable:!1}),s({pubkey:t.id}),s({pubkey:t.authority,isWritable:!1}),s({pubkey:t.openOrders}),s({pubkey:t.baseVault}),s({pubkey:t.quoteVault}),s({pubkey:he,isWritable:!1}),s({pubkey:t.marketProgramId,isWritable:!1}),s({pubkey:t.marketId}),s({pubkey:t.marketBids}),s({pubkey:t.marketAsks}),s({pubkey:t.marketEventQueue}),s({pubkey:t.id}),s({pubkey:t.id}),s({pubkey:t.id}),s({pubkey:e.middleTokenAccount}),s({pubkey:e.outTokenAccount}),s({pubkey:e.middleStatusAccount}),s({pubkey:e.owner,isWritable:!1,isSigner:!0})]),new Fr({programId:ut,keys:r,data:o})}async function vr({programId:n,fromPoolId:t,middleMint:e,owner:o}){let{publicKey:r}=await Pe([t.toBuffer(),e.toBuffer(),o.toBuffer()],n);return r}var ct=class extends re{constructor(t){super(t)}computeRouteAmountOut({fromPoolKeys:t,toPoolKeys:e,fromPoolInfo:o,toPoolInfo:r,amountIn:i,outputToken:a,slippage:u}){let{swap:c}=In(o),{swap:m}=In(r);(!c||!m)&&this.logAndCreateError("pools swap not enabled","pools",{fromPoolKeys:t,toPoolKeys:e,fromPoolInfo:o,toPoolInfo:r});let d=i.token,p=a;(!Ve(d,t)||!Ve(p,e))&&this.logAndCreateError("pools cannot be routed","pools",{fromPoolKeys:t,toPoolKeys:e});let y=[t.baseMint.toBase58(),t.quoteMint.toBase58()],f=[e.baseMint.toBase58(),e.quoteMint.toBase58()],b=[...y,...f],h=[o.baseDecimals,o.quoteDecimals,r.baseDecimals,r.quoteDecimals],[S,g]=[d.mint.toBase58(),p.mint.toBase58()],T=Ya(y,f);(T.length!==2||!T.includes(S)||!T.includes(g))&&this.logAndCreateError("xor tokens not match","pools",{fromPoolKeys:t,toPoolKeys:e});let _=Er(y,f);_.length!==1&&this.logAndCreateError("cannot found middle token of two pools","pools",{fromPoolKeys:t,toPoolKeys:e});let A=_[0],q=b.indexOf(A);q===-1&&this.logAndCreateError("cannot found middle token","pools",{fromPoolKeys:t,toPoolKeys:e});let F=h[q],N=new Dr(A),J=new G({mint:N,decimals:F});this.logInfo("from pool:",t),this.logInfo("to pool:",e),this.logInfo("intersection mints:",_),this.logInfo("xor mints:",T),this.logInfo("middleMint:",A);let{minAmountOut:D,priceImpact:U,fee:X}=this.scope.liquidity.computeAmountOut({poolKeys:t,poolInfo:o,amountIn:i,outputToken:J,slippage:u}),{amountOut:$,minAmountOut:ne,priceImpact:ie,fee:Ae}=this.scope.liquidity.computeAmountOut({poolKeys:e,poolInfo:r,amountIn:D,outputToken:a,slippage:u}),ce=null,[fe,de]=[i.raw,$.raw];return!fe.isZero()&&!de.isZero()&&(ce=new Q({baseToken:d,denominator:fe,quoteToken:a,numerator:de}),this.logDebug("executionPrice:",`1 ${d.symbol} \u2248 ${ce.toFixed()} ${a.symbol}`),this.logDebug("executionPrice invert:",`1 ${a.symbol} \u2248 ${ce.invert().toFixed()} ${d.symbol}`)),{amountOut:$,minAmountOut:ne,executionPrice:ce,priceImpact:U.add(ie),fee:[X,Ae]}}async swapWithRoute(t){let{fromPoolKeys:e,toPoolKeys:o,amountIn:r,amountOut:i,fixedSide:a,config:u}=t;this.logDebug("amountIn:",r,"amountOut:",i),(r.isZero()||i.isZero())&&this.logAndCreateError("amounts must greater than zero","amounts",{amountIn:r.toFixed(),amountOut:i.toFixed()});let{account:c}=this.scope,{bypassAssociatedCheck:m=!1}=u||{},[d,p]=[r.token,i.token],y=await this.scope.account.getCreatedTokenAccount({mint:d.mint,associatedOnly:!1}),f=await this.scope.account.getCreatedTokenAccount({mint:p.mint}),b=[e.baseMint.toBase58(),e.quoteMint.toBase58()],h=[o.baseMint.toBase58(),o.quoteMint.toBase58()],g=Er(b,h)[0],T=new Dr(g),_=await this.scope.account.getCreatedTokenAccount({mint:T}),[A,q]=[r.raw,i.raw],F=this.createTxBuilder(),N=this.createTxBuilder(),ce=await c.handleTokenAccount({side:"in",amount:A,mint:d.mint,tokenAccount:y,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:J}=ce,D=ee(ce,["tokenAccount"]);F.addInstruction(D);let fe=await c.handleTokenAccount({side:"out",amount:0,mint:p.mint,tokenAccount:f,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:U}=fe,X=ee(fe,["tokenAccount"]);F.addInstruction(X);let de=await c.handleTokenAccount({side:"in",amount:0,mint:T,tokenAccount:_,bypassAssociatedCheck:m,skipCloseAccount:!0}),{tokenAccount:$}=de,ne=ee(de,["tokenAccount"]);F.addInstruction(ne),N.addInstruction({instructions:Nr({fromPoolKeys:e,toPoolKeys:o,userKeys:{inTokenAccount:J,outTokenAccount:U,middleTokenAccount:$,middleStatusAccount:await vr({programId:ut,fromPoolId:e.id,middleMint:T,owner:this.scope.ownerPubKey}),owner:this.scope.ownerPubKey},amountIn:A,amountOut:q,fixedSide:a})});let ie=F.build();return await N.buildMultiTx({extraPreBuildData:[ie],extInfo:{amountOut:q}})}};import{PublicKey as Qa}from"@solana/web3.js";import Cr from"bn.js";var Sn=R([Oe("mintAuthorityOption"),k("mintAuthority"),l("supply"),v("decimals"),v("isInitialized"),Oe("freezeAuthorityOption"),k("freezeAuthority")]);function Vr(n,t){return n.sort((e,o)=>{let{official:r,unOfficial:i}=t,a=new Set(r),u=new Set(i),c=p=>a.has(p.mint)?1:u.has(p.mint)?2:3,m=c(e)-c(o),d=p=>!/^[a-zA-Z]/.test(p);if(m===0){let p=d(e.symbol),y=d(o.symbol);return p&&!y?1:!p&&y?-1:e.symbol.localeCompare(o.symbol)}else return m})}async function Fp(n,t){try{if(!n)return;let e=await n.getAccountInfo(E({publicKey:t}));return!e||e.data.length!==Sn.span?void 0:Sn.decode(e.data)}catch{return}}var mt=class extends re{constructor(e){super(e);this._tokens=[];this._tokenMap=new Map;this._tokenPrice=new Map;this._mintList={official:[],unOfficial:[],unNamed:[]}}async load(e){this.checkDisabled(),await this.scope.fetchTokens(e==null?void 0:e.forceUpdate),this._mintList={official:[],unOfficial:[],unNamed:[]},this._tokens=[],this._tokenMap=new Map;let{data:o}=this.scope.apiData.tokens||{data:{official:[],unOfficial:[],unNamed:[],blacklist:[]}},r=new Set(o.blacklist);[o.official,o.unOfficial,o.unNamed].forEach((i,a)=>{i.forEach(u=>{let c=["official","unOfficial","unNamed"][a];!r.has(u.mint)&&u.mint!==W.toBase58()&&(this._tokens.push(K(L({},u),{symbol:u.symbol||"",name:u.name||""})),this._mintList[c].push(u.mint))})}),this._mintList.official.push(Qe.mint.toBase58()),this._tokens=Vr(this._tokens,this._mintList),this._tokens.push(K(L({},Qe),{mint:W.toBase58()})),this._tokens.forEach(i=>{this._tokenMap.set(i.mint,K(L({},i),{id:i.mint}))}),this._tokenMap.set(j.mint,K(L({},j),{icon:Qe.icon,id:"wsol"})),this._tokenMap.set(W.toBase58(),K(L({},Qe),{mint:W.toBase58()}))}get allTokens(){return this._tokens}get allTokenMap(){return this._tokenMap}get tokenMints(){return this._mintList}get tokenPrices(){return this._tokenPrice}async fetchTokenPrices(e){let o=this.allTokens.filter(m=>{var d;return!!((d=m.extensions)!=null&&d.coingeckoId)&&m.mint!==Qa.default.toBase58()}),r=o.map(m=>m.extensions.coingeckoId),i=await this.scope.api.getCoingeckoPrice(r),a=o.reduce((m,d)=>i[d.extensions.coingeckoId].usd?K(L({},m),{[d.mint]:Je({token:this._tokenMap.get(d.mint),numberPrice:i[d.extensions.coingeckoId].usd,decimalDone:!0})}):m,{}),u=e||await this.scope.api.getRaydiumTokenPrice(),c=Object.keys(u).reduce((m,d)=>this._tokenMap.get(d)?K(L({},m),{[d]:Je({token:this._tokenMap.get(d),numberPrice:u[d],decimalDone:!0})}):m,{});return this._tokenPrice=new Map([...Object.entries(a),...Object.entries(c)]),this._tokenPrice}mintToToken(e){let o=E({publicKey:e,transformSol:!0}),r=this.allTokenMap.get(o.toBase58());r||this.logAndCreateError("token not found, mint:",o.toBase58());let{decimals:i,name:a,symbol:u}=r;return new G({mint:e,decimals:i,name:a,symbol:u})}mintToTokenAmount({mint:e,amount:o,decimalDone:r}){let i=this.mintToToken(e);return r?new O(i,x(o)):new O(i,this.decimalAmount({mint:e,amount:o,decimalDone:r}))}decimalAmount({mint:e,amount:o}){let r=se(o),i=this.mintToToken(e);return Ie(new I(r.numerator,r.denominator).mul(new Cr(10**i.decimals)))}uiAmount({mint:e,amount:o}){let r=se(o),i=this.mintToToken(e);return i?new I(r.numerator,r.denominator).div(new Cr(10**i.decimals)).toSignificant(i.decimals):""}};function Wr(n){let t=[];for(let e=0;e<n.length;e++)for(let o=0;o<n.length;o++)e!=o&&t.push([n[e],n[o]]);return t}var lt=class extends re{async load(){this.checkDisabled(),await this.scope.fetchLiquidity()}async _getBestSwapPool({availablePools:t,officialPoolIdSet:e}){if(t.length===0)return;if(t.length===1)return t[0];let o=t.filter(a=>e.has(a.id));return o.length===1?o[0]:(await this.scope.liquidity.sdkParseJsonLiquidityInfo(o.length?o:t)).reduce((a,u)=>{let c=a.version===5,m=u.version===5;return c&&!m?a:!c&&m?u:fo(Ht(a.lpSupply,10**a.lpDecimals),Ht(u.lpSupply,10**u.lpDecimals))?a:u}).jsonInfo}async getAvailablePools(t){this.checkDisabled();let{inputMint:e,outputMint:o}=t,[r,i]=[E({publicKey:e,transformSol:!0}).toBase58(),E({publicKey:o,transformSol:!0}).toBase58()],a=this.scope.liquidity.allPools.filter(p=>p.baseMint===r&&p.quoteMint===i||p.baseMint===i&&p.quoteMint===r),u=new Set([...Or,r,i]),c=new Set(JSON.parse(JSON.stringify([...u])));c.delete(r),c.delete(i);let m=this.scope.liquidity.allPools.filter(p=>{let y=u.has(p.baseMint)&&u.has(p.quoteMint),f=c.has(p.baseMint)&&c.has(p.quoteMint);return y&&!f}),d=await this._getBestSwapPool({availablePools:a,officialPoolIdSet:this.scope.liquidity.allPoolIdSet.official});return{availablePools:a,best:d,routedPools:m}}async getBestAmountOut({pools:t,amountIn:e,inputToken:o,outputToken:r,slippage:i,features:a}){if(this.checkDisabled(),!t){let{routedPools:_}=await this.getAvailablePools({inputMint:o.mint,outputMint:r.mint});t=_}let u=await this.scope.liquidity.sdkParseJsonLiquidityInfo(t||[]),c=(t||[]).map((_,A)=>({poolKeys:me(_),poolInfo:u[A]})),m=a||Kr;this.logDebug("features:",m),c.length||this.logAndCreateError("please provide at least one source of trade or (inputMint & outputMint)",c);let d=[],p="amm",y=new O(o,e),f=new O(r,0),b=f,h=null,S=null,g=new oe(ae),T=[];if(m.includes("amm"))for(let{poolKeys:_,poolInfo:A}of c)try{let{amountOut:q,minAmountOut:F,currentPrice:N,executionPrice:J,priceImpact:D,fee:U}=this.scope.liquidity.computeAmountOut({poolKeys:_,poolInfo:A,amountIn:y,outputToken:r,slippage:i});q.gt(f)&&(console.log("amm",A),d=[{source:"amm",keys:_}],p="amm",f=q,b=F,h=N,S=J,g=D,T=[U])}catch{}if(m.includes("route")){let _=Wr(c);for(let A of _){if(A.length!==2)continue;let[q,F]=A,{poolKeys:N,poolInfo:J}=q,{poolKeys:D,poolInfo:U}=F;try{let{amountOut:X,minAmountOut:$,executionPrice:ne,priceImpact:ie,fee:Ae}=this.scope.route.computeRouteAmountOut({fromPoolKeys:N,toPoolKeys:D,fromPoolInfo:J,toPoolInfo:U,amountIn:y,outputToken:r,slippage:i});X.gt(f)&&(d=[{source:"amm",keys:N},{source:"amm",keys:D}],p="route",f=X,b=$,S=ne,g=ie,T=Ae)}catch{}}}return{routes:d,routeType:p,amountOut:f,minAmountOut:b,fixedSide:"in",currentPrice:h,executionPrice:S,priceImpact:g,fee:T}}async directSwap(t){this.checkDisabled();let{amountOut:e,amountIn:o,slippage:r,config:i}=t,a=o.token,u=e.token,{routes:c,routeType:m,minAmountOut:d}=await this.getBestAmountOut({inputToken:a,outputToken:u,amountIn:o.raw,slippage:r});return await this.swap({routes:c,routeType:m,amountIn:o,amountOut:d,fixedSide:"in",config:i})}async swap(t){this.checkDisabled(),this.scope.checkOwner();let{routes:e,routeType:o,amountIn:r,amountOut:i,fixedSide:a,config:u}=t;if(o==="amm"&&e.length===1)return await this.scope.liquidity.swapWithAMM({poolKeys:e[0].keys,amountIn:r,amountOut:i,fixedSide:a,config:u});if(o==="route"&&e.length===2)return await this.scope.route.swapWithRoute({fromPoolKeys:e[0].keys,toPoolKeys:e[1].keys,amountIn:r,amountOut:i,fixedSide:a,config:u});throw this.logAndCreateError("invalid routes with routeType","routes",{routeType:o,routes:e}),new Error("invalid routes with routeType")}async getWSolAccounts(){this.scope.checkOwner(),await this.scope.account.fetchWalletTokenAccounts();let t=this.scope.account.tokenAccounts.filter(e=>e.mint.equals(xe));return t.sort((e,o)=>e.isAssociated?1:o.isAssociated||e.amount.lt(o.amount)?-1:1),t}async unWrapWSol(t){let e=await this.getWSolAccounts(),o=this.createTxBuilder(),r=await Le({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:0});o.addInstruction(r);let i=x(t);for(let a=0;a<e.length;a++)i.gte(e[a].amount)?(o.addInstruction({instructions:[qe({tokenAccount:e[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),i.sub(e[a].amount)):(o.addInstruction({instructions:[qe({tokenAccount:e[a].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),Ee({destination:r.signers[0].publicKey,source:e[a].publicKey,amount:i,owner:this.scope.ownerPubKey}));return o.build()}async wrapWSol(t){let e=await this.getWSolAccounts(),o=this.createTxBuilder(),r=await Le({connection:this.scope.connection,owner:this.scope.ownerPubKey,payer:this.scope.ownerPubKey,amount:t,skipCloseAccount:!0});return o.addInstruction(r),e.length&&o.addInstruction({instructions:[Ee({destination:e[0].publicKey,source:r.signers[0].publicKey,amount:t,owner:this.scope.ownerPubKey})],endInstructions:[qe({tokenAccount:r.signers[0].publicKey,payer:this.scope.ownerPubKey,owner:this.scope.ownerPubKey})]}),o.build()}};var Re={},Et=class{constructor(t){this.rawBalances=new Map;let{connection:e,cluster:o,owner:r,api:i,defaultApiTokens:a,defaultApiLiquidityPools:u,defaultApiFarmPools:c,defaultApiPairsInfo:m,apiCacheTime:d}=t;this._connection=e,this.cluster=o,this._owner=r?new le(r):void 0,this._signAllTransactions=t.signAllTransactions,this.api=i,this._apiCacheTime=d||5*60*1e3,this.logger=M("Raydium"),this.farm=new it({scope:this,moduleName:"Raydium_Farm"}),this.account=new Ze({scope:this,moduleName:"Raydium_Account",tokenAccounts:t.tokenAccounts,tokenAccountRawInfos:t.tokenAccountRawInfos}),this.liquidity=new st({scope:this,moduleName:"Raydium_Liquidity"}),this.token=new mt({scope:this,moduleName:"Raydium_token"}),this.trade=new lt({scope:this,moduleName:"Raydium_trade"}),this.route=new ct({scope:this,moduleName:"Raydium_route"});let p=new Date().getTime(),[y,f,b,h]=[a?{fetched:p,data:a}:Re.tokens,u?{fetched:p,data:u}:Re.liquidityPools,c?{fetched:p,data:c}:Re.farmPools,m?{fetched:p,data:m}:Re.liquidityPairsInfo];this.apiData=L(L(L(L({},y?{tokens:y}:{}),f?{liquidityPools:f}:{}),b?{farmPools:b}:{}),h?{liquidityPairsInfo:h}:{})}static async load(t){let e=Ha({cluster:"mainnet",owner:null,apiRequestInterval:3e5,apiRequestTimeout:1e4},t),{cluster:o,apiRequestTimeout:r}=e,i=new _t({cluster:o,timeout:r}),a=new Et(K(L({},e),{api:i}));return await a.token.load(),await a.liquidity.load(),a}get owner(){return this._owner}get ownerPubKey(){if(!this._owner)throw new Error(Rt);return this._owner.publicKey}setOwner(t){return this._owner=t?new le(t):void 0,this}get connection(){if(!this._connection)throw new Error(wo);return this._connection}setConnection(t){return this._connection=t,this}get signAllTransactions(){return this._signAllTransactions}setSignAllTransactions(t){return this._signAllTransactions=t,this}checkOwner(){if(!this.owner)throw this.logger.error(Rt),new Error(Rt)}isCacheInvalidate(t){return new Date().getTime()-t>this._apiCacheTime}async fetchTokens(t){if(this.apiData.tokens&&!this.isCacheInvalidate(this.apiData.tokens.fetched)&&!t)return this.apiData.tokens.data;let e={fetched:Date.now(),data:await this.api.getTokens()};return this.apiData.tokens=e,Re.tokens=e,e.data}async fetchLiquidity(t){if(this.apiData.liquidityPools&&!this.isCacheInvalidate(this.apiData.liquidityPools.fetched)&&!t)return this.apiData.liquidityPools.data;let e={fetched:Date.now(),data:await this.api.getLiquidityPools()};return this.apiData.liquidityPools=e,Re.liquidityPools=e,e.data}async fetchPairs(t){var o;if(this.apiData.liquidityPairsInfo&&!this.isCacheInvalidate(this.apiData.liquidityPairsInfo.fetched)&&!t)return((o=this.apiData.liquidityPairsInfo)==null?void 0:o.data)||[];let e={fetched:Date.now(),data:await this.api.getPairsInfo()};return this.apiData.liquidityPairsInfo=e,Re.liquidityPairsInfo=e,e.data}async fetchFarms(t){if(this.apiData.farmPools&&!this.isCacheInvalidate(this.apiData.farmPools.fetched)&&!t)return this.apiData.farmPools.data;let e={fetched:Date.now(),data:await this.api.getFarmPools()};return this.apiData.farmPools=e,Re.farmPools=e,e.data}async chainTimeOffset(){let t=await this.connection.getBlockTime(await this.connection.getSlot());return t?(t*1e3,Number((t*1e3-Date.now()).toFixed(0))):0}mintToToken(t){return this.token.mintToToken(t)}mintToTokenAmount(t){return this.token.mintToTokenAmount(t)}decimalAmount(t){return this.token.decimalAmount(t)}uiAmount(t){return this.token.uiAmount(t)}};var uy=n=>n;export{Ta as DataElement,Do as FARM_LOCK_MINT,Eo as FARM_LOCK_VAULT,No as FARM_PROGRAMID_TO_VERSION,Oo as FARM_PROGRAM_ID_V3,ta as FARM_PROGRAM_ID_V3_PUBKEY,qo as FARM_PROGRAM_ID_V5,na as FARM_PROGRAM_ID_V5_PUBKEY,Fo as FARM_PROGRAM_ID_V6,oa as FARM_PROGRAM_ID_V6_PUBKEY,Co as FARM_VERSION_TO_LEDGER_LAYOUT,vo as FARM_VERSION_TO_PROGRAMID,Vo as FARM_VERSION_TO_STATE_LAYOUT,ar as LIQUIDITY_FEES_DENOMINATOR,ir as LIQUIDITY_FEES_NUMERATOR,td as LIQUIDITY_PROGRAMID_TO_VERSION,Pa as LIQUIDITY_PROGRAM_ID_V4,wa as LIQUIDITY_PROGRAM_ID_V5,cr as LIQUIDITY_VERSION_TO_PROGRAM_ID,mr as LIQUIDITY_VERSION_TO_SERUM_VERSION,lr as LIQUIDITY_VERSION_TO_STATE_LAYOUT,rr as LiquidityPoolStatus,he as MODEL_DATA_PUBKEY,ut as ROUTE_PROGRAM_ID_V1,Et as Raydium,Ad as SERUM_PROGRAMID_TO_VERSION,Na as SERUM_PROGRAM_ID_V3,va as SERUM_VERSION_TO_PROGRAM_ID,Sn as SPL_MINT_LAYOUT,Ot as StableLayout,Hn as TOKEN_SOL,j as TOKEN_WSOL,sr as _LIQUIDITY_PROGRAM_ID_V4,ur as _LIQUIDITY_PROGRAM_ID_V5,Ga as _ROUTE_PROGRAM_ID_V1,Ir as _SERUM_PROGRAM_ID_V3,Pn as addLiquidityLayout,on as associatedLedgerAccountLayout,ln as calFarmRewardAmount,er as calculateFarmPoolAprList,qe as closeAccountInstruction,$o as createAssociatedLedgerAccountInstruction,yn as createPoolV4Layout,Le as createWSolAccountInstructions,Kr as defaultRoutes,et as dwLayout,un as farmAddRewardLayout,Wo as farmDespotVersionToInstruction,$m as farmLedgerLayoutV3_1,Ro as farmLedgerLayoutV3_2,jm as farmLedgerLayoutV5_1,Mo as farmLedgerLayoutV5_2,Bo as farmLedgerLayoutV6_1,Ho as farmRewardInfoToConfig,an as farmRewardLayout,sn as farmRewardRestartLayout,ea as farmRewardTimeInfoLayout,Lo as farmStateV3Layout,_o as farmStateV5Layout,Xe as farmStateV6Layout,Uo as farmWithdrawVersionToInstruction,fa as fetchMultipleFarmInfoAndUpdate,pn as fixedSwapInLayout,fn as fixedSwapOutLayout,Ka as formatLayout,An as getAmountSide,Mr as getAmountsSide,Yo as getAssociatedAuthority,mn as getAssociatedLedgerAccount,Kt as getAssociatedLedgerPoolAccount,vr as getAssociatedMiddleStatusAccount,xn as getAssociatedPoolKeys,yr as getDxByDyBaseIn,fr as getDyByDxBaseIn,la as getFarmLedgerLayout,Qo as getFarmProgramId,da as getFarmStateLayout,ma as getFarmVersion,Va as getLiquidityAssociatedAuthority,_e as getLiquidityAssociatedId,Dd as getLiquidityInfo,Ea as getLiquidityProgramId,vd as getLiquidityStateLayout,In as getPoolEnabledFeatures,Fp as getSPLTokenInfo,Lr as getSerumAssociatedAuthority,Sr as getSerumProgramId,xr as getSerumVersion,br as getStablePrice,_r as getTokenSide,Ca as getTokensSide,Wr as groupPools,Ve as includesToken,bn as initPoolLayout,Gi as initTokenAccountInstruction,cn as isValidFarmVersion,Br as isValidFixedSide,Zo as judgeFarmType,gn as liquidityStateV4Layout,ha as liquidityStateV5Layout,gr as makeAMMSwapInstruction,kr as makeAddLiquidityInstruction,jo as makeCreateFarmInstruction,wr as makeCreatePoolInstruction,hr as makeInitPoolInstruction,Tr as makeRemoveLiquidityInstruction,Nr as makeRouteSwapInstruction,Pr as makeSimulatePoolInfoInstruction,Rr as makeSimulationPoolInfo,qa as makeSwapFixedInInstruction,Fa as makeSwapFixedOutInstruction,$a as makeSwapInFixedInInstruction,ja as makeSwapOutFixedInInstruction,Ee as makeTransferInstruction,zo as mergeSdkFarmInfo,Aa as modelDataInfoLayout,Io as parseTokenAccountResp,Bt as poolTypeV6,Qe as quantumSOLHydratedTokenJsonInfo,zi as realFarmStateV3Layout,Zi as realFarmStateV5Layout,Xi as realFarmV6Layout,wn as removeLiquidityLayout,Nt as routeSwapInLayout,vt as routeSwapOutLayout,Vr as sortTokens,we as splAccountLayout,Or as swapRouteMiddleMints,uy as unionArr,pa as updateFarmPoolInfo,Go as validateFarmRewards,Xo as whetherIsStakeFarmPool,rn as withdrawRewardLayout};
//# sourceMappingURL=index.mjs.map