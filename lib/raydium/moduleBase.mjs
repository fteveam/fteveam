import{get as w,set as A}from"lodash";import R from"pino";import v from"pino-pretty";var x={},B={},L=v({colorize:!0,levelFirst:!0,translateTime:"SYS:yyyymmdd HH:MM:ss.l"}),k=R({base:null,level:"silent"},L);function h(e){let t=w(x,e);if(!t){let n=w(B,e);t=k.child({name:e},{level:n}),A(x,e,t)}return t.logWithError=(...n)=>{let r=n.map(i=>typeof i=="object"?JSON.stringify(i):i).join(", ");throw new Error(r)},t}import{PACKET_DATA_SIZE as z,PublicKey as H,sendAndConfirmTransaction as I,Transaction as E}from"@solana/web3.js";var V=h("Raydium_txTool"),d=class{constructor(t){this.instructions=[];this.endInstructions=[];this.signers=[];this.connection=t.connection,this.feePayer=t.feePayer,this.signAllTransactions=t.signAllTransactions,this.owner=t.owner}get AllTxData(){return{instructions:this.instructions,endInstructions:this.endInstructions,signers:this.signers}}get allInstructions(){return[...this.instructions,...this.endInstructions]}addInstruction({instructions:t=[],endInstructions:n=[],signers:r=[]}){return this.instructions.push(...t),this.endInstructions.push(...n),this.signers.push(...r),this}build(t){let n=new E;return this.allInstructions.length&&n.add(...this.allInstructions),n.feePayer=this.feePayer,{transaction:n,signers:this.signers,execute:async()=>{var i;let r=await S(this.connection);if(n.recentBlockhash=r,(i=this.owner)!=null&&i.isKeyPair)return I(this.connection,n,this.signers);if(this.signAllTransactions){this.signers.length&&n.partialSign(...this.signers);let a=await this.signAllTransactions([n]);return await this.connection.sendRawTransaction(a[0].serialize(),{skipPreflight:!0})}throw new Error("please connect wallet first")},extInfo:t||{}}}buildMultiTx(t){let{extraPreBuildData:n=[],extInfo:r}=t,{transaction:i}=this.build(r),a=n.filter(s=>s.transaction.instructions.length>0),f=[...a.map(s=>s.transaction),i],c=[...a.map(s=>s.signers),this.signers];return{transactions:f,signers:c,execute:async()=>{var y;let s=await S(this.connection);if((y=this.owner)!=null&&y.isKeyPair)return await Promise.all(f.map(async(l,g)=>(l.recentBlockhash=s,await I(this.connection,l,c[g]))));if(this.signAllTransactions){let l=f.map((o,u)=>(o.recentBlockhash=s,c[u].length&&o.partialSign(...c[u]),o)),g=await this.signAllTransactions(l),T=[];for(let o=0;o<g.length;o+=1){let u=await this.connection.sendRawTransaction(g[o].serialize(),{skipPreflight:!0});T.push(u)}return T}throw new Error("please connect wallet first")},extInfo:r||{}}}};async function S(e){var t,n;try{return((n=await((t=e.getLatestBlockhash)==null?void 0:t.call(e)))==null?void 0:n.blockhash)||(await e.getRecentBlockhash()).blockhash}catch{return(await e.getRecentBlockhash()).blockhash}}var p=(...e)=>e.map(t=>{try{return typeof t=="object"?JSON.stringify(t):t}catch{return t}}).join(", "),m=class{constructor({scope:t,moduleName:n}){this.disabled=!1;this.scope=t,this.logger=h(n)}createTxBuilder(t){return this.scope.checkOwner(),new d({connection:this.scope.connection,feePayer:t||this.scope.ownerPubKey,owner:this.scope.owner,signAllTransactions:this.scope.signAllTransactions})}logDebug(...t){this.logger.debug(p(t))}logInfo(...t){this.logger.info(p(t))}logAndCreateError(...t){let n=p(t);throw new Error(n)}checkDisabled(){(this.disabled||!this.scope)&&this.logAndCreateError("module not working")}};export{m as default};
//# sourceMappingURL=moduleBase.mjs.map