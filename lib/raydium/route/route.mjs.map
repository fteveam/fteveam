{"version":3,"sources":["../../../src/raydium/route/route.ts","../../../src/common/bignumber.ts","../../../src/module/amount.ts","../../../src/common/logger.ts","../../../src/module/formatter.ts","../../../src/module/fraction.ts","../../../src/raydium/token/constant.ts","../../../src/module/token.ts","../../../src/common/pubKey.ts","../../../src/module/currency.ts","../../../src/module/percent.ts","../../../src/module/price.ts","../../../src/raydium/liquidity/util.ts","../../../src/common/txTool.ts","../../../src/raydium/liquidity/constant.ts","../../../src/raydium/liquidity/instruction.ts","../../../src/marshmallow/index.ts","../../../src/marshmallow/buffer-layout.ts","../../../src/raydium/liquidity/layout.ts","../../../src/raydium/liquidity/stable.ts","../../../src/raydium/liquidity/serum.ts","../../../src/raydium/moduleBase.ts","../../../src/raydium/route/constant.ts","../../../src/raydium/route/instruction.ts","../../../src/raydium/route/layout.ts","../../../src/raydium/route/util.ts"],"sourcesContent":["import { PublicKey } from \"@solana/web3.js\";\nimport { intersection, xor } from \"lodash\";\n\nimport { Price } from \"../../module/price\";\nimport { Token } from \"../../module/token\";\nimport { getPoolEnabledFeatures, includesToken } from \"../liquidity/util\";\nimport ModuleBase, { ModuleBaseProps } from \"../moduleBase\";\nimport { SwapExtInfo } from \"../trade/type\";\nimport { MakeMultiTransaction } from \"../type\";\n\nimport { ROUTE_PROGRAM_ID_V1 } from \"./constant\";\nimport { makeRouteSwapInstruction } from \"./instruction\";\nimport { RouteComputeAmountOutData, RouteComputeAmountOutParams, RouteSwapTransactionParams } from \"./type\";\nimport { getAssociatedMiddleStatusAccount } from \"./util\";\n\nexport default class Route extends ModuleBase {\n  constructor(params: ModuleBaseProps) {\n    super(params);\n  }\n\n  public computeRouteAmountOut({\n    fromPoolKeys,\n    toPoolKeys,\n    fromPoolInfo,\n    toPoolInfo,\n    amountIn,\n    outputToken,\n    slippage,\n  }: RouteComputeAmountOutParams): RouteComputeAmountOutData {\n    const { swap: fromPoolSwapEnabled } = getPoolEnabledFeatures(fromPoolInfo);\n    const { swap: toPoolSwapEnabled } = getPoolEnabledFeatures(toPoolInfo);\n    if (!fromPoolSwapEnabled || !toPoolSwapEnabled)\n      this.logAndCreateError(\"pools swap not enabled\", \"pools\", {\n        fromPoolKeys,\n        toPoolKeys,\n        fromPoolInfo,\n        toPoolInfo,\n      });\n\n    const tokenIn = amountIn.token;\n    const tokenOut = outputToken;\n\n    if (!includesToken(tokenIn, fromPoolKeys) || !includesToken(tokenOut, toPoolKeys))\n      this.logAndCreateError(\"pools cannot be routed\", \"pools\", {\n        fromPoolKeys,\n        toPoolKeys,\n      });\n\n    const fromPoolMints = [fromPoolKeys.baseMint.toBase58(), fromPoolKeys.quoteMint.toBase58()];\n    const toPoolMints = [toPoolKeys.baseMint.toBase58(), toPoolKeys.quoteMint.toBase58()];\n    const mints = [...fromPoolMints, ...toPoolMints];\n    const decimals = [\n      fromPoolInfo.baseDecimals,\n      fromPoolInfo.quoteDecimals,\n      toPoolInfo.baseDecimals,\n      toPoolInfo.quoteDecimals,\n    ];\n    const [mintIn, mintOut] = [tokenIn.mint.toBase58(), tokenOut.mint.toBase58()];\n\n    const xorMints = xor(fromPoolMints, toPoolMints);\n    if (xorMints.length !== 2 || !xorMints.includes(mintIn) || !xorMints.includes(mintOut))\n      this.logAndCreateError(\"xor tokens not match\", \"pools\", {\n        fromPoolKeys,\n        toPoolKeys,\n      });\n\n    const intersectionMints = intersection(fromPoolMints, toPoolMints);\n    if (intersectionMints.length !== 1)\n      this.logAndCreateError(\"cannot found middle token of two pools\", \"pools\", {\n        fromPoolKeys,\n        toPoolKeys,\n      });\n\n    const _middleMint = intersectionMints[0];\n    const index = mints.indexOf(_middleMint);\n    if (index === -1)\n      this.logAndCreateError(\"cannot found middle token\", \"pools\", {\n        fromPoolKeys,\n        toPoolKeys,\n      });\n\n    const middleMintDecimals = decimals[index];\n    const middleMint = new PublicKey(_middleMint);\n    const middleToken = new Token({ mint: middleMint, decimals: middleMintDecimals });\n\n    this.logInfo(`from pool:`, fromPoolKeys);\n    this.logInfo(\"to pool:\", toPoolKeys);\n    this.logInfo(\"intersection mints:\", intersectionMints);\n    this.logInfo(\"xor mints:\", xorMints);\n    this.logInfo(\"middleMint:\", _middleMint);\n\n    const {\n      minAmountOut: minMiddleAmountOut,\n      priceImpact: firstPriceImpact,\n      fee: firstFee,\n    } = this.scope.liquidity.computeAmountOut({\n      poolKeys: fromPoolKeys,\n      poolInfo: fromPoolInfo,\n      amountIn,\n      outputToken: middleToken,\n      slippage,\n    });\n    const {\n      amountOut,\n      minAmountOut,\n      priceImpact: secondPriceImpact,\n      fee: secondFee,\n    } = this.scope.liquidity.computeAmountOut({\n      poolKeys: toPoolKeys,\n      poolInfo: toPoolInfo,\n      amountIn: minMiddleAmountOut,\n      outputToken,\n      slippage,\n    });\n\n    let executionPrice: Price | null = null;\n    const [amountInRaw, amountOutRaw] = [amountIn.raw, amountOut.raw];\n    if (!amountInRaw.isZero() && !amountOutRaw.isZero()) {\n      executionPrice = new Price({\n        baseToken: tokenIn,\n        denominator: amountInRaw,\n        quoteToken: outputToken,\n        numerator: amountOutRaw,\n      });\n      this.logDebug(\"executionPrice:\", `1 ${tokenIn.symbol} ≈ ${executionPrice.toFixed()} ${outputToken.symbol}`);\n      this.logDebug(\n        \"executionPrice invert:\",\n        `1 ${outputToken.symbol} ≈ ${executionPrice.invert().toFixed()} ${tokenIn.symbol}`,\n      );\n    }\n\n    return {\n      amountOut,\n      minAmountOut,\n      executionPrice,\n      priceImpact: firstPriceImpact.add(secondPriceImpact),\n      fee: [firstFee, secondFee],\n    };\n  }\n\n  public async swapWithRoute(params: RouteSwapTransactionParams): Promise<MakeMultiTransaction & SwapExtInfo> {\n    const { fromPoolKeys, toPoolKeys, amountIn, amountOut, fixedSide, config } = params;\n    this.logDebug(\"amountIn:\", amountIn, \"amountOut:\", amountOut);\n    if (amountIn.isZero() || amountOut.isZero())\n      this.logAndCreateError(\"amounts must greater than zero\", \"amounts\", {\n        amountIn: amountIn.toFixed(),\n        amountOut: amountOut.toFixed(),\n      });\n    const { account } = this.scope;\n    const { bypassAssociatedCheck = false } = config || {};\n    const [tokenIn, tokenOut] = [amountIn.token, amountOut.token];\n\n    const tokenAccountIn = await this.scope.account.getCreatedTokenAccount({\n      mint: tokenIn.mint,\n      associatedOnly: false,\n    });\n    const tokenAccountOut = await this.scope.account.getCreatedTokenAccount({\n      mint: tokenOut.mint,\n    });\n\n    const fromPoolMints = [fromPoolKeys.baseMint.toBase58(), fromPoolKeys.quoteMint.toBase58()];\n    const toPoolMints = [toPoolKeys.baseMint.toBase58(), toPoolKeys.quoteMint.toBase58()];\n    const intersectionMints = intersection(fromPoolMints, toPoolMints);\n    const _middleMint = intersectionMints[0];\n    const middleMint = new PublicKey(_middleMint);\n    const tokenAccountMiddle = await this.scope.account.getCreatedTokenAccount({\n      mint: middleMint,\n    });\n\n    const [amountInRaw, amountOutRaw] = [amountIn.raw, amountOut.raw];\n\n    const preTxBuilder = this.createTxBuilder();\n    const txBuilder = this.createTxBuilder();\n    const { tokenAccount: _tokenAccountIn, ...accountInInstruction } = await account.handleTokenAccount({\n      side: \"in\",\n      amount: amountInRaw,\n      mint: tokenIn.mint,\n      tokenAccount: tokenAccountIn,\n      bypassAssociatedCheck,\n      skipCloseAccount: true,\n    });\n    preTxBuilder.addInstruction(accountInInstruction);\n    const { tokenAccount: _tokenAccountOut, ...accountOutInstruction } = await account.handleTokenAccount({\n      side: \"out\",\n      amount: 0,\n      mint: tokenOut.mint,\n      tokenAccount: tokenAccountOut,\n      bypassAssociatedCheck,\n      skipCloseAccount: true,\n    });\n    preTxBuilder.addInstruction(accountOutInstruction);\n    const { tokenAccount: _tokenAccountMiddle, ...accountMiddleInstruction } = await account.handleTokenAccount({\n      side: \"in\",\n      amount: 0,\n      mint: middleMint,\n      tokenAccount: tokenAccountMiddle,\n      bypassAssociatedCheck,\n      skipCloseAccount: true,\n    });\n    preTxBuilder.addInstruction(accountMiddleInstruction);\n    txBuilder.addInstruction({\n      instructions: makeRouteSwapInstruction({\n        fromPoolKeys,\n        toPoolKeys,\n        userKeys: {\n          inTokenAccount: _tokenAccountIn,\n          outTokenAccount: _tokenAccountOut,\n          middleTokenAccount: _tokenAccountMiddle,\n          middleStatusAccount: await getAssociatedMiddleStatusAccount({\n            programId: ROUTE_PROGRAM_ID_V1,\n            fromPoolId: fromPoolKeys.id,\n            middleMint,\n            owner: this.scope.ownerPubKey,\n          }),\n          owner: this.scope.ownerPubKey,\n        },\n        amountIn: amountInRaw,\n        amountOut: amountOutRaw,\n        fixedSide,\n      }),\n    });\n    const preBuildData = preTxBuilder.build();\n    const buildData = (await txBuilder.buildMultiTx({\n      extraPreBuildData: [preBuildData],\n      extInfo: { amountOut: amountOutRaw },\n    })) as MakeMultiTransaction & SwapExtInfo;\n    return buildData;\n  }\n}\n","import BN from \"bn.js\";\n\nimport { Fraction, Percent, Price, TokenAmount, Token } from \"../module\";\nimport { SplToken, TokenJson } from \"../raydium/token/type\";\nimport { createLogger } from \"./logger\";\n\nconst logger = createLogger(\"Raydium_bignumber\");\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP,\n}\n\nexport const BN_ZERO = new BN(0);\nexport const BN_ONE = new BN(1);\nexport const BN_TWO = new BN(2);\nexport const BN_THREE = new BN(3);\nexport const BN_FIVE = new BN(5);\nexport const BN_TEN = new BN(10);\nexport const BN_100 = new BN(100);\nexport const BN_1000 = new BN(1000);\nexport const BN_10000 = new BN(10000);\nexport type BigNumberish = BN | string | number | bigint;\nexport type Numberish = number | string | bigint | Fraction | BN;\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\nexport function parseBigNumberish(value: BigNumberish): BN {\n  // BN\n  if (value instanceof BN) {\n    return value;\n  }\n\n  if (typeof value === \"string\") {\n    if (value.match(/^-?[0-9]+$/)) {\n      return new BN(value);\n    }\n    logger.logWithError(`invalid BigNumberish string: ${value}`);\n  }\n\n  if (typeof value === \"number\") {\n    if (value % 1) {\n      logger.logWithError(`BigNumberish number underflow: ${value}`);\n    }\n\n    if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n      logger.logWithError(`BigNumberish number overflow: ${value}`);\n    }\n\n    return new BN(String(value));\n  }\n\n  if (typeof value === \"bigint\") {\n    return new BN(value.toString());\n  }\n  logger.logWithError(`invalid BigNumberish value: ${value}`);\n  return new BN(0); // never reach, because logWithError will throw error\n}\n\nexport function tenExponential(shift: BigNumberish): BN {\n  return BN_TEN.pow(parseBigNumberish(shift));\n}\n\n/**\n *\n * @example\n * getIntInfo(0.34) //=> { numerator: '34', denominator: '100'}\n * getIntInfo('0.34') //=> { numerator: '34', denominator: '100'}\n */\nexport function parseNumberInfo(n: Numberish | undefined): {\n  denominator: string;\n  numerator: string;\n  sign?: string;\n  int?: string;\n  dec?: string;\n} {\n  if (n === undefined) return { denominator: \"1\", numerator: \"0\" };\n  if (n instanceof BN) {\n    return { numerator: n.toString(), denominator: \"1\" };\n  }\n\n  if (n instanceof Fraction) {\n    return { denominator: n.denominator.toString(), numerator: n.numerator.toString() };\n  }\n\n  const s = String(n);\n  const [, sign = \"\", int = \"\", dec = \"\"] = s.replace(\",\", \"\").match(/(-?)(\\d*)\\.?(\\d*)/) ?? [];\n  const denominator = \"1\" + \"0\".repeat(dec.length);\n  const numerator = sign + (int === \"0\" ? \"\" : int) + dec || \"0\";\n  return { denominator, numerator, sign, int, dec };\n}\n\n// round up\nexport function divCeil(a: BN, b: BN): BN {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const dm = a.divmod(b);\n\n  // Fast case - exact division\n  if (dm.mod.isZero()) return dm.div;\n\n  // Round up\n  return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n}\n\nexport function shakeFractionDecimal(n: Fraction): string {\n  const [, sign = \"\", int = \"\"] = n.toFixed(2).match(/(-?)(\\d*)\\.?(\\d*)/) ?? [];\n  return `${sign}${int}`;\n}\n\nexport function toBN(n: Numberish, decimal: BigNumberish = 0): BN {\n  if (n instanceof BN) return n;\n  return new BN(shakeFractionDecimal(toFraction(n).mul(BN_TEN.pow(new BN(String(decimal))))));\n}\n\nexport function toFraction(value: Numberish): Fraction {\n  //  to complete math format(may have decimal), not int\n  if (value instanceof Percent) return new Fraction(value.numerator, value.denominator);\n\n  if (value instanceof Price) return value.adjusted;\n\n  // to complete math format(may have decimal), not BN\n  if (value instanceof TokenAmount)\n    try {\n      return toFraction(value.toExact());\n    } catch {\n      return new Fraction(BN_ZERO);\n    }\n\n  // do not ideal with other fraction value\n  if (value instanceof Fraction) return value;\n\n  // wrap to Fraction\n  const n = String(value);\n  const details = parseNumberInfo(n);\n  return new Fraction(details.numerator, details.denominator);\n}\n\n/**\n * @example\n * toPercent(3.14) // => Percent { 314.00% }\n * toPercent(3.14, { alreadyDecimaled: true }) // => Percent {3.14%}\n */\nexport function toPercent(\n  n: Numberish,\n  options?: { /* usually used for backend data */ alreadyDecimaled?: boolean },\n): Percent {\n  const { numerator, denominator } = parseNumberInfo(n);\n  return new Percent(new BN(numerator), new BN(denominator).mul(options?.alreadyDecimaled ? new BN(100) : new BN(1)));\n}\n\nexport function toTokenPrice(params: {\n  token: TokenJson | Token | SplToken;\n  numberPrice: Numberish;\n  decimalDone?: boolean;\n}): Price {\n  const { token, numberPrice, decimalDone } = params;\n  const usdCurrency = new Token({ mint: \"\", decimals: 6, symbol: \"usd\", name: \"usd\", skipMint: true });\n  const { numerator, denominator } = parseNumberInfo(numberPrice);\n  const parsedNumerator = decimalDone ? new BN(numerator).mul(BN_TEN.pow(new BN(token.decimals))) : numerator;\n  const parsedDenominator = new BN(denominator).mul(BN_TEN.pow(new BN(usdCurrency.decimals)));\n\n  return new Price({\n    baseToken: usdCurrency,\n    denominator: parsedDenominator.toString(),\n    quoteToken: new Token({ ...token, skipMint: true, mint: \"\" }),\n    numerator: parsedNumerator.toString(),\n  });\n}\n\nexport function mul(a: Numberish | undefined, b: Numberish | undefined): Fraction | undefined {\n  if (a == null || b == null) return undefined;\n  const fa = toFraction(a);\n  const fb = toFraction(b);\n  return fa.mul(fb);\n}\n\nexport function toUsdCurrency(amount: Numberish): TokenAmount {\n  const usdCurrency = new Token({ mint: \"\", decimals: 6, symbol: \"usd\", name: \"usd\", skipMint: true });\n  const amountBigNumber = toBN(mul(amount, 10 ** usdCurrency.decimals)!);\n  return new TokenAmount(usdCurrency, amountBigNumber);\n}\n\nexport function toTotalPrice(amount: Numberish | undefined, price: Price | undefined): TokenAmount {\n  if (!price || !amount) return toUsdCurrency(0);\n  return toUsdCurrency(mul(amount, price)!);\n}\n","import _Big from \"big.js\";\nimport BN from \"bn.js\";\n\nimport { BigNumberish, BN_TEN, parseBigNumberish, Rounding } from \"../common/bignumber\";\nimport { createLogger, Logger } from \"../common/logger\";\n\nimport toFormat, { WrappedBig } from \"./formatter\";\nimport { Fraction } from \"./fraction\";\nimport { Token } from \"./token\";\n\nconst logger = createLogger(\"Raydium_amount\");\n\nconst Big = toFormat(_Big);\ntype Big = WrappedBig;\n\nexport function splitNumber(num: string, decimals: number): [string, string] {\n  let integral = \"0\";\n  let fractional = \"0\";\n\n  if (num.includes(\".\")) {\n    const splited = num.split(\".\");\n    if (splited.length === 2) {\n      [integral, fractional] = splited;\n      fractional = fractional.padEnd(decimals, \"0\");\n    } else {\n      logger.logWithError(`invalid number string, num: ${num}`);\n    }\n  } else {\n    integral = num;\n  }\n\n  // fix decimals is 0\n  return [integral, fractional.slice(0, decimals) || fractional];\n}\n\nexport class TokenAmount extends Fraction {\n  public readonly token: Token;\n  protected logger: Logger;\n\n  public constructor(token: Token, amount: BigNumberish, isRaw = true, name?: string) {\n    let parsedAmount = new BN(0);\n    const multiplier = BN_TEN.pow(new BN(token.decimals));\n\n    if (isRaw) {\n      parsedAmount = parseBigNumberish(amount);\n    } else {\n      let integralAmount = new BN(0);\n      let fractionalAmount = new BN(0);\n\n      // parse fractional string\n      if (typeof amount === \"string\" || typeof amount === \"number\" || typeof amount === \"bigint\") {\n        const [integral, fractional] = splitNumber(amount.toString(), token.decimals);\n        integralAmount = parseBigNumberish(integral);\n        fractionalAmount = parseBigNumberish(fractional);\n      }\n\n      integralAmount = integralAmount.mul(multiplier);\n      parsedAmount = integralAmount.add(fractionalAmount);\n    }\n\n    super(parsedAmount, multiplier);\n    this.logger = createLogger(name || \"Amount\");\n    this.token = token;\n  }\n\n  public get raw(): BN {\n    return this.numerator;\n  }\n  public isZero(): boolean {\n    return this.raw.isZero();\n  }\n  public gt(other: TokenAmount): boolean {\n    if (!this.token.equals(other.token)) this.logger.logWithError(\"gt token not equals\");\n    return this.raw.gt(other.raw);\n  }\n\n  /**\n   * a less than b\n   */\n  public lt(other: TokenAmount): boolean {\n    if (!this.token.equals(other.token)) this.logger.logWithError(\"lt token not equals\");\n    return this.raw.lt(other.raw);\n  }\n\n  public add(other: TokenAmount): TokenAmount {\n    if (!this.token.equals(other.token)) this.logger.logWithError(\"add token not equals\");\n    return new TokenAmount(this.token, this.raw.add(other.raw));\n  }\n\n  public subtract(other: TokenAmount): TokenAmount {\n    if (!this.token.equals(other.token)) this.logger.logWithError(\"sub token not equals\");\n    return new TokenAmount(this.token, this.raw.sub(other.raw));\n  }\n\n  public toSignificant(\n    significantDigits = this.token.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN,\n  ): string {\n    return super.toSignificant(significantDigits, format, rounding);\n  }\n\n  /**\n   * To fixed\n   *\n   * @example\n   * ```\n   * 1 -> 1.000000000\n   * 1.234 -> 1.234000000\n   * 1.123456789876543 -> 1.123456789\n   * ```\n   */\n  public toFixed(\n    decimalPlaces = this.token.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN,\n  ): string {\n    if (decimalPlaces > this.token.decimals) this.logger.logWithError(\"decimals overflow\");\n    return super.toFixed(decimalPlaces, format, rounding);\n  }\n\n  /**\n   * To exact\n   *\n   * @example\n   * ```\n   * 1 -> 1\n   * 1.234 -> 1.234\n   * 1.123456789876543 -> 1.123456789\n   * ```\n   */\n  public toExact(format: object = { groupSeparator: \"\" }): string {\n    Big.DP = this.token.decimals;\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);\n  }\n}\n\n// export class TokenAmount extends CurrencyAmount {\n//   public readonly token: Token;\n\n//   public constructor(token: Token, amount: BigNumberish, isRaw = true) {\n//     super(token, amount, isRaw);\n//     this.token = token;\n//   }\n\n//   public add(other: TokenAmount): TokenAmount {\n//     if (!currencyEquals(this.token, other.token)) this.logger.logWithError(\"add token not equals\");\n//     return new TokenAmount(this.token, this.raw.add(other.raw));\n//   }\n\n//   public subtract(other: TokenAmount): TokenAmount {\n//     if (!currencyEquals(this.token, other.token)) this.logger.logWithError(\"sub token not equals\");\n//     return new TokenAmount(this.token, this.raw.sub(other.raw));\n//   }\n// }\n","import { get, set } from \"lodash\";\nimport dayjs from \"dayjs\";\nimport utc from \"dayjs/plugin/utc\";\ndayjs.extend(utc);\n\nexport type ModuleName = \"Common.Api\";\n\nexport enum LogLevel {\n  Error,\n  Warning,\n  Info,\n  Debug,\n}\nexport class Logger {\n  private logLevel: LogLevel;\n  private name: string;\n  constructor(params: { name: string; logLevel?: LogLevel }) {\n    this.logLevel = params.logLevel !== undefined ? params.logLevel : LogLevel.Debug;\n    this.name = params.name;\n  }\n\n  set level(logLevel: LogLevel) {\n    this.logLevel = logLevel;\n  }\n  get time(): string {\n    return dayjs().utc().format(\"YYYY/MM/DD HH:mm:ss UTC\");\n  }\n  get moduleName(): string {\n    return this.name;\n  }\n\n  private isLogLevel(level: LogLevel): boolean {\n    return level <= this.logLevel;\n  }\n\n  public error(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Error)) return this;\n    console.error(this.time, this.name, \"sdk logger error\", ...props);\n    return this;\n  }\n\n  public logWithError(...props): Logger {\n    // this.error(...props)\n    const msg = props.map((arg) => (typeof arg === \"object\" ? JSON.stringify(arg) : arg)).join(\", \");\n    throw new Error(msg);\n  }\n\n  public warning(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Warning)) return this;\n    console.warn(this.time, this.name, \"sdk logger warning\", ...props);\n    return this;\n  }\n\n  public info(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Info)) return this;\n    console.info(this.time, this.name, \"sdk logger info\", ...props);\n    return this;\n  }\n\n  public debug(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Debug)) return this;\n    console.debug(this.time, this.name, \"sdk logger debug\", ...props);\n    return this;\n  }\n}\n\nconst moduleLoggers: { [key in ModuleName]?: Logger } = {};\nconst moduleLevels: { [key in ModuleName]?: LogLevel } = {};\n\nexport function createLogger(moduleName: string): Logger {\n  let logger = get(moduleLoggers, moduleName);\n  if (!logger) {\n    // default level is error\n    const logLevel = get(moduleLevels, moduleName);\n\n    logger = new Logger({ name: moduleName, logLevel });\n    set(moduleLoggers, moduleName, logger);\n  }\n\n  return logger;\n}\n\nexport function setLoggerLevel(moduleName: string, level: LogLevel): void {\n  set(moduleLevels, moduleName, level);\n\n  const logger = get(moduleLoggers, moduleName);\n  if (logger) logger.level = level;\n}\n","import Big, { BigConstructor, BigSource, RoundingMode } from \"big.js\";\nimport Decimal, { Config, Numeric } from \"decimal.js-light\";\nimport _toFarmat from \"toformat\";\n\ntype TakeStatic<T> = { [P in keyof T]: T[P] };\ninterface FormatOptions {\n  decimalSeparator?: string;\n  groupSeparator?: string;\n  groupSize?: number;\n  fractionGroupSeparator?: string;\n  fractionGroupSize?: number;\n}\ninterface WrappedBigConstructor extends TakeStatic<BigConstructor> {\n  new (value: BigSource): WrappedBig;\n  (value: BigSource): WrappedBig;\n  (): WrappedBigConstructor;\n\n  format: FormatOptions;\n}\nexport interface WrappedBig extends Big {\n  add(n: BigSource): WrappedBig;\n  abs(): WrappedBig;\n  div(n: BigSource): WrappedBig;\n  minus(n: BigSource): WrappedBig;\n  mod(n: BigSource): WrappedBig;\n  mul(n: BigSource): WrappedBig;\n  plus(n: BigSource): WrappedBig;\n  pow(exp: number): WrappedBig;\n  round(dp?: number, rm?: RoundingMode): WrappedBig;\n  sqrt(): WrappedBig;\n  sub(n: BigSource): WrappedBig;\n  times(n: BigSource): WrappedBig;\n  toFormat(): string;\n  toFormat(options: FormatOptions): string;\n  toFormat(fractionLength: number): string;\n  toFormat(fractionLength: number, options: FormatOptions): string;\n  toFormat(fractionLength: number, missionUnknown: number): string;\n  toFormat(fractionLength: number, missionUnknown: number, options: FormatOptions): string;\n}\n\ntype DecimalConstructor = typeof Decimal;\ninterface WrappedDecimalConstructor extends TakeStatic<DecimalConstructor> {\n  new (value: Numeric): WrappedDecimal;\n  clone(config?: Config): WrappedDecimalConstructor;\n  config(config: Config): WrappedDecimal;\n  set(config: Config): WrappedDecimal;\n  format: FormatOptions;\n}\nexport interface WrappedDecimal extends Decimal {\n  absoluteValue(): WrappedDecimal;\n  abs(): WrappedDecimal;\n  dividedBy(y: Numeric): WrappedDecimal;\n  div(y: Numeric): WrappedDecimal;\n  dividedToIntegerBy(y: Numeric): WrappedDecimal;\n  idiv(y: Numeric): WrappedDecimal;\n  logarithm(base?: Numeric): WrappedDecimal;\n  log(base?: Numeric): WrappedDecimal;\n  minus(y: Numeric): WrappedDecimal;\n  sub(y: Numeric): WrappedDecimal;\n  modulo(y: Numeric): WrappedDecimal;\n  mod(y: Numeric): WrappedDecimal;\n  naturalExponetial(): WrappedDecimal;\n  exp(): WrappedDecimal;\n  naturalLogarithm(): WrappedDecimal;\n  ln(): WrappedDecimal;\n  negated(): WrappedDecimal;\n  neg(): WrappedDecimal;\n  plus(y: Numeric): WrappedDecimal;\n  add(y: Numeric): WrappedDecimal;\n  squareRoot(): WrappedDecimal;\n  sqrt(): WrappedDecimal;\n  times(y: Numeric): WrappedDecimal;\n  mul(y: Numeric): WrappedDecimal;\n  toWrappedDecimalPlaces(dp?: number, rm?: number): WrappedDecimal;\n  todp(dp?: number, rm?: number): WrappedDecimal;\n  toInteger(): WrappedDecimal;\n  toint(): WrappedDecimal;\n  toPower(y: Numeric): WrappedDecimal;\n  pow(y: Numeric): WrappedDecimal;\n  toSignificantDigits(sd?: number, rm?: number): WrappedDecimal;\n  tosd(sd?: number, rm?: number): WrappedDecimal;\n  toFormat(options: FormatOptions): string;\n  toFormat(fractionLength: number): string;\n  toFormat(fractionLength: number, options: FormatOptions): string;\n  toFormat(fractionLength: number, missionUnknown: number): string;\n  toFormat(fractionLength: number, missionUnknown: number, options: FormatOptions): string;\n}\n\nconst toFormat: {\n  (fn: BigConstructor): WrappedBigConstructor;\n  (fn: DecimalConstructor): WrappedDecimalConstructor;\n} = _toFarmat;\nexport default toFormat;\n","import _Big from \"big.js\";\nimport BN from \"bn.js\";\nimport _Decimal from \"decimal.js-light\";\n\nimport { BigNumberish, BN_ONE, parseBigNumberish, Rounding } from \"../common/bignumber\";\nimport { createLogger } from \"../common/logger\";\n\nimport toFormat, { WrappedBig } from \"./formatter\";\n\nconst logger = createLogger(\"module/fraction\");\n\nconst Big = toFormat(_Big);\ntype Big = WrappedBig;\n\nconst Decimal = toFormat(_Decimal);\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP,\n};\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: _Big.roundDown,\n  [Rounding.ROUND_HALF_UP]: _Big.roundHalfUp,\n  [Rounding.ROUND_UP]: _Big.roundUp,\n};\n\nexport class Fraction {\n  public readonly numerator: BN;\n  public readonly denominator: BN;\n\n  public constructor(numerator: BigNumberish, denominator: BigNumberish = BN_ONE) {\n    this.numerator = parseBigNumberish(numerator);\n    this.denominator = parseBigNumberish(denominator);\n  }\n\n  public get quotient(): BN {\n    return this.numerator.div(this.denominator);\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator);\n  }\n\n  public add(other: Fraction | BigNumberish): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigNumberish(other));\n\n    if (this.denominator.eq(otherParsed.denominator)) {\n      return new Fraction(this.numerator.add(otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator).add(otherParsed.numerator.mul(this.denominator)),\n      this.denominator.mul(otherParsed.denominator),\n    );\n  }\n\n  public sub(other: Fraction | BigNumberish): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigNumberish(other));\n\n    if (this.denominator.eq(otherParsed.denominator)) {\n      return new Fraction(this.numerator.sub(otherParsed.numerator), this.denominator);\n    }\n\n    return new Fraction(\n      this.numerator.mul(otherParsed.denominator).sub(otherParsed.numerator.mul(this.denominator)),\n      this.denominator.mul(otherParsed.denominator),\n    );\n  }\n\n  public mul(other: Fraction | BigNumberish): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigNumberish(other));\n\n    return new Fraction(this.numerator.mul(otherParsed.numerator), this.denominator.mul(otherParsed.denominator));\n  }\n\n  public div(other: Fraction | BigNumberish): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigNumberish(other));\n\n    return new Fraction(this.numerator.mul(otherParsed.denominator), this.denominator.mul(otherParsed.numerator));\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: \"\" },\n    rounding: Rounding = Rounding.ROUND_HALF_UP,\n  ): string {\n    if (!Number.isInteger(significantDigits)) logger.logWithError(`${significantDigits} is not an integer.`);\n    if (significantDigits <= 0) logger.logWithError(`${significantDigits} is not positive.`);\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] });\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits);\n    return quotient.toFormat(quotient.decimalPlaces(), format);\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: \"\" },\n    rounding: Rounding = Rounding.ROUND_HALF_UP,\n  ): string {\n    if (!Number.isInteger(decimalPlaces)) logger.logWithError(`${decimalPlaces} is not an integer.`);\n    if (decimalPlaces < 0) logger.logWithError(`${decimalPlaces} is negative.`);\n\n    Big.DP = decimalPlaces;\n    Big.RM = toFixedRounding[rounding] || 1;\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);\n  }\n\n  public isZero(): boolean {\n    return this.numerator.isZero();\n  }\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { NativeTokenInfo, SplTokenInfo } from \"./type\";\n\nexport const TOKEN_SOL: NativeTokenInfo = {\n  symbol: \"SOL\",\n  name: \"Solana\",\n  decimals: 9,\n};\n\nexport const TOKEN_WSOL: SplTokenInfo = {\n  symbol: \"WSOL\",\n  name: \"Wrapped SOL\",\n  mint: \"So11111111111111111111111111111111111111112\",\n  decimals: 9,\n  extensions: {\n    coingeckoId: \"solana\",\n  },\n};\n\nexport const quantumSOLHydratedTokenJsonInfo = {\n  isQuantumSOL: true,\n  isLp: false,\n  official: true,\n  mint: new PublicKey(TOKEN_WSOL.mint),\n  decimals: 9,\n  symbol: \"SOL\",\n  id: \"sol\",\n  name: \"solana\",\n  icon: `https://img.raydium.io/icon/So11111111111111111111111111111111111111112.png`,\n  extensions: {\n    coingeckoId: \"solana\",\n  },\n};\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { PublicKeyish, SOLMint, validateAndParsePublicKey } from \"../common/pubKey\";\nimport { TOKEN_WSOL } from \"../raydium/token/constant\";\n\n/**\n * A token is any fungible financial instrument on Solana, including SOL and all SPL tokens.\n */\nexport interface TokenProps {\n  mint: PublicKeyish;\n  decimals: number;\n  symbol?: string;\n  name?: string;\n  skipMint?: boolean;\n}\n\nexport class Token {\n  public readonly symbol?: string;\n  public readonly name?: string;\n  public readonly decimals: number;\n\n  public readonly mint: PublicKey;\n  public static readonly WSOL: Token = new Token(TOKEN_WSOL);\n\n  /**\n   *\n   * @param mint - pass \"sol\" as mint will auto generate wsol token config\n   */\n  public constructor({ mint, decimals, symbol = \"UNKNOWN\", name = \"UNKNOWN\", skipMint = false }: TokenProps) {\n    if (mint === SOLMint.toBase58() || (mint instanceof PublicKey && SOLMint.equals(mint))) {\n      this.decimals = TOKEN_WSOL.decimals;\n      this.symbol = TOKEN_WSOL.symbol;\n      this.name = TOKEN_WSOL.name;\n      this.mint = new PublicKey(TOKEN_WSOL.mint);\n      return;\n    }\n\n    this.decimals = decimals;\n    this.symbol = symbol;\n    this.name = name;\n    this.mint = skipMint ? PublicKey.default : validateAndParsePublicKey({ publicKey: mint });\n  }\n\n  public equals(other: Token): boolean {\n    // short circuit on reference equality\n    if (this === other) {\n      return true;\n    }\n    return this.mint.equals(other.mint);\n  }\n}\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { AccountMeta, PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\n\ninterface AccountMetaProps {\n  pubkey: PublicKey;\n  isSigner?: boolean;\n  isWritable?: boolean;\n}\n\nexport function accountMeta({ pubkey, isSigner = false, isWritable = true }: AccountMetaProps): AccountMeta {\n  return {\n    pubkey,\n    isWritable,\n    isSigner,\n  };\n}\n\nexport const commonSystemAccountMeta = [\n  accountMeta({ pubkey: TOKEN_PROGRAM_ID, isWritable: false }),\n  accountMeta({ pubkey: SystemProgram.programId, isWritable: false }),\n  accountMeta({ pubkey: SYSVAR_RENT_PUBKEY, isWritable: false }),\n];\n\nexport type PublicKeyish = PublicKey | string;\n\nexport function validateAndParsePublicKey({\n  publicKey,\n  transformSol,\n}: {\n  publicKey: PublicKeyish;\n  transformSol?: boolean;\n}): PublicKey {\n  if (publicKey instanceof PublicKey) {\n    if (transformSol && publicKey.equals(SOLMint)) return WSOLMint;\n    return publicKey;\n  }\n\n  if (transformSol && publicKey === SOLMint.toBase58()) return WSOLMint;\n\n  if (typeof publicKey === \"string\") {\n    try {\n      const key = new PublicKey(publicKey);\n      return key;\n    } catch {\n      throw new Error(\"invalid public key\");\n    }\n  }\n\n  throw new Error(\"invalid public key\");\n}\n\nexport function tryParsePublicKey(v: string): PublicKey | string {\n  try {\n    return new PublicKey(v);\n  } catch (e) {\n    return v;\n  }\n}\n\nexport const RAYMint = new PublicKey(\"4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R\");\nexport const PAIMint = new PublicKey(\"Ea5SjE2Y6yvCeW5dYTn7PYMuW5ikXkvbGdcmSnXeaLjS\");\nexport const SRMMint = new PublicKey(\"SRMuApVNdxXokk5GT7XD5cUUgXMBCoAz2LHeuAoKWRt\");\nexport const USDCMint = new PublicKey(\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\");\nexport const USDTMint = new PublicKey(\"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB\");\nexport const mSOLMint = new PublicKey(\"mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So\");\nexport const stSOLMint = new PublicKey(\"7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj\");\nexport const USDHMint = new PublicKey(\"USDH1SM1ojwWUga67PGrgFWUHibbjqMvuMaDkRJTgkX\");\nexport const NRVMint = new PublicKey(\"NRVwhjBQiUPYtfDT5zRBVJajzFQHaBUNtC7SNVvqRFa\");\nexport const ANAMint = new PublicKey(\"ANAxByE6G2WjFp7A4NqtWYXb3mgruyzZYg3spfxe6Lbo\");\nexport const ETHMint = new PublicKey(\"7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs\");\nexport const WSOLMint = new PublicKey(\"So11111111111111111111111111111111111111112\");\nexport const SOLMint = PublicKey.default;\n","import { TOKEN_SOL } from \"../raydium/token/constant\";\n\nimport { Token } from \"./token\";\n\ninterface CurrencyProps {\n  decimals: number;\n  symbol?: string;\n  name?: string;\n}\n/**\n * A currency is any fungible financial instrument on Solana, including SOL and all SPL tokens.\n * The only instance of the base class `Currency` is SOL.\n */\nexport class Currency {\n  public readonly symbol?: string;\n  public readonly name?: string;\n  public readonly decimals: number;\n\n  /**\n   * The only instance of the base class `Currency`.\n   */\n  public static readonly SOL: Currency = new Currency(TOKEN_SOL);\n\n  /**\n   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.SOL`.\n   * @param decimals - decimals of the currency\n   * @param symbol - symbol of the currency\n   * @param name - name of the currency\n   */\n  public constructor({ decimals, symbol = \"UNKNOWN\", name = \"UNKNOWN\" }: CurrencyProps) {\n    this.decimals = decimals;\n    this.symbol = symbol;\n    this.name = name;\n  }\n\n  public equals(other: Currency): boolean {\n    return this === other;\n  }\n}\n\n/**\n * Compares two currencies for equality\n */\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB);\n  } else if (currencyA instanceof Token || currencyB instanceof Token) {\n    return false;\n  } else {\n    return currencyA === currencyB;\n  }\n}\n","import { BN_100, Rounding } from \"../common/bignumber\";\n\nimport { Fraction } from \"./fraction\";\n\nexport const _100_PERCENT = new Fraction(BN_100);\n\nexport class Percent extends Fraction {\n  public toSignificant(significantDigits = 5, format?: object, rounding?: Rounding): string {\n    return this.mul(_100_PERCENT).toSignificant(significantDigits, format, rounding);\n  }\n\n  public toFixed(decimalPlaces = 2, format?: object, rounding?: Rounding): string {\n    return this.mul(_100_PERCENT).toFixed(decimalPlaces, format, rounding);\n  }\n}\n","import { BigNumberish, Rounding, tenExponential } from \"../common/bignumber\";\nimport { createLogger } from \"../common/logger\";\n\nimport { Fraction } from \"./fraction\";\nimport { Token } from \"./token\";\n\nconst logger = createLogger(\"Raydium_price\");\n\ninterface PriceProps {\n  baseToken: Token;\n  denominator: BigNumberish;\n  quoteToken: Token;\n  numerator: BigNumberish;\n}\n\nexport class Price extends Fraction {\n  public readonly baseToken: Token; // input i.e. denominator\n  public readonly quoteToken: Token; // output i.e. numerator\n  // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n  public readonly scalar: Fraction;\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  public constructor(params: PriceProps) {\n    const { baseToken, quoteToken, numerator, denominator } = params;\n    super(numerator, denominator);\n\n    this.baseToken = baseToken;\n    this.quoteToken = quoteToken;\n    this.scalar = new Fraction(tenExponential(baseToken.decimals), tenExponential(quoteToken.decimals));\n  }\n\n  public get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator);\n  }\n\n  public get adjusted(): Fraction {\n    return super.mul(this.scalar);\n  }\n\n  public invert(): Price {\n    return new Price({\n      baseToken: this.quoteToken,\n      quoteToken: this.baseToken,\n      denominator: this.numerator,\n      numerator: this.denominator,\n    });\n  }\n\n  public mul(other: Price): Price {\n    if (this.quoteToken !== other.baseToken) logger.logWithError(\"mul token not equals\");\n\n    const fraction = super.mul(other);\n    return new Price({\n      baseToken: this.baseToken,\n      quoteToken: other.quoteToken,\n      denominator: fraction.denominator,\n      numerator: fraction.numerator,\n    });\n  }\n\n  public toSignificant(significantDigits = this.quoteToken.decimals, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding);\n  }\n\n  public toFixed(decimalPlaces = this.quoteToken.decimals, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding);\n  }\n}\n","import { OpenOrders } from \"@project-serum/serum\";\nimport { Connection, PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\n\nimport { LiquidityVersion } from \"../../api/type\";\nimport { createLogger } from \"../../common/logger\";\nimport { PublicKeyish, validateAndParsePublicKey } from \"../../common/pubKey\";\nimport {\n  findProgramAddress, parseSimulateLogToJson, parseSimulateValue, simulateMultipleInstruction,\n} from \"../../common/txTool\";\nimport { Token, TokenAmount } from \"../../module\";\n\nimport { LIQUIDITY_VERSION_TO_PROGRAM_ID, LiquidityPoolStatus } from \"./constant\";\nimport { makeSimulatePoolInfoInstruction } from \"./instruction\";\nimport { LIQUIDITY_VERSION_TO_STATE_LAYOUT, LiquidityStateLayout, liquidityStateV4Layout } from \"./layout\";\nimport { getSerumAssociatedAuthority, getSerumProgramId, getSerumVersion } from \"./serum\";\nimport {\n  AmountSide, LiquidityAssociatedPoolKeys, LiquidityFetchMultipleInfoParams, LiquidityPoolInfo, LiquidityPoolKeys,\n} from \"./type\";\n\nconst logger = createLogger(\"Raydium_liquidity_util\");\n/**\n * Get token amount side of liquidity pool\n * @param amount - the token amount provided\n * @param poolKeys - the pool keys\n * @returns token amount side is `base` or `quote`\n */\nexport function getAmountSide(amount: TokenAmount, poolKeys: LiquidityPoolKeys): AmountSide {\n  const token = amount instanceof TokenAmount ? amount.token : Token.WSOL;\n  const { baseMint, quoteMint } = poolKeys;\n\n  if (token.mint.equals(baseMint)) return \"base\";\n  else if (token.mint.equals(quoteMint)) return \"quote\";\n  const error = `liquidity getTokenSide - token not match with pool, params: ${JSON.stringify({\n    token: token.mint,\n    baseMint,\n    quoteMint,\n  })}`;\n  console.error(error);\n  throw new Error(error);\n}\n\nexport function includesToken(token: Token, poolKeys: LiquidityPoolKeys): boolean {\n  const { baseMint, quoteMint } = poolKeys;\n  return token.mint.equals(baseMint) || token.mint.equals(quoteMint);\n}\n\nexport function getPoolEnabledFeatures(poolInfo: LiquidityPoolInfo): {\n  swap: boolean;\n  addLiquidity: boolean;\n  removeLiquidity: boolean;\n} {\n  const { status, startTime } = poolInfo;\n  const statusEnum = status.toNumber();\n\n  const statusMap = {\n    [LiquidityPoolStatus.Uninitialized]: {\n      swap: false,\n      addLiquidity: false,\n      removeLiquidity: false,\n    },\n    [LiquidityPoolStatus.Initialized]: {\n      swap: true,\n      addLiquidity: true,\n      removeLiquidity: true,\n    },\n    [LiquidityPoolStatus.Disabled]: {\n      swap: false,\n      addLiquidity: false,\n      removeLiquidity: false,\n    },\n    [LiquidityPoolStatus.RemoveLiquidityOnly]: {\n      swap: false,\n      addLiquidity: false,\n      removeLiquidity: true,\n    },\n    [LiquidityPoolStatus.LiquidityOnly]: {\n      swap: false,\n      addLiquidity: true,\n      removeLiquidity: true,\n    },\n    [LiquidityPoolStatus.OrderBook]: {\n      swap: false,\n      addLiquidity: true,\n      removeLiquidity: true,\n    },\n    [LiquidityPoolStatus.Swap]: {\n      swap: true,\n      addLiquidity: true,\n      removeLiquidity: true,\n    },\n    [LiquidityPoolStatus.WaitingForStart]: {\n      swap: Date.now() / 1000 >= startTime.toNumber(),\n      addLiquidity: true,\n      removeLiquidity: true,\n    },\n  };\n\n  return (\n    statusMap[statusEnum] || {\n      swap: false,\n      addLiquidity: false,\n      removeLiquidity: false,\n    }\n  );\n}\n\nexport function getLiquidityStateLayout(version: number): LiquidityStateLayout {\n  const STATE_LAYOUT = LIQUIDITY_VERSION_TO_STATE_LAYOUT[version];\n  if (!STATE_LAYOUT) logger.logWithError(\"invalid version\", \"version\", version);\n\n  return STATE_LAYOUT;\n}\n\nexport function getLiquidityProgramId(version: number): PublicKey {\n  const programId = LIQUIDITY_VERSION_TO_PROGRAM_ID[version];\n  if (!programId) logger.logWithError(\"invalid version\", \"version\", version);\n\n  return programId;\n}\n\ninterface GetAssociatedParam {\n  name: AssociatedName;\n  programId: PublicKey;\n  marketId: PublicKey;\n}\n\ntype AssociatedName =\n  | \"amm_associated_seed\"\n  | \"lp_mint_associated_seed\"\n  | \"coin_vault_associated_seed\"\n  | \"pc_vault_associated_seed\"\n  | \"lp_mint_associated_seed\"\n  | \"temp_lp_token_associated_seed\"\n  | \"open_order_associated_seed\"\n  | \"target_associated_seed\"\n  | \"withdraw_associated_seed\";\n\nexport async function getLiquidityAssociatedId({ name, programId, marketId }: GetAssociatedParam): Promise<PublicKey> {\n  const { publicKey } = await findProgramAddress(\n    [programId.toBuffer(), marketId.toBuffer(), Buffer.from(name, \"utf-8\")],\n    programId,\n  );\n  return publicKey;\n}\n\nexport async function getLiquidityAssociatedAuthority({\n  programId,\n}: {\n  programId: PublicKey;\n}): Promise<{ publicKey: PublicKey; nonce: number }> {\n  return findProgramAddress([Buffer.from([97, 109, 109, 32, 97, 117, 116, 104, 111, 114, 105, 116, 121])], programId);\n}\n\nexport async function getAssociatedPoolKeys({\n  version,\n  marketId: _marketId,\n  baseMint: _baseMint,\n  quoteMint: _quoteMint,\n}: {\n  version: LiquidityVersion;\n  marketId: PublicKeyish;\n  baseMint: PublicKeyish;\n  quoteMint: PublicKeyish;\n}): Promise<LiquidityAssociatedPoolKeys> {\n  const programId = getLiquidityProgramId(version);\n  const [marketId, baseMint, quoteMint] = [\n    validateAndParsePublicKey({ publicKey: _marketId }),\n    validateAndParsePublicKey({ publicKey: _baseMint, transformSol: true }),\n    validateAndParsePublicKey({ publicKey: _quoteMint, transformSol: true }),\n  ];\n\n  const id = await getLiquidityAssociatedId({ name: \"amm_associated_seed\", programId, marketId });\n  const lpMint = await getLiquidityAssociatedId({ name: \"lp_mint_associated_seed\", programId, marketId });\n  const { publicKey: authority, nonce } = await getLiquidityAssociatedAuthority({ programId });\n  const baseVault = await getLiquidityAssociatedId({ name: \"coin_vault_associated_seed\", programId, marketId });\n  const quoteVault = await getLiquidityAssociatedId({ name: \"pc_vault_associated_seed\", programId, marketId });\n  const lpVault = await getLiquidityAssociatedId({ name: \"temp_lp_token_associated_seed\", programId, marketId });\n  const openOrders = await getLiquidityAssociatedId({ name: \"open_order_associated_seed\", programId, marketId });\n  const targetOrders = await getLiquidityAssociatedId({ name: \"target_associated_seed\", programId, marketId });\n  const withdrawQueue = await getLiquidityAssociatedId({ name: \"withdraw_associated_seed\", programId, marketId });\n\n  const serumVersion = getSerumVersion(version);\n  const serumProgramId = getSerumProgramId(serumVersion);\n  const { publicKey: marketAuthority } = await getSerumAssociatedAuthority({\n    programId: serumProgramId,\n    marketId,\n  });\n\n  return {\n    // base\n    id,\n    baseMint,\n    quoteMint,\n    lpMint,\n    // version\n    version,\n    programId,\n    // keys\n    authority,\n    nonce,\n    baseVault,\n    quoteVault,\n    lpVault,\n    openOrders,\n    targetOrders,\n    withdrawQueue,\n    // market version\n    marketVersion: serumVersion,\n    marketProgramId: serumProgramId,\n    // market keys\n    marketId,\n    marketAuthority,\n  };\n}\n\nexport async function makeSimulationPoolInfo({\n  connection,\n  pools,\n}: LiquidityFetchMultipleInfoParams & { connection: Connection }): Promise<LiquidityPoolInfo[]> {\n  const instructions = pools.map((pool) => makeSimulatePoolInfoInstruction(pool));\n  const logs = await simulateMultipleInstruction(connection, instructions, \"GetPoolData\");\n\n  return logs.map((log) => {\n    const json = parseSimulateLogToJson(log, \"GetPoolData\");\n    const status = new BN(parseSimulateValue(json, \"status\"));\n    const baseDecimals = Number(parseSimulateValue(json, \"coin_decimals\"));\n    const quoteDecimals = Number(parseSimulateValue(json, \"pc_decimals\"));\n    const lpDecimals = Number(parseSimulateValue(json, \"lp_decimals\"));\n    const baseReserve = new BN(parseSimulateValue(json, \"pool_coin_amount\"));\n    const quoteReserve = new BN(parseSimulateValue(json, \"pool_pc_amount\"));\n    const lpSupply = new BN(parseSimulateValue(json, \"pool_lp_supply\"));\n    let startTime = \"0\";\n    try {\n      startTime = parseSimulateValue(json, \"pool_open_time\");\n    } catch (error) {\n      startTime = \"0\";\n    }\n\n    return {\n      status,\n      baseDecimals,\n      quoteDecimals,\n      lpDecimals,\n      baseReserve,\n      quoteReserve,\n      lpSupply,\n      startTime: new BN(startTime),\n    };\n  });\n}\n\n/**\n * Get currencies amount side of liquidity pool\n * @param amountA - the token amount provided\n * @param amountB - the token amount provided\n * @param poolKeys - the pool keys\n * @returns currencies amount side array\n */\nexport function getAmountsSide(amountA: TokenAmount, amountB: TokenAmount, poolKeys: LiquidityPoolKeys): AmountSide[] {\n  return getTokensSide(amountA.token, amountB.token, poolKeys);\n}\n\nexport function getTokensSide(tokenA: Token, tokenB: Token, poolKeys: LiquidityPoolKeys): AmountSide[] {\n  const { baseMint, quoteMint } = poolKeys;\n\n  const sideA = getTokenSide(tokenA, poolKeys);\n  const sideB = getTokenSide(tokenB, poolKeys);\n\n  if (sideA === sideB)\n    logger.logWithError(\"tokens not match with pool\", \"params\", {\n      tokenA: tokenA.mint,\n      tokenB: tokenB.mint,\n      baseMint,\n      quoteMint,\n    });\n  return [sideA, sideB];\n}\n\nexport function getTokenSide(token: Token, poolKeys: LiquidityPoolKeys): AmountSide {\n  const { baseMint, quoteMint } = poolKeys;\n\n  if (token.mint.equals(baseMint)) return \"base\";\n  else if (token.mint.equals(quoteMint)) return \"quote\";\n\n  logger.logWithError(\"token not match with pool\", \"params\", {\n    token: token.mint,\n    baseMint,\n    quoteMint,\n  });\n  return \"base\"; // won't reach\n}\n\nexport const isValidFixedSide = (val: string): boolean => val === \"a\" || val === \"b\";\n\nexport async function getLiquidityInfo(\n  connection: Connection,\n  poolId: PublicKey,\n  dexProgramId: PublicKey,\n): Promise<{\n  baseAmount: number;\n  quoteAmount: number;\n  lpSupply: number;\n  baseVaultKey: PublicKey;\n  quoteVaultKey: PublicKey;\n  baseVaultBalance: number | null;\n  quoteVaultBalance: number | null;\n  openOrdersKey: PublicKey;\n  openOrdersTotalBase: number;\n  openOrdersTotalQuote: number;\n  basePnl: number;\n  quotePnl: number;\n  priceInQuote: number;\n} | null> {\n  const info = await connection.getAccountInfo(poolId);\n  if (info === null) return null;\n  const state = liquidityStateV4Layout.decode(info.data);\n\n  const baseTokenAmount = await connection.getTokenAccountBalance(state.baseVault);\n  const quoteTokenAmount = await connection.getTokenAccountBalance(state.quoteVault);\n  const openOrders = await OpenOrders.load(connection, state.openOrders, dexProgramId);\n\n  const baseDecimal = 10 ** state.baseDecimal.toNumber();\n  const quoteDecimal = 10 ** state.quoteDecimal.toNumber();\n\n  const openOrdersTotalBase = openOrders.baseTokenTotal.toNumber() / baseDecimal;\n  const openOrdersTotalQuote = openOrders.quoteTokenTotal.toNumber() / quoteDecimal;\n\n  const basePnl = state.baseNeedTakePnl.toNumber() / baseDecimal;\n  const quotePnl = state.quoteNeedTakePnl.toNumber() / quoteDecimal;\n\n  const baseAmount = baseTokenAmount.value.uiAmount! + openOrdersTotalBase - basePnl;\n  const quoteAmount = quoteTokenAmount.value.uiAmount! + openOrdersTotalQuote - quotePnl;\n\n  const lpSupply = parseFloat(state.lpReserve.toString());\n  const priceInQuote = baseAmount / quoteAmount;\n\n  return {\n    baseAmount,\n    quoteAmount,\n    lpSupply,\n    baseVaultKey: state.baseVault,\n    quoteVaultKey: state.quoteVault,\n    baseVaultBalance: baseTokenAmount.value.uiAmount,\n    quoteVaultBalance: quoteTokenAmount.value.uiAmount,\n    openOrdersKey: state.openOrders,\n    openOrdersTotalBase,\n    openOrdersTotalQuote,\n    basePnl,\n    quotePnl,\n    priceInQuote,\n  };\n}\n","import {\n  Connection,\n  PACKET_DATA_SIZE,\n  PublicKey,\n  RpcResponseAndContext,\n  sendAndConfirmTransaction,\n  Signer,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\n\nimport { SignAllTransactions } from \"../raydium/type\";\n\nimport { createLogger } from \"./logger\";\nimport { Owner } from \"./owner\";\n\nconst logger = createLogger(\"Raydium_txTool\");\ninterface TxBuilderInit {\n  connection: Connection;\n  feePayer: PublicKey;\n  owner?: Owner;\n  signAllTransactions?: SignAllTransactions;\n}\n\nexport interface AddInstructionParam {\n  instructions?: TransactionInstruction[];\n  endInstructions?: TransactionInstruction[];\n  signers?: Signer[];\n}\n\nexport interface TxBuildData {\n  transaction: Transaction;\n  signers: Signer[];\n  execute: () => Promise<string>;\n  extInfo: Record<string, any>;\n}\n\nexport interface MultiTxBuildData {\n  transactions: Transaction[];\n  signers: Signer[][];\n  execute: () => Promise<string[]>;\n  extInfo: Record<string, any>;\n}\n\nexport class TxBuilder {\n  private connection: Connection;\n  private owner?: Owner;\n  private instructions: TransactionInstruction[] = [];\n  private endInstructions: TransactionInstruction[] = [];\n  private signers: Signer[] = [];\n  private feePayer: PublicKey;\n  private signAllTransactions?: SignAllTransactions;\n\n  constructor(params: TxBuilderInit) {\n    this.connection = params.connection;\n    this.feePayer = params.feePayer;\n    this.signAllTransactions = params.signAllTransactions;\n    this.owner = params.owner;\n  }\n\n  get AllTxData(): {\n    instructions: TransactionInstruction[];\n    endInstructions: TransactionInstruction[];\n    signers: Signer[];\n  } {\n    return {\n      instructions: this.instructions,\n      endInstructions: this.endInstructions,\n      signers: this.signers,\n    };\n  }\n\n  get allInstructions(): TransactionInstruction[] {\n    return [...this.instructions, ...this.endInstructions];\n  }\n\n  public addInstruction({ instructions = [], endInstructions = [], signers = [] }: AddInstructionParam): TxBuilder {\n    this.instructions.push(...instructions);\n    this.endInstructions.push(...endInstructions);\n    this.signers.push(...signers);\n    return this;\n  }\n\n  public build(extInfo?: Record<string, any>): TxBuildData {\n    const transaction = new Transaction();\n    if (this.allInstructions.length) transaction.add(...this.allInstructions);\n    transaction.feePayer = this.feePayer;\n\n    return {\n      transaction,\n      signers: this.signers,\n      execute: async (): Promise<string> => {\n        const recentBlockHash = await getRecentBlockHash(this.connection);\n        transaction.recentBlockhash = recentBlockHash;\n        if (this.owner?.isKeyPair) {\n          return sendAndConfirmTransaction(this.connection, transaction, this.signers);\n        }\n        if (this.signAllTransactions) {\n          if (this.signers.length) transaction.partialSign(...this.signers);\n          const txs = await this.signAllTransactions([transaction]);\n          return await this.connection.sendRawTransaction(txs[0].serialize(), { skipPreflight: true });\n        }\n        throw new Error(\"please connect wallet first\");\n      },\n      extInfo: extInfo || {},\n    };\n  }\n\n  public buildMultiTx(params: { extraPreBuildData?: TxBuildData[]; extInfo?: Record<string, any> }): MultiTxBuildData {\n    const { extraPreBuildData = [], extInfo } = params;\n    const { transaction } = this.build(extInfo);\n\n    const filterExtraBuildData = extraPreBuildData.filter((data) => data.transaction.instructions.length > 0);\n\n    const allTransactions: Transaction[] = [...filterExtraBuildData.map((data) => data.transaction), transaction];\n    const allSigners: Signer[][] = [...filterExtraBuildData.map((data) => data.signers), this.signers];\n\n    return {\n      transactions: allTransactions,\n      signers: allSigners,\n      execute: async (): Promise<string[]> => {\n        const recentBlockHash = await getRecentBlockHash(this.connection);\n        if (this.owner?.isKeyPair) {\n          return await Promise.all(\n            allTransactions.map(async (tx, idx) => {\n              tx.recentBlockhash = recentBlockHash;\n              return await sendAndConfirmTransaction(this.connection, tx, allSigners[idx]);\n            }),\n          );\n        }\n        if (this.signAllTransactions) {\n          const partialSignedTxs = allTransactions.map((tx, idx) => {\n            tx.recentBlockhash = recentBlockHash;\n            if (allSigners[idx].length) tx.partialSign(...allSigners[idx]);\n            return tx;\n          });\n          const signedTxs = await this.signAllTransactions(partialSignedTxs);\n\n          const txIds: string[] = [];\n          for (let i = 0; i < signedTxs.length; i += 1) {\n            const txId = await this.connection.sendRawTransaction(signedTxs[i].serialize(), { skipPreflight: true });\n            txIds.push(txId);\n          }\n          return txIds;\n        }\n        throw new Error(\"please connect wallet first\");\n      },\n      extInfo: extInfo || {},\n    };\n  }\n}\n\nexport async function getRecentBlockHash(connection: Connection): Promise<string> {\n  try {\n    return (await connection.getLatestBlockhash?.())?.blockhash || (await connection.getRecentBlockhash()).blockhash;\n  } catch {\n    return (await connection.getRecentBlockhash()).blockhash;\n  }\n}\n\n/**\n * Forecast transaction size\n */\nexport function forecastTransactionSize(instructions: TransactionInstruction[], signers: PublicKey[]): number {\n  if (instructions.length < 1) logger.logWithError(`no instructions provided: ${instructions.toString()}`);\n  if (signers.length < 1) logger.logWithError(`no signers provided:, ${signers.toString()}`);\n\n  const transaction = new Transaction();\n  transaction.recentBlockhash = \"11111111111111111111111111111111\";\n  transaction.feePayer = signers[0];\n  transaction.add(...instructions);\n\n  const message = transaction.compileMessage().serialize();\n  // SIGNATURE_LENGTH = 64\n  const transactionLength = signers.length + signers.length * 64 + message.length;\n  return transactionLength;\n}\n\n/**\n * Simulates multiple instruction\n */\nexport async function simulateMultipleInstruction(\n  connection: Connection,\n  instructions: TransactionInstruction[],\n  keyword: string,\n): Promise<any> {\n  const feePayer = new PublicKey(\"RaydiumSimuLateTransaction11111111111111111\");\n\n  const transactions: Transaction[] = [];\n\n  let transaction = new Transaction();\n  transaction.feePayer = feePayer;\n\n  for (const instruction of instructions) {\n    if (forecastTransactionSize([...transaction.instructions, instruction], [feePayer]) > PACKET_DATA_SIZE) {\n      transactions.push(transaction);\n      transaction = new Transaction();\n      transaction.feePayer = feePayer;\n      transaction.add(instruction);\n    } else {\n      transaction.add(instruction);\n    }\n  }\n  if (transaction.instructions.length > 0) {\n    transactions.push(transaction);\n  }\n\n  let results: RpcResponseAndContext<SimulatedTransactionResponse>[] = [];\n\n  try {\n    results = await Promise.all(transactions.map((transaction) => connection.simulateTransaction(transaction)));\n  } catch (error) {\n    if (error instanceof Error) {\n      logger.logWithError(`failed to simulate for instructions, RPC_ERROR, ${error.message}`);\n    }\n  }\n\n  const logs: string[] = [];\n  for (const result of results) {\n    const { value } = result;\n    logger.debug(`simulate result: ${JSON.stringify(result)}`);\n\n    if (value.logs) {\n      const filteredLog = value.logs.filter((log) => log && log.includes(keyword));\n      logger.debug(`filteredLog: ${JSON.stringify(logs)}`);\n      if (!filteredLog.length) logger.logWithError(` \"simulate log not match keyword, keyword: ${keyword}`);\n      logs.push(...filteredLog);\n    }\n  }\n\n  return logs;\n}\n\nexport function parseSimulateLogToJson(log: string, keyword: string): any {\n  const results = log.match(/{[\"\\w:,]+}/g);\n  if (!results || results.length !== 1) {\n    return logger.logWithError(`simulate log fail to match json, keyword: ${keyword}`);\n  }\n\n  return results[0];\n}\n\nexport function parseSimulateValue(log: string, key: string): any {\n  const reg = new RegExp(`\"${key}\":(\\\\d+)`, \"g\");\n\n  const results = reg.exec(log);\n  if (!results || results.length !== 2) {\n    return logger.logWithError(`simulate log fail to match key\", key: ${key}`);\n  }\n\n  return results[1];\n}\n\nexport interface ProgramAddress {\n  publicKey: PublicKey;\n  nonce: number;\n}\nexport async function findProgramAddress(\n  seeds: Array<Buffer | Uint8Array>,\n  programId: PublicKey,\n): Promise<ProgramAddress> {\n  const [publicKey, nonce] = await PublicKey.findProgramAddress(seeds, programId);\n  return { publicKey, nonce };\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\n\nimport { LiquidityVersion, SerumVersion } from \"../../api/type\";\n\nexport enum LiquidityPoolStatus {\n  Uninitialized,\n  Initialized,\n  Disabled,\n  RemoveLiquidityOnly,\n  LiquidityOnly,\n  OrderBook,\n  Swap,\n  WaitingForStart,\n}\n\nexport const LIQUIDITY_FEES_NUMERATOR = new BN(25);\nexport const LIQUIDITY_FEES_DENOMINATOR = new BN(10000);\n\n/* ================= program public keys ================= */\nexport const _LIQUIDITY_PROGRAM_ID_V4 = \"675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8\";\nexport const LIQUIDITY_PROGRAM_ID_V4 = new PublicKey(_LIQUIDITY_PROGRAM_ID_V4);\n\nexport const _LIQUIDITY_PROGRAM_ID_V5 = \"5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h\";\nexport const LIQUIDITY_PROGRAM_ID_V5 = new PublicKey(_LIQUIDITY_PROGRAM_ID_V5);\n\n// liquidity program id string => liquidity version\nexport const LIQUIDITY_PROGRAMID_TO_VERSION: {\n  [key: string]: LiquidityVersion;\n} = {\n  [_LIQUIDITY_PROGRAM_ID_V4]: 4,\n  [_LIQUIDITY_PROGRAM_ID_V5]: 5,\n};\n\n// liquidity version => liquidity program id\nexport const LIQUIDITY_VERSION_TO_PROGRAM_ID: { [key in LiquidityVersion]?: PublicKey } & {\n  [K: number]: PublicKey;\n} = {\n  4: LIQUIDITY_PROGRAM_ID_V4,\n  5: LIQUIDITY_PROGRAM_ID_V5,\n};\n\n// liquidity version => serum version\nexport const LIQUIDITY_VERSION_TO_SERUM_VERSION: {\n  [key in LiquidityVersion]?: SerumVersion;\n} & {\n  [K: number]: SerumVersion;\n} = {\n  4: 3,\n  5: 3,\n};\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { PublicKey, SystemProgram, TransactionInstruction } from \"@solana/web3.js\";\n\nimport { parseBigNumberish } from \"../../common/bignumber\";\nimport { createLogger } from \"../../common/logger\";\nimport { accountMeta, commonSystemAccountMeta } from \"../../common/pubKey\";\nimport { struct, u8 } from \"../../marshmallow\";\n\nimport {\n  addLiquidityLayout,\n  createPoolV4Layout,\n  fixedSwapInLayout,\n  fixedSwapOutLayout,\n  initPoolLayout,\n  removeLiquidityLayout,\n} from \"./layout\";\nimport { MODEL_DATA_PUBKEY } from \"./stable\";\nimport {\n  LiquidityAddInstructionParams,\n  LiquidityAssociatedPoolKeys,\n  LiquidityInitPoolInstructionParams,\n  LiquidityPoolKeys,\n  LiquidityRemoveInstructionParams,\n  LiquiditySwapFixedInInstructionParamsV4,\n  LiquiditySwapFixedOutInstructionParamsV4,\n  LiquiditySwapInstructionParams,\n} from \"./type\";\n\nconst logger = createLogger(\"Raydium_liquidity_instruction\");\n\nexport function makeAMMSwapInstruction(params: LiquiditySwapInstructionParams): TransactionInstruction {\n  const { poolKeys, userKeys, amountIn, amountOut, fixedSide } = params;\n  const { version } = poolKeys;\n  if (version === 4 || version === 5) {\n    const props = { poolKeys, userKeys };\n    if (fixedSide === \"in\") {\n      return makeSwapFixedInInstruction(\n        {\n          ...props,\n          amountIn,\n          minAmountOut: amountOut,\n        },\n        version,\n      );\n    } else if (fixedSide === \"out\") {\n      return makeSwapFixedOutInstruction(\n        {\n          ...props,\n          maxAmountIn: amountIn,\n          amountOut,\n        },\n        version,\n      );\n    }\n    logger.logWithError(\"invalid params\", \"params\", params);\n  }\n\n  logger.logWithError(\"invalid version\", \"poolKeys.version\", version);\n  throw new Error(\"invalid version\");\n}\n\nexport function makeSimulatePoolInfoInstruction(poolKeys: LiquidityPoolKeys): TransactionInstruction {\n  const simulatePoolLayout = struct([u8(\"instruction\"), u8(\"simulateType\")]);\n  const data = Buffer.alloc(simulatePoolLayout.span);\n  simulatePoolLayout.encode(\n    {\n      instruction: 12,\n      simulateType: 0,\n    },\n    data,\n  );\n\n  const keys = [\n    // amm\n    accountMeta({ pubkey: poolKeys.id, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.authority, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.openOrders, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.baseVault, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.quoteVault, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.lpMint, isWritable: false }),\n    // serum\n    accountMeta({ pubkey: poolKeys.marketId, isWritable: false }),\n  ];\n\n  return new TransactionInstruction({\n    programId: poolKeys.programId,\n    keys,\n    data,\n  });\n}\n\nexport function makeSwapFixedInInstruction(\n  { poolKeys, userKeys, amountIn, minAmountOut }: LiquiditySwapFixedInInstructionParamsV4,\n  version: number,\n): TransactionInstruction {\n  const data = Buffer.alloc(fixedSwapInLayout.span);\n  fixedSwapInLayout.encode(\n    {\n      instruction: 9,\n      amountIn: parseBigNumberish(amountIn),\n      minAmountOut: parseBigNumberish(minAmountOut),\n    },\n    data,\n  );\n  const keys = [\n    // amm\n    accountMeta({ pubkey: TOKEN_PROGRAM_ID, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.id }),\n    accountMeta({ pubkey: poolKeys.authority, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.openOrders }),\n  ];\n\n  if (version === 4) keys.push(accountMeta({ pubkey: poolKeys.targetOrders }));\n  keys.push(accountMeta({ pubkey: poolKeys.baseVault }), accountMeta({ pubkey: poolKeys.quoteVault }));\n  if (version === 5) keys.push(accountMeta({ pubkey: MODEL_DATA_PUBKEY }));\n  keys.push(\n    // serum\n    accountMeta({ pubkey: poolKeys.marketProgramId, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.marketId }),\n    accountMeta({ pubkey: poolKeys.marketBids }),\n    accountMeta({ pubkey: poolKeys.marketAsks }),\n    accountMeta({ pubkey: poolKeys.marketEventQueue }),\n    accountMeta({ pubkey: poolKeys.marketBaseVault }),\n    accountMeta({ pubkey: poolKeys.marketQuoteVault }),\n    accountMeta({ pubkey: poolKeys.marketAuthority, isWritable: false }),\n    // user\n    accountMeta({ pubkey: userKeys.tokenAccountIn }),\n    accountMeta({ pubkey: userKeys.tokenAccountOut }),\n    accountMeta({ pubkey: userKeys.owner, isWritable: false }),\n  );\n\n  return new TransactionInstruction({\n    programId: poolKeys.programId,\n    keys,\n    data,\n  });\n}\n\nexport function makeSwapFixedOutInstruction(\n  { poolKeys, userKeys, maxAmountIn, amountOut }: LiquiditySwapFixedOutInstructionParamsV4,\n  version: number,\n): TransactionInstruction {\n  const data = Buffer.alloc(fixedSwapOutLayout.span);\n  fixedSwapOutLayout.encode(\n    {\n      instruction: 11,\n      maxAmountIn: parseBigNumberish(maxAmountIn),\n      amountOut: parseBigNumberish(amountOut),\n    },\n    data,\n  );\n\n  const keys = [\n    accountMeta({ pubkey: SystemProgram.programId, isWritable: false }),\n    // amm\n    accountMeta({ pubkey: poolKeys.id }),\n    accountMeta({ pubkey: poolKeys.authority, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.openOrders }),\n    accountMeta({ pubkey: poolKeys.targetOrders }),\n    accountMeta({ pubkey: poolKeys.baseVault }),\n    accountMeta({ pubkey: poolKeys.quoteVault }),\n  ];\n\n  if (version === 5) keys.push(accountMeta({ pubkey: MODEL_DATA_PUBKEY }));\n\n  keys.push(\n    // serum\n    accountMeta({ pubkey: poolKeys.marketProgramId, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.marketId }),\n    accountMeta({ pubkey: poolKeys.marketBids }),\n    accountMeta({ pubkey: poolKeys.marketAsks }),\n    accountMeta({ pubkey: poolKeys.marketEventQueue }),\n    accountMeta({ pubkey: poolKeys.marketBaseVault }),\n    accountMeta({ pubkey: poolKeys.marketQuoteVault }),\n    accountMeta({ pubkey: poolKeys.marketAuthority, isWritable: false }),\n    accountMeta({ pubkey: userKeys.tokenAccountIn }),\n    accountMeta({ pubkey: userKeys.tokenAccountOut }),\n    accountMeta({ pubkey: userKeys.owner, isWritable: false, isSigner: true }),\n  );\n\n  return new TransactionInstruction({\n    programId: poolKeys.programId,\n    keys,\n    data,\n  });\n}\n\nexport function makeCreatePoolInstruction(\n  params: LiquidityAssociatedPoolKeys & { owner: PublicKey },\n): TransactionInstruction {\n  const { owner, ...poolKeys } = params;\n  const data = Buffer.alloc(createPoolV4Layout.span);\n  createPoolV4Layout.encode(\n    {\n      instruction: 10,\n      nonce: poolKeys.nonce,\n    },\n    data,\n  );\n\n  const keys = [\n    ...commonSystemAccountMeta,\n    // amm\n    accountMeta({ pubkey: poolKeys.targetOrders }),\n    accountMeta({ pubkey: poolKeys.withdrawQueue }),\n    accountMeta({ pubkey: poolKeys.authority, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.lpMint }),\n    accountMeta({ pubkey: poolKeys.baseMint, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.quoteMint, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.baseVault }),\n    accountMeta({ pubkey: poolKeys.quoteVault }),\n    accountMeta({ pubkey: poolKeys.lpVault }),\n    // serum\n    accountMeta({ pubkey: poolKeys.marketId, isWritable: false }),\n    accountMeta({ pubkey: owner, isSigner: true }),\n  ];\n  return new TransactionInstruction({\n    programId: poolKeys.programId,\n    keys,\n    data,\n  });\n}\n\nexport function makeInitPoolInstruction(params: LiquidityInitPoolInstructionParams): TransactionInstruction {\n  const { poolKeys, userKeys, startTime } = params;\n  const data = Buffer.alloc(initPoolLayout.span);\n  initPoolLayout.encode(\n    {\n      instruction: 0,\n      nonce: poolKeys.nonce,\n      startTime: parseBigNumberish(startTime),\n    },\n    data,\n  );\n\n  const keys = [\n    ...commonSystemAccountMeta,\n    // amm\n    accountMeta({ pubkey: poolKeys.id }),\n    accountMeta({ pubkey: poolKeys.authority, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.openOrders }),\n    accountMeta({ pubkey: poolKeys.lpMint }),\n    accountMeta({ pubkey: poolKeys.baseMint, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.quoteMint, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.baseVault, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.quoteVault, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.withdrawQueue }),\n    accountMeta({ pubkey: poolKeys.targetOrders }),\n    accountMeta({ pubkey: userKeys.lpTokenAccount }),\n    accountMeta({ pubkey: poolKeys.lpVault, isWritable: false }),\n    // serum\n    accountMeta({ pubkey: poolKeys.marketProgramId, isWritable: false }),\n    accountMeta({ pubkey: poolKeys.marketId, isWritable: false }),\n    // user\n    accountMeta({ pubkey: userKeys.payer, isSigner: true }),\n  ];\n\n  return new TransactionInstruction({\n    programId: poolKeys.programId,\n    keys,\n    data,\n  });\n}\n\nexport function makeAddLiquidityInstruction(params: LiquidityAddInstructionParams): TransactionInstruction {\n  const { poolKeys, userKeys, baseAmountIn, quoteAmountIn, fixedSide } = params;\n  const { version } = poolKeys;\n\n  if (version === 4 || version === 5) {\n    const data = Buffer.alloc(addLiquidityLayout.span);\n    addLiquidityLayout.encode(\n      {\n        instruction: 3,\n        baseAmountIn: parseBigNumberish(baseAmountIn),\n        quoteAmountIn: parseBigNumberish(quoteAmountIn),\n        fixedSide: parseBigNumberish(fixedSide === \"base\" ? 0 : 1),\n      },\n      data,\n    );\n\n    const keys = [\n      accountMeta({ pubkey: TOKEN_PROGRAM_ID, isWritable: false }),\n      // amm\n      accountMeta({ pubkey: poolKeys.id }),\n      accountMeta({ pubkey: poolKeys.authority, isWritable: false }),\n      accountMeta({ pubkey: poolKeys.openOrders, isWritable: false }),\n      accountMeta({ pubkey: poolKeys.targetOrders }),\n      accountMeta({ pubkey: poolKeys.lpMint }),\n      accountMeta({ pubkey: poolKeys.baseVault }),\n      accountMeta({ pubkey: poolKeys.quoteVault }),\n    ];\n\n    if (version === 5) {\n      keys.push(accountMeta({ pubkey: MODEL_DATA_PUBKEY }));\n    }\n\n    keys.push(\n      // serum\n      accountMeta({ pubkey: poolKeys.marketId, isWritable: false }),\n      // user\n      accountMeta({ pubkey: userKeys.baseTokenAccount }),\n      accountMeta({ pubkey: userKeys.quoteTokenAccount }),\n      accountMeta({ pubkey: userKeys.lpTokenAccount }),\n      accountMeta({ pubkey: userKeys.owner, isWritable: false, isSigner: true }),\n    );\n\n    return new TransactionInstruction({\n      programId: poolKeys.programId,\n      keys,\n      data,\n    });\n  }\n\n  logger.logWithError(\"invalid version\", \"poolKeys.version\", version);\n  return new TransactionInstruction({ programId: poolKeys.programId, keys: [] }); // won't reach\n}\n\nexport function makeRemoveLiquidityInstruction(params: LiquidityRemoveInstructionParams): TransactionInstruction {\n  const { poolKeys, userKeys, amountIn } = params;\n  const { version } = poolKeys;\n\n  if (version === 4 || version === 5) {\n    const data = Buffer.alloc(removeLiquidityLayout.span);\n    removeLiquidityLayout.encode(\n      {\n        instruction: 4,\n        amountIn: parseBigNumberish(amountIn),\n      },\n      data,\n    );\n\n    const keys = [\n      // system\n      accountMeta({ pubkey: TOKEN_PROGRAM_ID, isWritable: false }),\n      // amm\n      accountMeta({ pubkey: poolKeys.id }),\n      accountMeta({ pubkey: poolKeys.authority, isWritable: false }),\n      accountMeta({ pubkey: poolKeys.openOrders }),\n      accountMeta({ pubkey: poolKeys.targetOrders }),\n      accountMeta({ pubkey: poolKeys.lpMint }),\n      accountMeta({ pubkey: poolKeys.baseVault }),\n      accountMeta({ pubkey: poolKeys.quoteVault }),\n    ];\n\n    if (version === 5) {\n      keys.push(accountMeta({ pubkey: MODEL_DATA_PUBKEY }));\n    } else {\n      keys.push(accountMeta({ pubkey: poolKeys.withdrawQueue }), accountMeta({ pubkey: poolKeys.lpVault }));\n    }\n\n    keys.push(\n      // serum\n      accountMeta({ pubkey: poolKeys.marketProgramId, isWritable: false }),\n      accountMeta({ pubkey: poolKeys.marketId }),\n      accountMeta({ pubkey: poolKeys.marketBaseVault }),\n      accountMeta({ pubkey: poolKeys.marketQuoteVault }),\n      accountMeta({ pubkey: poolKeys.marketAuthority, isWritable: false }),\n      // user\n      accountMeta({ pubkey: userKeys.lpTokenAccount }),\n      accountMeta({ pubkey: userKeys.baseTokenAccount }),\n      accountMeta({ pubkey: userKeys.quoteTokenAccount }),\n      accountMeta({ pubkey: userKeys.owner, isWritable: false, isSigner: true }),\n      // serum orderbook\n      accountMeta({ pubkey: poolKeys.marketEventQueue }),\n      accountMeta({ pubkey: poolKeys.marketBids }),\n      accountMeta({ pubkey: poolKeys.marketAsks }),\n    );\n\n    return new TransactionInstruction({\n      programId: poolKeys.programId,\n      keys,\n      data,\n    });\n  }\n\n  logger.logWithError(\"invalid version\", \"poolKeys.version\", version);\n  return new TransactionInstruction({ programId: poolKeys.programId, keys: [] }); // won't reach\n}\n","import { PublicKey } from \"@solana/web3.js\";\nimport BN, { isBN } from \"bn.js\";\n\nimport {\n  bits, blob, Blob, Layout, offset as _offset, seq as _seq, Structure as _Structure, u32 as _u32, u8 as _u8, UInt,\n  union as _union, Union as _Union,\n} from \"./buffer-layout\";\n\nexport * from \"./buffer-layout\";\nexport { blob };\n\nexport class BNLayout<P extends string = \"\"> extends Layout<BN, P> {\n  blob: Layout<Buffer>;\n  signed: boolean;\n\n  constructor(span: number, signed: boolean, property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends, but it desn't matter\n    super(span, property);\n    this.blob = blob(span);\n    this.signed = signed;\n  }\n\n  /** @override */\n  decode(b: Buffer, offset = 0): BN {\n    const num = new BN(this.blob.decode(b, offset), 10, \"le\");\n    if (this.signed) {\n      return num.fromTwos(this.span * 8).clone();\n    }\n    return num;\n  }\n\n  /** @override */\n  encode(src: BN, b: Buffer, offset = 0): number {\n    if (typeof src === \"number\") src = new BN(src); // src will pass a number accidently in union\n    if (this.signed) {\n      src = src.toTwos(this.span * 8);\n    }\n    return this.blob.encode(src.toArrayLike(Buffer, \"le\", this.span), b, offset);\n  }\n}\n\nexport class WideBits<P extends string = \"\"> extends Layout<Record<string, boolean>, P> {\n  _lower: any;\n  _upper: any;\n  // TODO: unknown\n  constructor(property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\n    super(8, property);\n    this._lower = bits(_u32(), false);\n    this._upper = bits(_u32(), false);\n  }\n\n  addBoolean(property: string): void {\n    if (this._lower.fields.length < 32) {\n      this._lower.addBoolean(property);\n    } else {\n      this._upper.addBoolean(property);\n    }\n  }\n\n  decode(b: Buffer, offset = 0): Record<string, boolean> {\n    const lowerDecoded = this._lower.decode(b, offset);\n    const upperDecoded = this._upper.decode(b, offset + this._lower.span);\n    return { ...lowerDecoded, ...upperDecoded };\n  }\n\n  encode(src: any /* TEMP */, b: Buffer, offset = 0):any {\n    return this._lower.encode(src, b, offset) + this._upper.encode(src, b, offset + this._lower.span);\n  }\n}\n\nexport function u8<P extends string = \"\">(property?: P): UInt<number, P> {\n  return new UInt(1, property);\n}\n\nexport function u32<P extends string = \"\">(property?: P): UInt<number, P> {\n  return new UInt(4, property);\n}\n\nexport function u64<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(8, false, property);\n}\n\nexport function u128<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(16, false, property);\n}\n\nexport function i64<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(8, true, property);\n}\n\nexport function i128<P extends string = \"\">(property?: P): BNLayout<P> {\n  return new BNLayout(16, true, property);\n}\n\nexport class WrappedLayout<T, U, P extends string = \"\"> extends Layout<U, P> {\n  layout: Layout<T>;\n  decoder: (data: T) => U;\n  encoder: (src: U) => T;\n\n  constructor(layout: Layout<T>, decoder: (data: T) => U, encoder: (src: U) => T, property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\n    super(layout.span, property);\n    this.layout = layout;\n    this.decoder = decoder;\n    this.encoder = encoder;\n  }\n\n  decode(b: Buffer, offset?: number): U {\n    return this.decoder(this.layout.decode(b, offset));\n  }\n\n  encode(src: U, b: Buffer, offset?: number): number {\n    return this.layout.encode(this.encoder(src), b, offset);\n  }\n\n  getSpan(b: Buffer, offset?: number): number {\n    return this.layout.getSpan(b, offset);\n  }\n}\n\nexport function publicKey<P extends string = \"\">(property?: P): Layout<PublicKey, P> {\n  return new WrappedLayout(\n    blob(32),\n    (b: Buffer) => new PublicKey(b),\n    (key: PublicKey) => key.toBuffer(),\n    property,\n  );\n}\n\nexport class OptionLayout<T, P> extends Layout<T | null, P> {\n  layout: Layout<T>;\n  discriminator: Layout<number>;\n\n  constructor(layout: Layout<T>, property?: P) {\n    //@ts-expect-error type wrong for super()'s type different from extends , but it desn't matter\n    super(-1, property);\n    this.layout = layout;\n    this.discriminator = _u8();\n  }\n\n  encode(src: T | null, b: Buffer, offset = 0): number {\n    if (src === null || src === undefined) {\n      return this.discriminator.encode(0, b, offset);\n    }\n    this.discriminator.encode(1, b, offset);\n    return this.layout.encode(src, b, offset + 1) + 1;\n  }\n\n  decode(b: Buffer, offset = 0): T | null {\n    const discriminator = this.discriminator.decode(b, offset);\n    if (discriminator === 0) {\n      return null;\n    } else if (discriminator === 1) {\n      return this.layout.decode(b, offset + 1);\n    }\n    throw new Error(\"Invalid option \" + this.property);\n  }\n\n  getSpan(b: Buffer, offset = 0): number {\n    const discriminator = this.discriminator.decode(b, offset);\n    if (discriminator === 0) {\n      return 1;\n    } else if (discriminator === 1) {\n      return this.layout.getSpan(b, offset + 1) + 1;\n    }\n    throw new Error(\"Invalid option \" + this.property);\n  }\n}\n\nexport function option<T, P extends string = \"\">(layout: Layout<T>, property?: P): Layout<T | null, P> {\n  return new OptionLayout<T, P>(layout, property);\n}\n\nexport function bool<P extends string = \"\">(property?: P): Layout<boolean, P> {\n  return new WrappedLayout(_u8(), decodeBool, encodeBool, property);\n}\n\nexport function decodeBool(value: number): boolean {\n  if (value === 0) {\n    return false;\n  } else if (value === 1) {\n    return true;\n  }\n  throw new Error(\"Invalid bool: \" + value);\n}\n\nexport function encodeBool(value: boolean): number {\n  return value ? 1 : 0;\n}\n\nexport function vec<T, P extends string = \"\">(elementLayout: Layout<T>, property?: P): Layout<T[], P> {\n  const length = _u32(\"length\");\n  const layout: Layout<{ values: T[] }> = struct([\n    length,\n    seq(elementLayout, _offset(length, -length.span), \"values\"),\n  ]) as any; // Something I don't know\n  return new WrappedLayout(\n    layout,\n    ({ values }) => values,\n    (values) => ({ values }),\n    property,\n  );\n}\n\nexport function tagged<T, P extends string = \"\">(tag: BN, layout: Layout<T>, property?: P): Layout<T, P> {\n  const wrappedLayout: Layout<{ tag: BN; data: T }> = struct([u64(\"tag\"), layout.replicate(\"data\")]) as any; // Something I don't know\n\n  function decodeTag({ tag: receivedTag, data }: { tag: BN; data: T }): T {\n    if (!receivedTag.eq(tag)) {\n      throw new Error(\"Invalid tag, expected: \" + tag.toString(\"hex\") + \", got: \" + receivedTag.toString(\"hex\"));\n    }\n    return data;\n  }\n\n  return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);\n}\n\nexport function vecU8<P extends string = \"\">(property?: P): Layout<Buffer, P> {\n  const length = _u32(\"length\");\n  const layout: Layout<{ data: Buffer }> = struct([length, blob(_offset(length, -length.span), \"data\")]) as any; // Something I don't know\n  return new WrappedLayout(\n    layout,\n    ({ data }) => data,\n    (data) => ({ data }),\n    property,\n  );\n}\n\nexport function str<P extends string = \"\">(property?: P): Layout<string, P> {\n  return new WrappedLayout(\n    vecU8(),\n    (data) => data.toString(\"utf-8\"),\n    (s) => Buffer.from(s, \"utf-8\"),\n    property,\n  );\n}\n\nexport interface EnumLayout<T, P extends string = \"\"> extends Layout<T, P> {\n  registry: Record<string, Layout<any>>;\n}\n\nexport function rustEnum<T, P extends string = \"\">(variants: Layout<any>[], property?: P): EnumLayout<T, P> {\n  const unionLayout = _union(_u8(), property);\n  variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));\n  return unionLayout as any; // ?why use UnionLayout? This must be a fault\n}\n\nexport function array<T, P extends string = \"\">(\n  elementLayout: Layout<T>,\n  length: number,\n  property?: P,\n): Layout<T[], P> {\n  const layout = struct([seq(elementLayout, length, \"values\")]) as any as Layout<{ values: T[] }>; // Something I don't know\n  return new WrappedLayout(\n    layout,\n    ({ values }) => values,\n    (values) => ({ values }),\n    property,\n  );\n}\n\nexport class Structure<T, P, D> extends _Structure<T, P, D> {\n  /** @override */\n  decode(b: Buffer, offset?: number): D {\n    return super.decode(b, offset);\n  }\n}\n\nexport function struct<T, P extends string = \"\">(\n  fields: T,\n  property?: P,\n  decodePrefixes?: boolean,\n): T extends Layout<infer Value, infer Property>[]\n  ? Structure<\n      Value,\n      P,\n      {\n        [K in Exclude<Extract<Property, string>, \"\">]: Extract<T[number], Layout<any, K>> extends Layout<infer V, any>\n          ? V\n          : any;\n      }\n    >\n  : any {\n  //@ts-expect-error this type is not quite satisfied the define, but, never no need to worry about.\n  return new Structure(fields, property, decodePrefixes);\n}\n\nexport type GetLayoutSchemaFromStructure<T extends Structure<any, any, any>> = T extends Structure<any, any, infer S>\n  ? S\n  : any;\nexport type GetStructureFromLayoutSchema<S> = Structure<any, any, S>;\n\nexport class Union<Schema> extends _Union<Schema> {\n  encodeInstruction(instruction: any): Buffer {\n    const instructionMaxSpan = Math.max(...Object.values(this.registry).map((r) => r.span));\n    const b = Buffer.alloc(instructionMaxSpan);\n    return b.slice(0, this.encode(instruction, b));\n  }\n\n  decodeInstruction(instruction: any):Partial<Schema> {\n    return this.decode(instruction);\n  }\n}\nexport function union<UnionSchema extends { [key: string]: any } = any>(\n  discr: any,\n  defaultLayout?: any,\n  property?: string,\n): Union<UnionSchema> {\n  return new Union(discr, defaultLayout, property);\n}\n\nclass Zeros extends Blob {\n  decode(b: Buffer, offset: number):Buffer {\n    const slice = super.decode(b, offset);\n    if (!slice.every((v) => v === 0)) {\n      throw new Error(\"nonzero padding bytes\");\n    }\n    return slice;\n  }\n}\n\nexport function zeros(length: number):Zeros {\n  return new Zeros(length);\n}\n\nexport function seq<T, P extends string = \"\", AnotherP extends string = \"\">(\n  elementLayout: Layout<T, P>,\n  count: number | BN | Layout<BN | number, P>,\n  property?: AnotherP,\n): Layout<T[], AnotherP> {\n  let parsedCount: number;\n  const superCount =\n    typeof count === \"number\"\n      ? count\n      : isBN(count)\n      ? count.toNumber()\n      : new Proxy(count as unknown as Layout<number> /* pretend to be Layout<number> */, {\n          get(target, property):any {\n            if (!parsedCount) {\n              // get count in targetLayout. note that count may be BN\n              const countProperty = Reflect.get(target, \"count\");\n\n              // let targetLayout's  property:count be a number\n              parsedCount = isBN(countProperty) ? countProperty.toNumber() : countProperty;\n\n              // record the count\n              Reflect.set(target, \"count\", parsedCount);\n            }\n            return Reflect.get(target, property);\n          },\n          set(target, property, value):any {\n            if (property === \"count\") {\n              parsedCount = value;\n            }\n            return Reflect.set(target, property, value);\n          },\n        });\n\n  // @ts-expect-error force type\n  return _seq(elementLayout, superCount, property);\n}\n","import {\n  bits as _bits, BitStructure as _BitStructure, blob as _blob, Blob as _Blob, cstr as _cstr, f32 as _f32,\n  f32be as _f32be, f64 as _f64, f64be as _f64be, greedy as _greedy, Layout as _Layout, ns64 as _ns64, ns64be as _ns64be,\n  nu64 as _nu64, nu64be as _nu64be, offset as _offset, s16 as _s16, s16be as _s16be, s24 as _s24, s24be as _s24be,\n  s32 as _s32, s32be as _s32be, s40 as _s40, s40be as _s40be, s48 as _s48, s48be as _s48be, s8 as _s8, seq as _seq,\n  struct as _struct, Structure as _Structure, u16 as _u16, u16be as _u16be, u24 as _u24, u24be as _u24be, u32 as _u32,\n  u32be as _u32be, u40 as _u40, u40be as _u40be, u48 as _u48, u48be as _u48be, u8 as _u8, UInt as _UInt,\n  union as _union, Union as _Union, unionLayoutDiscriminator as _unionLayoutDiscriminator, utf8 as _utf8,\n} from \"@solana/buffer-layout\";\n\n//#region ------------------- Layout -------------------\nexport interface Layout<T = any, P = \"\"> {\n  span: number;\n  property?: P;\n  decode(b: Buffer, offset?: number): T;\n  encode(src: T, b: Buffer, offset?: number): number;\n  getSpan(b: Buffer, offset?: number): number;\n  replicate<AP extends string>(name: AP): Layout<T, AP>;\n}\nexport interface LayoutConstructor {\n  new <T, P>(): Layout<T, P>; // for class extends syntex\n  new <T, P>(span?: T, property?: P): Layout<T, P>;\n  readonly prototype: Layout;\n}\nexport const Layout = _Layout as unknown as LayoutConstructor;\n//#endregion\n\n//#region ------------------- Structure -------------------\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface Structure<T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>\n  extends Layout<DecodeSchema, P> {\n  span: number;\n  decode(b: Buffer, offset?: number): DecodeSchema;\n  layoutFor<AP extends string>(property: AP): Layout<DecodeSchema[AP]>;\n  offsetOf<AP extends string>(property: AP): number;\n}\ninterface StructureConstructor {\n  new <T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>(): Structure<T, P, DecodeSchema>;\n  new <T = any, P = \"\", DecodeSchema extends { [key: string]: any } = any>(\n    fields: T,\n    property?: P,\n    decodePrefixes?: boolean,\n  ): Structure<T, P, DecodeSchema>;\n}\nexport const Structure = _Structure as unknown as StructureConstructor;\n//#endregion\n\n//#region ------------------- Union -------------------\nexport interface Union<UnionSchema extends { [key: string]: any } = any> extends Layout {\n  registry: object;\n  decode(b: Buffer, offset?: number): Partial<UnionSchema>;\n  addVariant(\n    variant: number,\n    layout: Structure<any, any, Partial<UnionSchema>> | Layout<any, keyof UnionSchema>,\n    property?: string,\n  ): any /* TEMP: code in Layout.js 1809 */;\n}\ninterface UnionConstructor {\n  new <UnionSchema extends { [key: string]: any } = any>(): Union<UnionSchema>;\n  new <UnionSchema extends { [key: string]: any } = any>(\n    discr: Layout<any, any>,\n    defaultLayout: Layout<any, any>,\n    property?: string,\n  ): Union<UnionSchema>;\n}\nexport const Union = _Union as unknown as UnionConstructor;\n//#endregion\n\n//#region ------------------- BitStructure -------------------\nexport type BitStructure<T = unknown /* TEMP */, P = \"\"> = Layout<T, P>;\ninterface BitStructureConstructor {\n  new (...params: any[]): BitStructure;\n}\nexport const BitStructure = _BitStructure as BitStructureConstructor;\n//#endregion\n\n//#region ------------------- UInt -------------------\nexport type UInt<T = any, P = \"\"> = Layout<T, P>;\ninterface UIntConstructor {\n  new <T, P>(span?: T, property?: P): UInt<T, P>;\n}\nexport const UInt = _UInt as UIntConstructor;\n//#endregion\n\n//#region ------------------- Blob -------------------\nexport type Blob<P extends string = \"\"> = Layout<Buffer, P>;\ninterface BlobConstructor {\n  new (...params: ConstructorParameters<LayoutConstructor>): Blob;\n}\nexport const Blob = _Blob as unknown as BlobConstructor;\n//#endregion\n\nexport const greedy = _greedy as <P extends string = \"\">(elementSpan?: number, property?: P) => Layout<number, P>;\nexport const u8 = _u8 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u16 = _u16 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u24 = _u24 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u32 = _u32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u40 = _u40 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u48 = _u48 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const nu64 = _nu64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u16be = _u16be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u24be = _u24be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u32be = _u32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u40be = _u40be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const u48be = _u48be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const nu64be = _nu64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s8 = _s8 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s16 = _s16 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s24 = _s24 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s32 = _s32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s40 = _s40 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s48 = _s48 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const ns64 = _ns64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s16be = _s16be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s24be = _s24be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s32be = _s32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s40be = _s40be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const s48be = _s48be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const ns64be = _ns64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f32 = _f32 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f32be = _f32be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f64 = _f64 as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const f64be = _f64be as <P extends string = \"\">(property?: P) => Layout<number, P>;\nexport const struct = _struct as <T, P extends string = \"\">(\n  fields: T,\n  property?: P,\n  decodePrefixes?: boolean,\n) => T extends Layout<infer Value, infer Property>[]\n  ? Structure<\n      Value,\n      P,\n      {\n        [K in Exclude<Extract<Property, string>, \"\">]: Extract<T[number], Layout<any, K>> extends Layout<infer V, any>\n          ? V\n          : any;\n      }\n    >\n  : any;\n\nexport const seq = _seq as unknown as <T, P>(\n  elementLayout: Layout<T, string>,\n  count: number | Layout<number, string>,\n  property?: P,\n) => Layout<T[]>;\nexport const union = _union as <UnionSchema extends { [key: string]: any } = any>(\n  discr: Layout<any, any>,\n  defaultLayout?: any,\n  property?: string,\n) => Union<UnionSchema>;\nexport const unionLayoutDiscriminator = _unionLayoutDiscriminator as <P extends string = \"\">(\n  layout: Layout<any, P>,\n  property?: P,\n) => any;\nexport const blob = _blob as unknown as <P extends string = \"\">(length: number | Layout<number, P>, property?: P) => Blob<P>;\nexport const cstr = _cstr as <P extends string = \"\">(property?: P) => Layout<string, P>;\nexport const utf8 = _utf8 as <P extends string = \"\">(maxSpan: number, property?: P) => Layout<string, P>;\nexport const bits = _bits as unknown as <T, P extends string = \"\">(\n  word: Layout<T>,\n  msb?: boolean,\n  property?: P,\n) => BitStructure<T, P>; // TODO: not quite sure\nexport const offset = _offset as unknown as <T, P extends string = \"\">(\n  layout: Layout<T, P>,\n  offset?: number,\n  property?: P,\n) => Layout<T, P>;\n\nexport type GetStructureSchema<T extends Structure> = T extends Structure<any, any, infer S> ? S : unknown;\n","import { GetStructureSchema, publicKey, seq, struct, u128, u64, u8 } from \"../../marshmallow\";\n\nexport const fixedSwapInLayout = struct([u8(\"instruction\"), u64(\"amountIn\"), u64(\"minAmountOut\")]);\nexport const fixedSwapOutLayout = struct([u8(\"instruction\"), u64(\"maxAmountIn\"), u64(\"amountOut\")]);\n\nexport const createPoolV4Layout = struct([u8(\"instruction\"), u8(\"nonce\")]);\nexport const initPoolLayout = struct([u8(\"instruction\"), u8(\"nonce\"), u64(\"startTime\")]);\n/* ================= state layouts ================= */\nexport const liquidityStateV4Layout = struct([\n  u64(\"status\"),\n  u64(\"nonce\"),\n  u64(\"maxOrder\"),\n  u64(\"depth\"),\n  u64(\"baseDecimal\"),\n  u64(\"quoteDecimal\"),\n  u64(\"state\"),\n  u64(\"resetFlag\"),\n  u64(\"minSize\"),\n  u64(\"volMaxCutRatio\"),\n  u64(\"amountWaveRatio\"),\n  u64(\"baseLotSize\"),\n  u64(\"quoteLotSize\"),\n  u64(\"minPriceMultiplier\"),\n  u64(\"maxPriceMultiplier\"),\n  u64(\"systemDecimalValue\"),\n  u64(\"minSeparateNumerator\"),\n  u64(\"minSeparateDenominator\"),\n  u64(\"tradeFeeNumerator\"),\n  u64(\"tradeFeeDenominator\"),\n  u64(\"pnlNumerator\"),\n  u64(\"pnlDenominator\"),\n  u64(\"swapFeeNumerator\"),\n  u64(\"swapFeeDenominator\"),\n  u64(\"baseNeedTakePnl\"),\n  u64(\"quoteNeedTakePnl\"),\n  u64(\"quoteTotalPnl\"),\n  u64(\"baseTotalPnl\"),\n  u128(\"quoteTotalDeposited\"),\n  u128(\"baseTotalDeposited\"),\n  u128(\"swapBaseInAmount\"),\n  u128(\"swapQuoteOutAmount\"),\n  u64(\"swapBase2QuoteFee\"),\n  u128(\"swapQuoteInAmount\"),\n  u128(\"swapBaseOutAmount\"),\n  u64(\"swapQuote2BaseFee\"),\n  // amm vault\n  publicKey(\"baseVault\"),\n  publicKey(\"quoteVault\"),\n  // mint\n  publicKey(\"baseMint\"),\n  publicKey(\"quoteMint\"),\n  publicKey(\"lpMint\"),\n  // market\n  publicKey(\"openOrders\"),\n  publicKey(\"marketId\"),\n  publicKey(\"marketProgramId\"),\n  publicKey(\"targetOrders\"),\n  publicKey(\"withdrawQueue\"),\n  publicKey(\"lpVault\"),\n  publicKey(\"owner\"),\n  // true circulating supply without lock up\n  u64(\"lpReserve\"),\n  seq(u64(), 3, \"padding\"),\n]);\n\nexport type LiquidityStateLayoutV4 = typeof liquidityStateV4Layout;\nexport type LiquidityStateV4 = GetStructureSchema<LiquidityStateLayoutV4>;\n\nexport const liquidityStateV5Layout = struct([\n  u64(\"accountType\"),\n  u64(\"status\"),\n  u64(\"nonce\"),\n  u64(\"maxOrder\"),\n  u64(\"depth\"),\n  u64(\"baseDecimal\"),\n  u64(\"quoteDecimal\"),\n  u64(\"state\"),\n  u64(\"resetFlag\"),\n  u64(\"minSize\"),\n  u64(\"volMaxCutRatio\"),\n  u64(\"amountWaveRatio\"),\n  u64(\"baseLotSize\"),\n  u64(\"quoteLotSize\"),\n  u64(\"minPriceMultiplier\"),\n  u64(\"maxPriceMultiplier\"),\n  u64(\"systemDecimalsValue\"),\n  u64(\"abortTradeFactor\"),\n  u64(\"priceTickMultiplier\"),\n  u64(\"priceTick\"),\n  // Fees\n  u64(\"minSeparateNumerator\"),\n  u64(\"minSeparateDenominator\"),\n  u64(\"tradeFeeNumerator\"),\n  u64(\"tradeFeeDenominator\"),\n  u64(\"pnlNumerator\"),\n  u64(\"pnlDenominator\"),\n  u64(\"swapFeeNumerator\"),\n  u64(\"swapFeeDenominator\"),\n  // OutPutData\n  u64(\"baseNeedTakePnl\"),\n  u64(\"quoteNeedTakePnl\"),\n  u64(\"quoteTotalPnl\"),\n  u64(\"baseTotalPnl\"),\n  u64(\"poolOpenTime\"),\n  u64(\"punishPcAmount\"),\n  u64(\"punishCoinAmount\"),\n  u64(\"orderbookToInitTime\"),\n  u128(\"swapBaseInAmount\"),\n  u128(\"swapQuoteOutAmount\"),\n  u128(\"swapQuoteInAmount\"),\n  u128(\"swapBaseOutAmount\"),\n  u64(\"swapQuote2BaseFee\"),\n  u64(\"swapBase2QuoteFee\"),\n\n  publicKey(\"baseVault\"),\n  publicKey(\"quoteVault\"),\n  publicKey(\"baseMint\"),\n  publicKey(\"quoteMint\"),\n  publicKey(\"lpMint\"),\n\n  publicKey(\"modelDataAccount\"),\n  publicKey(\"openOrders\"),\n  publicKey(\"marketId\"),\n  publicKey(\"marketProgramId\"),\n  publicKey(\"targetOrders\"),\n  publicKey(\"owner\"),\n  seq(u64(), 64, \"padding\"),\n]);\n\nexport const addLiquidityLayout = struct([\n  u8(\"instruction\"),\n  u64(\"baseAmountIn\"),\n  u64(\"quoteAmountIn\"),\n  u64(\"fixedSide\"),\n]);\n\nexport const removeLiquidityLayout = struct([u8(\"instruction\"), u64(\"amountIn\")]);\n\nexport type LiquidityStateLayoutV5 = typeof liquidityStateV5Layout;\nexport type LiquidityStateV5 = GetStructureSchema<LiquidityStateLayoutV5>;\n\nexport type LiquidityState = LiquidityStateV4 | LiquidityStateV5;\nexport type LiquidityStateLayout = LiquidityStateLayoutV4 | LiquidityStateLayoutV5;\n\n/* ================= index ================= */\n// version => liquidity state layout\nexport const LIQUIDITY_VERSION_TO_STATE_LAYOUT: {\n  [version: number]: LiquidityStateLayout;\n} = {\n  4: liquidityStateV4Layout,\n  5: liquidityStateV5Layout,\n};\n","import { Connection, PublicKey } from \"@solana/web3.js\";\n\nimport { seq, struct, u64 } from \"../../marshmallow\";\n\nexport const MODEL_DATA_PUBKEY = new PublicKey(\"CDSr3ssLcRB6XYPJwAfFt18MZvEZp4LjHcvzBVZ45duo\");\nconst ELEMENT_SIZE = 50000;\n\nexport const DataElement = struct([u64(\"x\"), u64(\"y\"), u64(\"price\")]);\n\nexport const modelDataInfoLayout = struct([\n  u64(\"accountType\"),\n  u64(\"status\"),\n  u64(\"multiplier\"),\n  u64(\"validDataCount\"),\n  seq(DataElement, ELEMENT_SIZE, \"DataElement\"),\n]);\n\nexport interface StableModelLayout {\n  accountType: number;\n  status: number;\n  multiplier: number;\n  validDataCount: number;\n  DataElement: { x: number; y: number; price: number }[];\n}\n\nfunction estimateRangeByXyReal(_xReal: number, _yReal: number): number[] {\n  return [0, ELEMENT_SIZE - 2];\n}\n\nfunction estimateRangeByX(_x: number): number[] {\n  return [0, ELEMENT_SIZE - 2];\n}\n\nfunction estimateRangeByY(_y: number): number[] {\n  return [0, ELEMENT_SIZE - 2];\n}\n\nfunction getMininumRangeByXyReal(\n  layoutData: StableModelLayout,\n  xReal: number,\n  yReal: number,\n): [number, number, boolean] {\n  const [min, max] = estimateRangeByXyReal(xReal, yReal);\n  let minRangeIdx = min;\n  let maxRangeIdx = max;\n  let mid = 0;\n  const target = (xReal * layoutData.multiplier) / yReal;\n  while (minRangeIdx <= maxRangeIdx) {\n    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);\n    if (mid === 0 || mid >= ELEMENT_SIZE - 2) {\n      return [mid, mid, false];\n    }\n    const cur = (layoutData.DataElement[mid].x * layoutData.multiplier) / layoutData.DataElement[mid].y;\n    const left = (layoutData.DataElement[mid - 1].x * layoutData.multiplier) / layoutData.DataElement[mid - 1].y;\n    const right = (layoutData.DataElement[mid + 1].x * layoutData.multiplier) / layoutData.DataElement[mid + 1].y;\n\n    if (target === cur) {\n      return [mid, mid, true];\n    } else if (target === left) {\n      return [mid - 1, mid - 1, true];\n    } else if (target === right) {\n      return [mid + 1, mid + 1, true];\n    } else if (target < left) {\n      maxRangeIdx = mid - 1;\n    } else if (target > left && target < cur) {\n      return [mid - 1, mid, true];\n    } else if (target > cur && target < right) {\n      return [mid, mid + 1, true];\n    } else {\n      minRangeIdx = mid + 1;\n    }\n  }\n  return [mid, mid, false];\n}\nfunction getRatio(layoutData: StableModelLayout, xReal: number, yReal: number): number {\n  const [minRangeIdx, maxRangeIdx, find] = getMininumRangeByXyReal(layoutData, xReal, yReal);\n\n  if (!find) {\n    return 0;\n  }\n\n  if (minRangeIdx === maxRangeIdx) {\n    const x = layoutData.DataElement[minRangeIdx].x;\n    const ratio = (xReal * layoutData.multiplier) / x;\n    return ratio;\n  } else {\n    const x1 = layoutData.DataElement[minRangeIdx].x;\n    const y1 = layoutData.DataElement[minRangeIdx].y;\n    const x2 = layoutData.DataElement[maxRangeIdx].x;\n    const y2 = layoutData.DataElement[maxRangeIdx].y;\n\n    const xDenominator = yReal * (x2 * y1 - x1 * y2);\n    const xNumerator1 = x1 * xDenominator;\n    const xNumerator2 = (x2 - x1) * (xReal * y1 - x1 * yReal) * y2;\n\n    const xNumerator = xNumerator1 + xNumerator2;\n    const ratio = (xReal * layoutData.multiplier * xDenominator) / xNumerator;\n    return ratio;\n  }\n}\n\nfunction realToTable(layoutData: StableModelLayout, realValue: number, ratio: number): number {\n  return (realValue * layoutData.multiplier) / ratio;\n}\n\nfunction tableToReal(layoutData: StableModelLayout, tableValue: number, ratio: number): number {\n  return (tableValue * ratio) / layoutData.multiplier;\n}\n\nfunction getMinimumRangeByX(layoutData: StableModelLayout, x: number): [number, number, boolean] {\n  const [min, max] = estimateRangeByX(x);\n  let minRangeIdx = min;\n  let maxRangeIdx = max;\n  let mid = 0;\n  const target = x;\n  while (minRangeIdx < maxRangeIdx) {\n    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);\n\n    if (mid <= 0 || mid > ELEMENT_SIZE - 2) {\n      return [mid, mid, false];\n    }\n    const cur = layoutData.DataElement[mid].x;\n    const left = layoutData.DataElement[mid - 1].x;\n    const right = layoutData.DataElement[mid + 1].x;\n\n    if (target === cur) return [mid, mid, true];\n    else if (target === left) return [mid - 1, mid - 1, true];\n    else if (target === right) return [mid + 1, mid + 1, true];\n    else if (target < left) maxRangeIdx = mid - 1;\n    else if (target > left && target < cur) return [mid - 1, mid, true];\n    else if (target > cur && target < right) return [mid, mid + 1, true];\n    else minRangeIdx = mid + 1;\n  }\n  return [mid, mid, false];\n}\n\nfunction getMinimumRangeByY(layoutData: StableModelLayout, y: number): [number, number, boolean] {\n  const [min, max] = estimateRangeByY(y);\n  let minRangeIdx = min;\n  let maxRangeIdx = max;\n  let mid = 0;\n  const target = y;\n  while (minRangeIdx <= maxRangeIdx) {\n    mid = Math.floor((maxRangeIdx + minRangeIdx) / 2);\n    if (mid <= 0 || mid >= ELEMENT_SIZE - 2) {\n      return [mid, mid, false];\n    }\n\n    const cur = layoutData.DataElement[mid].y;\n    const left = layoutData.DataElement[mid - 1].y;\n    const right = layoutData.DataElement[mid + 1].y;\n    if (target === cur) return [mid, mid, true];\n    else if (target === left) return [mid - 1, mid - 1, true];\n    else if (target === right) return [mid + 1, mid + 1, true];\n    else if (target < right) {\n      minRangeIdx = mid + 1;\n    } else if (target < left && target > cur) return [mid - 1, mid, true];\n    else if (target < cur && target > right) return [mid, mid + 1, true];\n    else maxRangeIdx = mid - 1;\n  }\n  return [mid, mid, false];\n}\n\nfunction getDataByX(\n  layoutData: StableModelLayout,\n  x: number,\n  dx: number,\n  priceUp: boolean,\n): [number, number, boolean, boolean] {\n  const xWithDx = priceUp ? x + dx : x - dx;\n  const [minIdx, maxIdx, find] = getMinimumRangeByX(layoutData, xWithDx);\n  if (!find) return [0, 0, false, find];\n\n  if (minIdx === maxIdx) return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].y, false, find];\n  else {\n    const x1 = layoutData.DataElement[minIdx].x;\n    const x2 = layoutData.DataElement[maxIdx].x;\n    const p1 = layoutData.DataElement[minIdx].price;\n    const p2 = layoutData.DataElement[maxIdx].price;\n    const y1 = layoutData.DataElement[minIdx].y;\n    const y2 = layoutData.DataElement[maxIdx].y;\n\n    if (x >= x1 && x <= x2) {\n      if (priceUp) return [p2, y2, true, find];\n      else return [p1, y1, true, find];\n    } else {\n      let p, y;\n      if (priceUp) {\n        p = p1 + ((p2 - p1) * (x - x1)) / (x2 - x1);\n        y = y1 - ((xWithDx - x1) * layoutData.multiplier) / p2;\n      } else {\n        p = p1 + ((p2 - p1) * (x - x1)) / (x2 - x1);\n        y = y2 + ((x2 - xWithDx) * layoutData.multiplier) / p1;\n      }\n      return [p, y, false, find];\n    }\n  }\n}\n\nfunction getDataByY(\n  layoutData: StableModelLayout,\n  y: number,\n  dy: number,\n  priceUp: boolean,\n): [number, number, boolean, boolean] {\n  const yWithDy = priceUp ? y - dy : y + dy;\n  const [minIdx, maxIdx, find] = getMinimumRangeByY(layoutData, yWithDy);\n  if (!find) return [0, 0, false, find];\n  if (minIdx === maxIdx) return [layoutData.DataElement[maxIdx].price, layoutData.DataElement[maxIdx].x, false, find];\n  else {\n    const x1 = layoutData.DataElement[minIdx].x;\n    const x2 = layoutData.DataElement[maxIdx].x;\n    const p1 = layoutData.DataElement[minIdx].price;\n    const p2 = layoutData.DataElement[maxIdx].price;\n    const y1 = layoutData.DataElement[minIdx].y;\n    const y2 = layoutData.DataElement[maxIdx].y;\n\n    if (y >= y2 && y <= y1) {\n      return priceUp ? [p2, x2, true, find] : [p1, x1, true, find];\n    } else {\n      let p, x;\n      if (priceUp) {\n        p = p1 + ((p2 - p1) * (y1 - y)) / (y1 - y2);\n        x = x1 + (p2 * (y1 - yWithDy)) / layoutData.multiplier;\n      } else {\n        p = p1 + ((p2 - p1) * (y1 - y)) / (y1 - y2);\n        x = x2 - (p1 * (yWithDy - y2)) / layoutData.multiplier;\n      }\n      return [p, x, false, find];\n    }\n  }\n}\n\nfunction getMidPrice(layoutData: StableModelLayout, x: number): number {\n  const ret = getDataByX(layoutData, x, 0, false);\n  if (ret[3]) return ret[0];\n  else return 0;\n}\n\nexport function getDyByDxBaseIn(layoutData: StableModelLayout, xReal: number, yReal: number, dxReal: number): number {\n  const ratio = getRatio(layoutData, xReal, yReal);\n  const x = realToTable(layoutData, xReal, ratio);\n  const y = realToTable(layoutData, yReal, ratio);\n  const dx = realToTable(layoutData, dxReal, ratio);\n  const priceUp = true;\n  const [p, y2, lessTrade, find] = getDataByX(layoutData, x, dx, priceUp);\n  if (!find) return 0;\n  if (lessTrade) {\n    const dyReal = (dxReal * layoutData.multiplier) / p;\n    return dyReal;\n  } else {\n    const dy = y - y2;\n    const dyReal = tableToReal(layoutData, dy, ratio);\n    return dyReal;\n  }\n}\n\nexport function getDxByDyBaseIn(layoutData: StableModelLayout, xReal: number, yReal: number, dyReal: number): number {\n  const ratio = getRatio(layoutData, xReal, yReal);\n  const x = realToTable(layoutData, xReal, ratio);\n  const y = realToTable(layoutData, yReal, ratio);\n  const dy = realToTable(layoutData, dyReal, ratio);\n  const priceUp = false;\n  const [p, x2, lessTrade, find] = getDataByY(layoutData, y, dy, priceUp);\n  if (!find) return 0;\n  if (lessTrade) {\n    const dxReal = (dyReal * p) / layoutData.multiplier;\n    return dxReal;\n  } else {\n    const dx = x - x2;\n    const dxReal = tableToReal(layoutData, dx, ratio);\n    return dxReal;\n  }\n}\n\nexport function formatLayout(buffer: Buffer): StableModelLayout {\n  const layoutInfo = modelDataInfoLayout.decode(buffer);\n  return {\n    accountType: layoutInfo.accountType.toNumber(),\n    status: layoutInfo.status.toNumber(),\n    multiplier: layoutInfo.multiplier.toNumber(),\n    validDataCount: layoutInfo.validDataCount.toNumber(),\n    DataElement: layoutInfo.DataElement.map((item: any) => ({\n      x: item.x.toNumber(),\n      y: item.y.toNumber(),\n      price: item.price.toNumber(),\n    })),\n  };\n}\n\nexport function getStablePrice(\n  layoutData: StableModelLayout,\n  coinReal: number,\n  pcReal: number,\n  baseCoin: boolean,\n): number {\n  const price =\n    getMidPrice(layoutData, realToTable(layoutData, coinReal, getRatio(layoutData, coinReal, pcReal))) /\n    layoutData.multiplier;\n  return baseCoin ? price : 1 / price;\n}\n\nexport class StableLayout {\n  private readonly connection: Connection;\n  private _layoutData: StableModelLayout = {\n    accountType: 0,\n    status: 0,\n    multiplier: 0,\n    validDataCount: 0,\n    DataElement: [],\n  };\n\n  constructor({ connection }: { connection: Connection }) {\n    this.connection = connection;\n  }\n\n  get stableModelData(): StableModelLayout {\n    return this._layoutData;\n  }\n\n  public async initStableModelLayout(): Promise<void> {\n    if (this._layoutData.validDataCount === 0) {\n      if (this.connection) {\n        const acc = await this.connection.getAccountInfo(MODEL_DATA_PUBKEY);\n        if (acc) this._layoutData = formatLayout(acc?.data);\n      }\n    }\n  }\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { SerumVersion } from \"../../api\";\nimport { createLogger } from \"../../common/logger\";\n\nimport { LIQUIDITY_VERSION_TO_SERUM_VERSION } from \"./constant\";\n\nconst logger = createLogger(\"Raydium_liquidity_serum\");\n\n/* ================= program public keys ================= */\nexport const _SERUM_PROGRAM_ID_V3 = \"9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin\";\nexport const SERUM_PROGRAM_ID_V3 = new PublicKey(_SERUM_PROGRAM_ID_V3);\n\n// serum program id string => serum version\nexport const SERUM_PROGRAMID_TO_VERSION: {\n  [key: string]: SerumVersion;\n} = {\n  [_SERUM_PROGRAM_ID_V3]: 3,\n};\n\n// serum version => serum program id\nexport const SERUM_VERSION_TO_PROGRAM_ID: { [key in SerumVersion]?: PublicKey } & {\n  [K: number]: PublicKey;\n} = {\n  3: SERUM_PROGRAM_ID_V3,\n};\n\nexport function getSerumVersion(version: number): SerumVersion {\n  const serumVersion = LIQUIDITY_VERSION_TO_SERUM_VERSION[version];\n  if (!serumVersion) logger.logWithError(\"invalid version\", \"version\", version);\n\n  return serumVersion;\n}\n\nexport function getSerumProgramId(version: number): PublicKey {\n  const programId = SERUM_VERSION_TO_PROGRAM_ID[version];\n  if (!programId) logger.logWithError(\"invalid version\", \"version\", version);\n\n  return programId;\n}\n\nexport async function getSerumAssociatedAuthority({\n  programId,\n  marketId,\n}: {\n  programId: PublicKey;\n  marketId: PublicKey;\n}): Promise<{ publicKey: PublicKey; nonce: number }> {\n  const seeds = [marketId.toBuffer()];\n\n  let nonce = 0;\n  let publicKey: PublicKey;\n\n  while (nonce < 100) {\n    try {\n      const seedsWithNonce = seeds.concat(Buffer.from([nonce]), Buffer.alloc(7));\n      publicKey = await PublicKey.createProgramAddress(seedsWithNonce, programId);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw err;\n      }\n      nonce++;\n      continue;\n    }\n    return { publicKey, nonce };\n  }\n\n  logger.logWithError(\"unable to find a viable program address nonce\", \"params\", {\n    programId,\n    marketId,\n  });\n  throw new Error(\"unable to find a viable program address nonce\");\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { createLogger, Logger } from \"../common/logger\";\nimport { TxBuilder } from \"../common/txTool\";\n\nimport { Raydium } from \"./\";\n\nexport interface ModuleBaseProps {\n  scope: Raydium;\n  moduleName: string;\n}\n\nconst joinMsg = (...args: (string | number | Record<string, any>)[]): string =>\n  args\n    .map((arg) => {\n      try {\n        return typeof arg === \"object\" ? JSON.stringify(arg) : arg;\n      } catch {\n        return arg;\n      }\n    })\n    .join(\", \");\nexport default class ModuleBase {\n  public scope: Raydium;\n  private disabled = false;\n  protected logger: Logger;\n\n  constructor({ scope, moduleName }: ModuleBaseProps) {\n    this.scope = scope;\n    this.logger = createLogger(moduleName);\n  }\n\n  protected createTxBuilder(feePayer?: PublicKey): TxBuilder {\n    this.scope.checkOwner();\n    return new TxBuilder({\n      connection: this.scope.connection,\n      feePayer: feePayer || this.scope.ownerPubKey,\n      owner: this.scope.owner,\n      signAllTransactions: this.scope.signAllTransactions,\n    });\n  }\n\n  public logDebug(...args: (string | number | Record<string, any>)[]): void {\n    this.logger.debug(joinMsg(args));\n  }\n\n  public logInfo(...args: (string | number | Record<string, any>)[]): void {\n    this.logger.info(joinMsg(args));\n  }\n\n  public logAndCreateError(...args: (string | number | Record<string, any>)[]): void {\n    const message = joinMsg(args);\n    // this.logger.error(message);\n    throw new Error(message);\n  }\n\n  public checkDisabled(): void {\n    if (this.disabled || !this.scope) this.logAndCreateError(\"module not working\");\n  }\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport {\n  ETHMint,\n  mSOLMint,\n  PAIMint,\n  RAYMint,\n  stSOLMint,\n  USDCMint,\n  USDHMint,\n  USDTMint,\n  WSOLMint,\n} from \"../../common/pubKey\";\n\nexport const _ROUTE_PROGRAM_ID_V1 = \"routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS\";\nexport const ROUTE_PROGRAM_ID_V1 = new PublicKey(_ROUTE_PROGRAM_ID_V1);\n\nexport const defaultRoutes = [\"amm\", \"serum\", \"route\"];\n\nexport const swapRouteMiddleMints = [\n  USDCMint,\n  RAYMint,\n  WSOLMint,\n  mSOLMint,\n  PAIMint,\n  stSOLMint,\n  USDHMint,\n  USDTMint,\n  ETHMint,\n].map((pubKey) => pubKey.toBase58());\n","import { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { SystemProgram, TransactionInstruction } from \"@solana/web3.js\";\n\nimport { parseBigNumberish } from \"../../common/bignumber\";\nimport { createLogger } from \"../../common/logger\";\nimport { accountMeta } from \"../../common/pubKey\";\nimport { MODEL_DATA_PUBKEY } from \"../liquidity/stable\";\n\nimport { ROUTE_PROGRAM_ID_V1 } from \"./constant\";\nimport { routeSwapInLayout, routeSwapOutLayout } from \"./layout\";\nimport {\n  RouteSwapInFixedInInstructionParams,\n  RouteSwapInstructionParams,\n  RouteSwapOutFixedInInstructionParams,\n} from \"./type\";\n\nconst logger = createLogger(\"Raydium_route_instruction\");\nexport function makeRouteSwapInstruction(params: RouteSwapInstructionParams): TransactionInstruction[] {\n  const { fixedSide } = params;\n\n  if (fixedSide === \"in\") {\n    return [makeSwapInFixedInInstruction(params), makeSwapOutFixedInInstruction(params)];\n  }\n\n  logger.logWithError(\"invalid params\", \"params\", params);\n  throw new Error(`invalid params, params: ${params}`);\n}\n\nexport function makeSwapInFixedInInstruction({\n  fromPoolKeys,\n  toPoolKeys,\n  userKeys,\n  amountIn,\n  amountOut,\n}: RouteSwapInFixedInInstructionParams): TransactionInstruction {\n  const data = Buffer.alloc(routeSwapInLayout.span);\n\n  let keys;\n\n  if (fromPoolKeys.version === 4) {\n    routeSwapInLayout.encode(\n      {\n        instruction: 0,\n        amountIn: parseBigNumberish(amountIn),\n        amountOut: parseBigNumberish(amountOut),\n      },\n      data,\n    );\n    keys = [\n      // system\n      accountMeta({ pubkey: SystemProgram.programId, isWritable: false }),\n      accountMeta({ pubkey: TOKEN_PROGRAM_ID, isWritable: false }),\n      // amm\n      accountMeta({ pubkey: fromPoolKeys.programId, isWritable: false }),\n      accountMeta({ pubkey: fromPoolKeys.id }),\n      accountMeta({ pubkey: toPoolKeys.id, isWritable: false }),\n      accountMeta({ pubkey: fromPoolKeys.authority, isWritable: false }),\n      accountMeta({ pubkey: fromPoolKeys.openOrders }),\n      accountMeta({ pubkey: fromPoolKeys.baseVault }),\n      accountMeta({ pubkey: fromPoolKeys.quoteVault }),\n      // serum\n      accountMeta({ pubkey: fromPoolKeys.marketProgramId, isWritable: false }),\n      accountMeta({ pubkey: fromPoolKeys.marketId }),\n      accountMeta({ pubkey: fromPoolKeys.marketBids }),\n      accountMeta({ pubkey: fromPoolKeys.marketAsks }),\n      accountMeta({ pubkey: fromPoolKeys.marketEventQueue }),\n      accountMeta({ pubkey: fromPoolKeys.marketBaseVault }),\n      accountMeta({ pubkey: fromPoolKeys.marketQuoteVault }),\n      accountMeta({ pubkey: fromPoolKeys.marketAuthority, isWritable: false }),\n      // user\n      accountMeta({ pubkey: userKeys.inTokenAccount }),\n      accountMeta({ pubkey: userKeys.middleTokenAccount }),\n      accountMeta({ pubkey: userKeys.middleStatusAccount }),\n      accountMeta({ pubkey: userKeys.owner, isWritable: false, isSigner: true }),\n    ];\n  } else {\n    routeSwapInLayout.encode(\n      {\n        instruction: 2,\n        amountIn: parseBigNumberish(amountIn),\n        amountOut: parseBigNumberish(amountOut),\n      },\n      data,\n    );\n    keys = [\n      // system\n      accountMeta({ pubkey: SystemProgram.programId, isWritable: false }),\n      accountMeta({ pubkey: TOKEN_PROGRAM_ID, isWritable: false }),\n      // amm\n      accountMeta({ pubkey: fromPoolKeys.programId, isWritable: false }),\n      accountMeta({ pubkey: fromPoolKeys.id }),\n      accountMeta({ pubkey: toPoolKeys.id, isWritable: false }),\n      accountMeta({ pubkey: fromPoolKeys.authority, isWritable: false }),\n      accountMeta({ pubkey: fromPoolKeys.openOrders }),\n      accountMeta({ pubkey: fromPoolKeys.baseVault }),\n      accountMeta({ pubkey: fromPoolKeys.quoteVault }),\n      accountMeta({ pubkey: MODEL_DATA_PUBKEY, isWritable: false }),\n      // serum\n      accountMeta({ pubkey: fromPoolKeys.marketProgramId, isWritable: false }),\n      accountMeta({ pubkey: fromPoolKeys.marketId }),\n      accountMeta({ pubkey: fromPoolKeys.marketBids }),\n      accountMeta({ pubkey: fromPoolKeys.marketAsks }),\n      accountMeta({ pubkey: fromPoolKeys.marketEventQueue }),\n      accountMeta({ pubkey: fromPoolKeys.id }),\n      accountMeta({ pubkey: fromPoolKeys.id }),\n      accountMeta({ pubkey: fromPoolKeys.id }),\n      // user\n      accountMeta({ pubkey: userKeys.inTokenAccount }),\n      accountMeta({ pubkey: userKeys.middleTokenAccount }),\n      accountMeta({ pubkey: userKeys.middleStatusAccount }),\n      accountMeta({ pubkey: userKeys.owner, isWritable: false, isSigner: true }),\n    ];\n  }\n\n  return new TransactionInstruction({\n    programId: ROUTE_PROGRAM_ID_V1,\n    keys,\n    data,\n  });\n}\n\nexport function makeSwapOutFixedInInstruction({\n  fromPoolKeys,\n  toPoolKeys,\n  userKeys,\n}: RouteSwapOutFixedInInstructionParams): TransactionInstruction {\n  const data = Buffer.alloc(routeSwapOutLayout.span);\n\n  let keys;\n  if (toPoolKeys.version === 4) {\n    routeSwapOutLayout.encode(\n      {\n        instruction: 1,\n      },\n      data,\n    );\n    keys = [\n      // system\n      accountMeta({ pubkey: TOKEN_PROGRAM_ID, isWritable: false }),\n      // amm\n      accountMeta({ pubkey: toPoolKeys.programId, isWritable: false }),\n      accountMeta({ pubkey: fromPoolKeys.id, isWritable: false }),\n      accountMeta({ pubkey: toPoolKeys.id }),\n      accountMeta({ pubkey: toPoolKeys.authority, isWritable: false }),\n      accountMeta({ pubkey: toPoolKeys.openOrders }),\n      accountMeta({ pubkey: toPoolKeys.baseVault }),\n      accountMeta({ pubkey: toPoolKeys.quoteVault }),\n      // serum\n      accountMeta({ pubkey: toPoolKeys.marketProgramId, isWritable: false }),\n      accountMeta({ pubkey: toPoolKeys.marketId }),\n      accountMeta({ pubkey: toPoolKeys.marketBids }),\n      accountMeta({ pubkey: toPoolKeys.marketAsks }),\n      accountMeta({ pubkey: toPoolKeys.marketEventQueue }),\n      accountMeta({ pubkey: toPoolKeys.marketBaseVault }),\n      accountMeta({ pubkey: toPoolKeys.marketQuoteVault }),\n      accountMeta({ pubkey: toPoolKeys.marketAuthority, isWritable: false }),\n      // user\n      accountMeta({ pubkey: userKeys.middleTokenAccount }),\n      accountMeta({ pubkey: userKeys.outTokenAccount }),\n      accountMeta({ pubkey: userKeys.middleStatusAccount }),\n      accountMeta({ pubkey: userKeys.owner, isWritable: false, isSigner: true }),\n    ];\n  } else {\n    routeSwapOutLayout.encode(\n      {\n        instruction: 3,\n      },\n      data,\n    );\n    keys = [\n      // system\n      accountMeta({ pubkey: TOKEN_PROGRAM_ID, isWritable: false }),\n      // amm\n      accountMeta({ pubkey: toPoolKeys.programId, isWritable: false }),\n      accountMeta({ pubkey: fromPoolKeys.id, isWritable: false }),\n      accountMeta({ pubkey: toPoolKeys.id }),\n      accountMeta({ pubkey: toPoolKeys.authority, isWritable: false }),\n      accountMeta({ pubkey: toPoolKeys.openOrders }),\n      accountMeta({ pubkey: toPoolKeys.baseVault }),\n      accountMeta({ pubkey: toPoolKeys.quoteVault }),\n      accountMeta({ pubkey: MODEL_DATA_PUBKEY, isWritable: false }),\n      // serum\n      accountMeta({ pubkey: toPoolKeys.marketProgramId, isWritable: false }),\n      accountMeta({ pubkey: toPoolKeys.marketId }),\n      accountMeta({ pubkey: toPoolKeys.marketBids }),\n      accountMeta({ pubkey: toPoolKeys.marketAsks }),\n      accountMeta({ pubkey: toPoolKeys.marketEventQueue }),\n      accountMeta({ pubkey: toPoolKeys.id }),\n      accountMeta({ pubkey: toPoolKeys.id }),\n      accountMeta({ pubkey: toPoolKeys.id }),\n      // user\n      accountMeta({ pubkey: userKeys.middleTokenAccount }),\n      accountMeta({ pubkey: userKeys.outTokenAccount }),\n      accountMeta({ pubkey: userKeys.middleStatusAccount }),\n      accountMeta({ pubkey: userKeys.owner, isWritable: false, isSigner: true }),\n    ];\n  }\n\n  return new TransactionInstruction({\n    programId: ROUTE_PROGRAM_ID_V1,\n    keys,\n    data,\n  });\n}\n","import { struct, u64, u8 } from \"../../marshmallow\";\n\nexport const routeSwapInLayout = struct([u8(\"instruction\"), u64(\"amountIn\"), u64(\"amountOut\")]);\nexport const routeSwapOutLayout = struct([u8(\"instruction\")]);\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { findProgramAddress } from \"../../common/txTool\";\n\nexport async function getAssociatedMiddleStatusAccount({\n  programId,\n  fromPoolId,\n  middleMint,\n  owner,\n}: {\n  programId: PublicKey;\n  fromPoolId: PublicKey;\n  middleMint: PublicKey;\n  owner: PublicKey;\n}): Promise<PublicKey> {\n  const { publicKey } = await findProgramAddress(\n    [fromPoolId.toBuffer(), middleMint.toBuffer(), owner.toBuffer()],\n    programId,\n  );\n  return publicKey;\n}\n"],"mappings":"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","names":[]}