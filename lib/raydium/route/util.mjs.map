{"version":3,"sources":["../../../src/common/txTool.ts","../../../src/common/logger.ts","../../../src/raydium/route/util.ts"],"sourcesContent":["import {\n  Connection,\n  PACKET_DATA_SIZE,\n  PublicKey,\n  RpcResponseAndContext,\n  sendAndConfirmTransaction,\n  Signer,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\n\nimport { SignAllTransactions } from \"../raydium/type\";\n\nimport { createLogger } from \"./logger\";\nimport { Owner } from \"./owner\";\n\nconst logger = createLogger(\"Raydium_txTool\");\ninterface TxBuilderInit {\n  connection: Connection;\n  feePayer: PublicKey;\n  owner?: Owner;\n  signAllTransactions?: SignAllTransactions;\n}\n\nexport interface AddInstructionParam {\n  instructions?: TransactionInstruction[];\n  endInstructions?: TransactionInstruction[];\n  signers?: Signer[];\n}\n\nexport interface TxBuildData {\n  transaction: Transaction;\n  signers: Signer[];\n  execute: () => Promise<string>;\n  extInfo: Record<string, any>;\n}\n\nexport interface MultiTxBuildData {\n  transactions: Transaction[];\n  signers: Signer[][];\n  execute: () => Promise<string[]>;\n  extInfo: Record<string, any>;\n}\n\nexport class TxBuilder {\n  private connection: Connection;\n  private owner?: Owner;\n  private instructions: TransactionInstruction[] = [];\n  private endInstructions: TransactionInstruction[] = [];\n  private signers: Signer[] = [];\n  private feePayer: PublicKey;\n  private signAllTransactions?: SignAllTransactions;\n\n  constructor(params: TxBuilderInit) {\n    this.connection = params.connection;\n    this.feePayer = params.feePayer;\n    this.signAllTransactions = params.signAllTransactions;\n    this.owner = params.owner;\n  }\n\n  get AllTxData(): {\n    instructions: TransactionInstruction[];\n    endInstructions: TransactionInstruction[];\n    signers: Signer[];\n  } {\n    return {\n      instructions: this.instructions,\n      endInstructions: this.endInstructions,\n      signers: this.signers,\n    };\n  }\n\n  get allInstructions(): TransactionInstruction[] {\n    return [...this.instructions, ...this.endInstructions];\n  }\n\n  public addInstruction({ instructions = [], endInstructions = [], signers = [] }: AddInstructionParam): TxBuilder {\n    this.instructions.push(...instructions);\n    this.endInstructions.push(...endInstructions);\n    this.signers.push(...signers);\n    return this;\n  }\n\n  public build(extInfo?: Record<string, any>): TxBuildData {\n    const transaction = new Transaction();\n    if (this.allInstructions.length) transaction.add(...this.allInstructions);\n    transaction.feePayer = this.feePayer;\n\n    return {\n      transaction,\n      signers: this.signers,\n      execute: async (): Promise<string> => {\n        const recentBlockHash = await getRecentBlockHash(this.connection);\n        transaction.recentBlockhash = recentBlockHash;\n        if (this.owner?.isKeyPair) {\n          return sendAndConfirmTransaction(this.connection, transaction, this.signers);\n        }\n        if (this.signAllTransactions) {\n          if (this.signers.length) transaction.partialSign(...this.signers);\n          const txs = await this.signAllTransactions([transaction]);\n          return await this.connection.sendRawTransaction(txs[0].serialize(), { skipPreflight: true });\n        }\n        throw new Error(\"please connect wallet first\");\n      },\n      extInfo: extInfo || {},\n    };\n  }\n\n  public buildMultiTx(params: { extraPreBuildData?: TxBuildData[]; extInfo?: Record<string, any> }): MultiTxBuildData {\n    const { extraPreBuildData = [], extInfo } = params;\n    const { transaction } = this.build(extInfo);\n\n    const filterExtraBuildData = extraPreBuildData.filter((data) => data.transaction.instructions.length > 0);\n\n    const allTransactions: Transaction[] = [...filterExtraBuildData.map((data) => data.transaction), transaction];\n    const allSigners: Signer[][] = [...filterExtraBuildData.map((data) => data.signers), this.signers];\n\n    return {\n      transactions: allTransactions,\n      signers: allSigners,\n      execute: async (): Promise<string[]> => {\n        const recentBlockHash = await getRecentBlockHash(this.connection);\n        if (this.owner?.isKeyPair) {\n          return await Promise.all(\n            allTransactions.map(async (tx, idx) => {\n              tx.recentBlockhash = recentBlockHash;\n              return await sendAndConfirmTransaction(this.connection, tx, allSigners[idx]);\n            }),\n          );\n        }\n        if (this.signAllTransactions) {\n          const partialSignedTxs = allTransactions.map((tx, idx) => {\n            tx.recentBlockhash = recentBlockHash;\n            if (allSigners[idx].length) tx.partialSign(...allSigners[idx]);\n            return tx;\n          });\n          const signedTxs = await this.signAllTransactions(partialSignedTxs);\n\n          const txIds: string[] = [];\n          for (let i = 0; i < signedTxs.length; i += 1) {\n            const txId = await this.connection.sendRawTransaction(signedTxs[i].serialize(), { skipPreflight: true });\n            txIds.push(txId);\n          }\n          return txIds;\n        }\n        throw new Error(\"please connect wallet first\");\n      },\n      extInfo: extInfo || {},\n    };\n  }\n}\n\nexport async function getRecentBlockHash(connection: Connection): Promise<string> {\n  try {\n    return (await connection.getLatestBlockhash?.())?.blockhash || (await connection.getRecentBlockhash()).blockhash;\n  } catch {\n    return (await connection.getRecentBlockhash()).blockhash;\n  }\n}\n\n/**\n * Forecast transaction size\n */\nexport function forecastTransactionSize(instructions: TransactionInstruction[], signers: PublicKey[]): number {\n  if (instructions.length < 1) logger.logWithError(`no instructions provided: ${instructions.toString()}`);\n  if (signers.length < 1) logger.logWithError(`no signers provided:, ${signers.toString()}`);\n\n  const transaction = new Transaction();\n  transaction.recentBlockhash = \"11111111111111111111111111111111\";\n  transaction.feePayer = signers[0];\n  transaction.add(...instructions);\n\n  const message = transaction.compileMessage().serialize();\n  // SIGNATURE_LENGTH = 64\n  const transactionLength = signers.length + signers.length * 64 + message.length;\n  return transactionLength;\n}\n\n/**\n * Simulates multiple instruction\n */\nexport async function simulateMultipleInstruction(\n  connection: Connection,\n  instructions: TransactionInstruction[],\n  keyword: string,\n): Promise<any> {\n  const feePayer = new PublicKey(\"RaydiumSimuLateTransaction11111111111111111\");\n\n  const transactions: Transaction[] = [];\n\n  let transaction = new Transaction();\n  transaction.feePayer = feePayer;\n\n  for (const instruction of instructions) {\n    if (forecastTransactionSize([...transaction.instructions, instruction], [feePayer]) > PACKET_DATA_SIZE) {\n      transactions.push(transaction);\n      transaction = new Transaction();\n      transaction.feePayer = feePayer;\n      transaction.add(instruction);\n    } else {\n      transaction.add(instruction);\n    }\n  }\n  if (transaction.instructions.length > 0) {\n    transactions.push(transaction);\n  }\n\n  let results: RpcResponseAndContext<SimulatedTransactionResponse>[] = [];\n\n  try {\n    results = await Promise.all(transactions.map((transaction) => connection.simulateTransaction(transaction)));\n  } catch (error) {\n    if (error instanceof Error) {\n      logger.logWithError(`failed to simulate for instructions, RPC_ERROR, ${error.message}`);\n    }\n  }\n\n  const logs: string[] = [];\n  for (const result of results) {\n    const { value } = result;\n    logger.debug(`simulate result: ${JSON.stringify(result)}`);\n\n    if (value.logs) {\n      const filteredLog = value.logs.filter((log) => log && log.includes(keyword));\n      logger.debug(`filteredLog: ${JSON.stringify(logs)}`);\n      if (!filteredLog.length) logger.logWithError(` \"simulate log not match keyword, keyword: ${keyword}`);\n      logs.push(...filteredLog);\n    }\n  }\n\n  return logs;\n}\n\nexport function parseSimulateLogToJson(log: string, keyword: string): any {\n  const results = log.match(/{[\"\\w:,]+}/g);\n  if (!results || results.length !== 1) {\n    return logger.logWithError(`simulate log fail to match json, keyword: ${keyword}`);\n  }\n\n  return results[0];\n}\n\nexport function parseSimulateValue(log: string, key: string): any {\n  const reg = new RegExp(`\"${key}\":(\\\\d+)`, \"g\");\n\n  const results = reg.exec(log);\n  if (!results || results.length !== 2) {\n    return logger.logWithError(`simulate log fail to match key\", key: ${key}`);\n  }\n\n  return results[1];\n}\n\nexport interface ProgramAddress {\n  publicKey: PublicKey;\n  nonce: number;\n}\nexport async function findProgramAddress(\n  seeds: Array<Buffer | Uint8Array>,\n  programId: PublicKey,\n): Promise<ProgramAddress> {\n  const [publicKey, nonce] = await PublicKey.findProgramAddress(seeds, programId);\n  return { publicKey, nonce };\n}\n","import { get, set } from \"lodash\";\nimport pino, { LevelWithSilent, Logger } from \"pino\";\nimport pretty from \"pino-pretty\";\n\nexport type ModuleName = \"Common.Api\";\n\nconst moduleLoggers: { [key in ModuleName]?: Logger } = {};\n\nconst moduleLevels: { [key in ModuleName]?: LevelWithSilent } = {};\n\nconst stream = pretty({\n  colorize: true,\n  levelFirst: true,\n  translateTime: \"SYS:yyyymmdd HH:MM:ss.l\",\n});\nconst globalLogger = pino({ base: null, level: \"silent\" }, stream);\n\nexport interface LoggerInstance extends Logger {\n  logWithError: (...args: any) => void;\n}\n\nexport function createLogger(moduleName: string): LoggerInstance {\n  let logger = get(moduleLoggers, moduleName);\n\n  if (!logger) {\n    // default level is silent\n    const level = get(moduleLevels, moduleName);\n\n    logger = globalLogger.child({ name: moduleName }, { level });\n    set(moduleLoggers, moduleName, logger);\n  }\n\n  logger.logWithError = (...args): void => {\n    const msg = args.map((arg) => (typeof arg === \"object\" ? JSON.stringify(arg) : arg)).join(\", \");\n    // logger.error(msg);\n    throw new Error(msg);\n  };\n\n  return logger;\n}\n\nexport function setLoggerLevel(moduleName: ModuleName, level: LevelWithSilent): void {\n  set(moduleLevels, moduleName, level);\n\n  const logger = get(moduleLoggers, moduleName);\n  if (logger) logger.level = level;\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { findProgramAddress } from \"../../common/txTool\";\n\nexport async function getAssociatedMiddleStatusAccount({\n  programId,\n  fromPoolId,\n  middleMint,\n  owner,\n}: {\n  programId: PublicKey;\n  fromPoolId: PublicKey;\n  middleMint: PublicKey;\n  owner: PublicKey;\n}): Promise<PublicKey> {\n  const { publicKey } = await findProgramAddress(\n    [fromPoolId.toBuffer(), middleMint.toBuffer(), owner.toBuffer()],\n    programId,\n  );\n  return publicKey;\n}\n"],"mappings":"AAAA,kHCAA,sCACA,oBACA,2BAIA,GAAM,GAAkD,CAAC,EAEnD,EAA0D,CAAC,EAE3D,EAAS,EAAO,CACpB,SAAU,GACV,WAAY,GACZ,cAAe,yBACjB,CAAC,EACK,EAAe,EAAK,CAAE,KAAM,KAAM,MAAO,QAAS,EAAG,CAAM,EAM1D,WAAsB,EAAoC,CAC/D,GAAI,GAAS,EAAI,EAAe,CAAU,EAE1C,GAAI,CAAC,EAAQ,CAEX,GAAM,GAAQ,EAAI,EAAc,CAAU,EAE1C,EAAS,EAAa,MAAM,CAAE,KAAM,CAAW,EAAG,CAAE,OAAM,CAAC,EAC3D,EAAI,EAAe,EAAY,CAAM,CACvC,CAEA,SAAO,aAAe,IAAI,IAAe,CACvC,GAAM,GAAM,EAAK,IAAI,AAAC,GAAS,MAAO,IAAQ,SAAW,KAAK,UAAU,CAAG,EAAI,CAAI,EAAE,KAAK,IAAI,EAE9F,KAAM,IAAI,OAAM,CAAG,CACrB,EAEO,CACT,CDtBA,GAAM,GAAS,EAAa,gBAAgB,EAiP5C,iBACE,EACA,EACyB,CACzB,GAAM,CAAC,EAAW,GAAS,KAAM,GAAU,mBAAmB,EAAO,CAAS,EAC9E,MAAO,CAAE,YAAW,OAAM,CAC5B,CEpQA,iBAAuD,CACrD,YACA,aACA,aACA,SAMqB,CACrB,GAAM,CAAE,aAAc,KAAM,GAC1B,CAAC,EAAW,SAAS,EAAG,EAAW,SAAS,EAAG,EAAM,SAAS,CAAC,EAC/D,CACF,EACA,MAAO,EACT","names":[]}