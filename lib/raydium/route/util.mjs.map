{"version":3,"sources":["../../../src/common/txTool.ts","../../../src/common/logger.ts","../../../src/raydium/route/util.ts"],"sourcesContent":["import {\n  Connection,\n  PACKET_DATA_SIZE,\n  PublicKey,\n  RpcResponseAndContext,\n  sendAndConfirmTransaction,\n  Signer,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\n\nimport { SignAllTransactions } from \"../raydium/type\";\n\nimport { createLogger } from \"./logger\";\nimport { Owner } from \"./owner\";\n\nconst logger = createLogger(\"Raydium_txTool\");\ninterface TxBuilderInit {\n  connection: Connection;\n  feePayer: PublicKey;\n  owner?: Owner;\n  signAllTransactions?: SignAllTransactions;\n}\n\nexport interface AddInstructionParam {\n  instructions?: TransactionInstruction[];\n  endInstructions?: TransactionInstruction[];\n  signers?: Signer[];\n}\n\nexport interface TxBuildData {\n  transaction: Transaction;\n  signers: Signer[];\n  execute: () => Promise<string>;\n  extInfo: Record<string, any>;\n}\n\nexport interface MultiTxBuildData {\n  transactions: Transaction[];\n  signers: Signer[][];\n  execute: () => Promise<string[]>;\n  extInfo: Record<string, any>;\n}\n\nexport class TxBuilder {\n  private connection: Connection;\n  private owner?: Owner;\n  private instructions: TransactionInstruction[] = [];\n  private endInstructions: TransactionInstruction[] = [];\n  private signers: Signer[] = [];\n  private feePayer: PublicKey;\n  private signAllTransactions?: SignAllTransactions;\n\n  constructor(params: TxBuilderInit) {\n    this.connection = params.connection;\n    this.feePayer = params.feePayer;\n    this.signAllTransactions = params.signAllTransactions;\n    this.owner = params.owner;\n  }\n\n  get AllTxData(): {\n    instructions: TransactionInstruction[];\n    endInstructions: TransactionInstruction[];\n    signers: Signer[];\n  } {\n    return {\n      instructions: this.instructions,\n      endInstructions: this.endInstructions,\n      signers: this.signers,\n    };\n  }\n\n  get allInstructions(): TransactionInstruction[] {\n    return [...this.instructions, ...this.endInstructions];\n  }\n\n  public addInstruction({ instructions = [], endInstructions = [], signers = [] }: AddInstructionParam): TxBuilder {\n    this.instructions.push(...instructions);\n    this.endInstructions.push(...endInstructions);\n    this.signers.push(...signers);\n    return this;\n  }\n\n  public build(extInfo?: Record<string, any>): TxBuildData {\n    const transaction = new Transaction();\n    if (this.allInstructions.length) transaction.add(...this.allInstructions);\n    transaction.feePayer = this.feePayer;\n\n    return {\n      transaction,\n      signers: this.signers,\n      execute: async (): Promise<string> => {\n        const recentBlockHash = await getRecentBlockHash(this.connection);\n        transaction.recentBlockhash = recentBlockHash;\n        if (this.owner?.isKeyPair) {\n          return sendAndConfirmTransaction(this.connection, transaction, this.signers);\n        }\n        if (this.signAllTransactions) {\n          if (this.signers.length) transaction.partialSign(...this.signers);\n          const txs = await this.signAllTransactions([transaction]);\n          return await this.connection.sendRawTransaction(txs[0].serialize(), { skipPreflight: true });\n        }\n        throw new Error(\"please connect wallet first\");\n      },\n      extInfo: extInfo || {},\n    };\n  }\n\n  public buildMultiTx(params: { extraPreBuildData?: TxBuildData[]; extInfo?: Record<string, any> }): MultiTxBuildData {\n    const { extraPreBuildData = [], extInfo } = params;\n    const { transaction } = this.build(extInfo);\n\n    const filterExtraBuildData = extraPreBuildData.filter((data) => data.transaction.instructions.length > 0);\n\n    const allTransactions: Transaction[] = [...filterExtraBuildData.map((data) => data.transaction), transaction];\n    const allSigners: Signer[][] = [...filterExtraBuildData.map((data) => data.signers), this.signers];\n\n    return {\n      transactions: allTransactions,\n      signers: allSigners,\n      execute: async (): Promise<string[]> => {\n        const recentBlockHash = await getRecentBlockHash(this.connection);\n        if (this.owner?.isKeyPair) {\n          return await Promise.all(\n            allTransactions.map(async (tx, idx) => {\n              tx.recentBlockhash = recentBlockHash;\n              return await sendAndConfirmTransaction(this.connection, tx, allSigners[idx]);\n            }),\n          );\n        }\n        if (this.signAllTransactions) {\n          const partialSignedTxs = allTransactions.map((tx, idx) => {\n            tx.recentBlockhash = recentBlockHash;\n            if (allSigners[idx].length) tx.partialSign(...allSigners[idx]);\n            return tx;\n          });\n          const signedTxs = await this.signAllTransactions(partialSignedTxs);\n\n          const txIds: string[] = [];\n          for (let i = 0; i < signedTxs.length; i += 1) {\n            const txId = await this.connection.sendRawTransaction(signedTxs[i].serialize(), { skipPreflight: true });\n            txIds.push(txId);\n          }\n          return txIds;\n        }\n        throw new Error(\"please connect wallet first\");\n      },\n      extInfo: extInfo || {},\n    };\n  }\n}\n\nexport async function getRecentBlockHash(connection: Connection): Promise<string> {\n  try {\n    return (await connection.getLatestBlockhash?.())?.blockhash || (await connection.getRecentBlockhash()).blockhash;\n  } catch {\n    return (await connection.getRecentBlockhash()).blockhash;\n  }\n}\n\n/**\n * Forecast transaction size\n */\nexport function forecastTransactionSize(instructions: TransactionInstruction[], signers: PublicKey[]): number {\n  if (instructions.length < 1) logger.logWithError(`no instructions provided: ${instructions.toString()}`);\n  if (signers.length < 1) logger.logWithError(`no signers provided:, ${signers.toString()}`);\n\n  const transaction = new Transaction();\n  transaction.recentBlockhash = \"11111111111111111111111111111111\";\n  transaction.feePayer = signers[0];\n  transaction.add(...instructions);\n\n  const message = transaction.compileMessage().serialize();\n  // SIGNATURE_LENGTH = 64\n  const transactionLength = signers.length + signers.length * 64 + message.length;\n  return transactionLength;\n}\n\n/**\n * Simulates multiple instruction\n */\nexport async function simulateMultipleInstruction(\n  connection: Connection,\n  instructions: TransactionInstruction[],\n  keyword: string,\n): Promise<any> {\n  const feePayer = new PublicKey(\"RaydiumSimuLateTransaction11111111111111111\");\n\n  const transactions: Transaction[] = [];\n\n  let transaction = new Transaction();\n  transaction.feePayer = feePayer;\n\n  for (const instruction of instructions) {\n    if (forecastTransactionSize([...transaction.instructions, instruction], [feePayer]) > PACKET_DATA_SIZE) {\n      transactions.push(transaction);\n      transaction = new Transaction();\n      transaction.feePayer = feePayer;\n      transaction.add(instruction);\n    } else {\n      transaction.add(instruction);\n    }\n  }\n  if (transaction.instructions.length > 0) {\n    transactions.push(transaction);\n  }\n\n  let results: RpcResponseAndContext<SimulatedTransactionResponse>[] = [];\n\n  try {\n    results = await Promise.all(transactions.map((transaction) => connection.simulateTransaction(transaction)));\n  } catch (error) {\n    if (error instanceof Error) {\n      logger.logWithError(`failed to simulate for instructions, RPC_ERROR, ${error.message}`);\n    }\n  }\n\n  const logs: string[] = [];\n  for (const result of results) {\n    const { value } = result;\n    logger.debug(`simulate result: ${JSON.stringify(result)}`);\n\n    if (value.logs) {\n      const filteredLog = value.logs.filter((log) => log && log.includes(keyword));\n      logger.debug(`filteredLog: ${JSON.stringify(logs)}`);\n      if (!filteredLog.length) logger.logWithError(` \"simulate log not match keyword, keyword: ${keyword}`);\n      logs.push(...filteredLog);\n    }\n  }\n\n  return logs;\n}\n\nexport function parseSimulateLogToJson(log: string, keyword: string): any {\n  const results = log.match(/{[\"\\w:,]+}/g);\n  if (!results || results.length !== 1) {\n    return logger.logWithError(`simulate log fail to match json, keyword: ${keyword}`);\n  }\n\n  return results[0];\n}\n\nexport function parseSimulateValue(log: string, key: string): any {\n  const reg = new RegExp(`\"${key}\":(\\\\d+)`, \"g\");\n\n  const results = reg.exec(log);\n  if (!results || results.length !== 2) {\n    return logger.logWithError(`simulate log fail to match key\", key: ${key}`);\n  }\n\n  return results[1];\n}\n\nexport interface ProgramAddress {\n  publicKey: PublicKey;\n  nonce: number;\n}\nexport async function findProgramAddress(\n  seeds: Array<Buffer | Uint8Array>,\n  programId: PublicKey,\n): Promise<ProgramAddress> {\n  const [publicKey, nonce] = await PublicKey.findProgramAddress(seeds, programId);\n  return { publicKey, nonce };\n}\n","import { get, set } from \"lodash\";\nimport dayjs from \"dayjs\";\nimport utc from \"dayjs/plugin/utc\";\ndayjs.extend(utc);\n\nexport type ModuleName = \"Common.Api\";\n\nexport enum LogLevel {\n  Error,\n  Warning,\n  Info,\n  Debug,\n}\nexport class Logger {\n  private logLevel: LogLevel;\n  private name: string;\n  constructor(params: { name: string; logLevel?: LogLevel }) {\n    this.logLevel = params.logLevel !== undefined ? params.logLevel : LogLevel.Debug;\n    this.name = params.name;\n  }\n\n  set level(logLevel: LogLevel) {\n    this.logLevel = logLevel;\n  }\n  get time(): string {\n    return dayjs().utc().format(\"YYYY/MM/DD HH:mm:ss UTC\");\n  }\n  get moduleName(): string {\n    return this.name;\n  }\n\n  private isLogLevel(level: LogLevel): boolean {\n    return level <= this.logLevel;\n  }\n\n  public error(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Error)) return this;\n    console.error(this.time, this.name, \"sdk logger error\", ...props);\n    return this;\n  }\n\n  public logWithError(...props): Logger {\n    // this.error(...props)\n    const msg = props.map((arg) => (typeof arg === \"object\" ? JSON.stringify(arg) : arg)).join(\", \");\n    throw new Error(msg);\n  }\n\n  public warning(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Warning)) return this;\n    console.warn(this.time, this.name, \"sdk logger warning\", ...props);\n    return this;\n  }\n\n  public info(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Info)) return this;\n    console.info(this.time, this.name, \"sdk logger info\", ...props);\n    return this;\n  }\n\n  public debug(...props): Logger {\n    if (!this.isLogLevel(LogLevel.Debug)) return this;\n    console.debug(this.time, this.name, \"sdk logger debug\", ...props);\n    return this;\n  }\n}\n\nconst moduleLoggers: { [key in ModuleName]?: Logger } = {};\nconst moduleLevels: { [key in ModuleName]?: LogLevel } = {};\n\nexport function createLogger(moduleName: string): Logger {\n  let logger = get(moduleLoggers, moduleName);\n  if (!logger) {\n    // default level is error\n    const logLevel = get(moduleLevels, moduleName);\n\n    logger = new Logger({ name: moduleName, logLevel });\n    set(moduleLoggers, moduleName, logger);\n  }\n\n  return logger;\n}\n\nexport function setLoggerLevel(moduleName: string, level: LogLevel): void {\n  set(moduleLevels, moduleName, level);\n\n  const logger = get(moduleLoggers, moduleName);\n  if (logger) logger.level = level;\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { findProgramAddress } from \"../../common/txTool\";\n\nexport async function getAssociatedMiddleStatusAccount({\n  programId,\n  fromPoolId,\n  middleMint,\n  owner,\n}: {\n  programId: PublicKey;\n  fromPoolId: PublicKey;\n  middleMint: PublicKey;\n  owner: PublicKey;\n}): Promise<PublicKey> {\n  const { publicKey } = await findProgramAddress(\n    [fromPoolId.toBuffer(), middleMint.toBuffer(), owner.toBuffer()],\n    programId,\n  );\n  return publicKey;\n}\n"],"mappings":"AAAA,kHCAA,sCACA,qBACA,gCACA,EAAM,OAAO,CAAG,EAUT,WAAa,CAGlB,YAAY,EAA+C,CACzD,KAAK,SAAW,EAAO,WAAa,OAAY,EAAO,SAAW,EAClE,KAAK,KAAO,EAAO,IACrB,IAEI,OAAM,EAAoB,CAC5B,KAAK,SAAW,CAClB,IACI,OAAe,CACjB,MAAO,GAAM,EAAE,IAAI,EAAE,OAAO,yBAAyB,CACvD,IACI,aAAqB,CACvB,MAAO,MAAK,IACd,CAEQ,WAAW,EAA0B,CAC3C,MAAO,IAAS,KAAK,QACvB,CAEO,SAAS,EAAe,CAC7B,MAAK,MAAK,WAAW,CAAc,EACnC,SAAQ,MAAM,KAAK,KAAM,KAAK,KAAM,mBAAoB,GAAG,CAAK,EACzD,MAFsC,IAG/C,CAEO,gBAAgB,EAAe,CAEpC,GAAM,GAAM,EAAM,IAAI,AAAC,GAAS,MAAO,IAAQ,SAAW,KAAK,UAAU,CAAG,EAAI,CAAI,EAAE,KAAK,IAAI,EAC/F,KAAM,IAAI,OAAM,CAAG,CACrB,CAEO,WAAW,EAAe,CAC/B,MAAK,MAAK,WAAW,CAAgB,EACrC,SAAQ,KAAK,KAAK,KAAM,KAAK,KAAM,qBAAsB,GAAG,CAAK,EAC1D,MAFwC,IAGjD,CAEO,QAAQ,EAAe,CAC5B,MAAK,MAAK,WAAW,CAAa,EAClC,SAAQ,KAAK,KAAK,KAAM,KAAK,KAAM,kBAAmB,GAAG,CAAK,EACvD,MAFqC,IAG9C,CAEO,SAAS,EAAe,CAC7B,MAAK,MAAK,WAAW,CAAc,EACnC,SAAQ,MAAM,KAAK,KAAM,KAAK,KAAM,mBAAoB,GAAG,CAAK,EACzD,MAFsC,IAG/C,CACF,EAEM,EAAkD,CAAC,EACnD,EAAmD,CAAC,EAEnD,WAAsB,EAA4B,CACvD,GAAI,GAAS,EAAI,EAAe,CAAU,EAC1C,GAAI,CAAC,EAAQ,CAEX,GAAM,GAAW,EAAI,EAAc,CAAU,EAE7C,EAAS,GAAI,GAAO,CAAE,KAAM,EAAY,UAAS,CAAC,EAClD,EAAI,EAAe,EAAY,CAAM,CACvC,CAEA,MAAO,EACT,CD/DA,GAAM,GAAS,EAAa,gBAAgB,EAiP5C,iBACE,EACA,EACyB,CACzB,GAAM,CAAC,EAAW,GAAS,KAAM,GAAU,mBAAmB,EAAO,CAAS,EAC9E,MAAO,CAAE,YAAW,OAAM,CAC5B,CEpQA,iBAAuD,CACrD,YACA,aACA,aACA,SAMqB,CACrB,GAAM,CAAE,aAAc,KAAM,GAC1B,CAAC,EAAW,SAAS,EAAG,EAAW,SAAS,EAAG,EAAM,SAAS,CAAC,EAC/D,CACF,EACA,MAAO,EACT","names":[]}